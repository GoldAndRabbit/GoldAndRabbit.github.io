<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Leetcode_hot_100 总结 | G&amp;R Blog</title>
  <meta name="keywords" content="">
  <meta name="description" content="Leetcode_hot_100 总结 | G&amp;R Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="Overview1.BERT is basically a trained Transformer Encoder stack.   2.Both BERT model sizes have a large number of encoder layers (which the paper calls Transformer Blocks) – twelve for the Base ve">
<meta property="og:type" content="website">
<meta property="og:title" content="Bert">
<meta property="og:url" content="http://example.com/hist_articles/Bert.html">
<meta property="og:site_name" content="G&amp;R Blog">
<meta property="og:description" content="Overview1.BERT is basically a trained Transformer Encoder stack.   2.Both BERT model sizes have a large number of encoder layers (which the paper calls Transformer Blocks) – twelve for the Base ve">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s3.ax1x.com/2020/12/16/r1tx0A.png">
<meta property="og:image" content="https://s3.ax1x.com/2020/12/16/r1tWy4.png">
<meta property="og:image" content="https://s3.ax1x.com/2020/12/16/r1tcWT.png">
<meta property="og:image" content="https://s3.ax1x.com/2020/12/16/r1tfOJ.png">
<meta property="og:image" content="https://s3.ax1x.com/2020/12/16/r1tRlF.png">
<meta property="og:image" content="https://s3.ax1x.com/2020/12/16/r1t2SU.png">
<meta property="og:image" content="https://s3.ax1x.com/2020/12/16/r1tx0A.png">
<meta property="article:published_time" content="2020-12-16T13:56:00.000Z">
<meta property="article:modified_time" content="2025-04-28T09:12:10.794Z">
<meta property="article:author" content="G&amp;R">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.ax1x.com/2020/12/16/r1tx0A.png">


<link rel="icon" href="/img/fox.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-dark.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="G&R Blog" type="application/atom+xml">
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/fox.jpg"/>
</a>
<div class="author">
    <span>G&amp;R</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/goldandrabbit"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:goldandrabbit@foxmail.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(170)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="Ads_RecSys">
            
            Ads_RecSys
            <small>(34)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Algorithm">
            
            Algorithm
            <small>(70)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Coding">
            
            Coding
            <small>(33)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="ML_DL_LLM">
            
            ML_DL_LLM
            <small>(14)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Reading">
            
            Reading
            <small>(12)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Rethinking">
            
            Rethinking
            <small>(7)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="170">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="search shortcut key i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="switch to outline view shortcut key w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="return"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="case sensitive"></i>
            <i class="iconfont icon-tag" data-title="label"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">outline</div>
            <i class="iconfont icon-list" data-title="switch to article list"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All Coding "
           href="/2099/01/30/G&R%20Blog%20Release%20Regulation/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="G&amp;R Blog Release Regulation">G&amp;R Blog Release Regulation</span>
            <span class="post-date" title="2099-01-30 20:00:00">2099/01/30</span>
        </a>
        
        
        <a  class="All ML_DL_LLM "
           href="/2099/01/01/A%20Collection%20of%20High-Quality%20Blog/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="A Collection of High-Quality Blog">A Collection of High-Quality Blog</span>
            <span class="post-date" title="2099-01-01 20:28:00">2099/01/01</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2025/02/01/Linux%20Access%20the%20Open%20Internet/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux Access the Open Internet">Linux Access the Open Internet</span>
            <span class="post-date" title="2025-02-01 20:43:00">2025/02/01</span>
        </a>
        
        
        <a  class="All Rethinking "
           href="/2024/12/29/2024%20Annual%20Summary/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2024 Annual Summary">2024 Annual Summary</span>
            <span class="post-date" title="2024-12-29 09:00:00">2024/12/29</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2024/10/30/Ubuntu%2024.04%20Upgrade%20Log/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Ubuntu 24.04 Upgrade Log">Ubuntu 24.04 Upgrade Log</span>
            <span class="post-date" title="2024-10-30 20:00:00">2024/10/30</span>
        </a>
        
        
        <a  class="All ML_DL_LLM "
           href="/2024/09/05/LLaMA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="LLaMA">LLaMA</span>
            <span class="post-date" title="2024-09-05 20:00:00">2024/09/05</span>
        </a>
        
        
        <a  class="All ML_DL_LLM "
           href="/2024/06/30/Large%20Language%20Model/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Large Language Model">Large Language Model</span>
            <span class="post-date" title="2024-06-30 20:00:00">2024/06/30</span>
        </a>
        
        
        <a  class="All ML_DL_LLM "
           href="/2024/05/30/Decoder-only%20transformer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Decoder-only transformer">Decoder-only transformer</span>
            <span class="post-date" title="2024-05-30 20:00:00">2024/05/30</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2024/03/22/Ubuntu%2022.04%20Upgrade%20Log/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Ubuntu 22.04 Upgrade Log">Ubuntu 22.04 Upgrade Log</span>
            <span class="post-date" title="2024-03-22 10:11:00">2024/03/22</span>
        </a>
        
        
        <a  class="All Rethinking "
           href="/2024/02/20/2023%20Annual%20Summary/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2023 Annual Summary">2023 Annual Summary</span>
            <span class="post-date" title="2024-02-20 20:00:00">2024/02/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2024/01/20/CREAD%20A%20Classification-Restoration%20Framework%20with%20Error%20Adaptive%20Discretization%20for%20Watch%20Time%20Prediction%20in%20Video%20Recommender%20Systems/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CREAD A Classification-Restoration Framework with Error Adaptive Discretization for Watch Time Prediction in Video Recommender Systems">CREAD A Classification-Restoration Framework with Error Adaptive Discretization for Watch Time Prediction in Video Recommender Systems</span>
            <span class="post-date" title="2024-01-20 20:20:00">2024/01/20</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2024/01/11/%E4%BB%8E%E6%89%BE%E4%BA%8B%E7%90%86%E8%AE%BA%E5%88%B0%20TRIZ/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="从找事理论到 TRIZ">从找事理论到 TRIZ</span>
            <span class="post-date" title="2024-01-11 20:11:00">2024/01/11</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/12/30/Joint%20Optimization%20of%20Ranking%20and%20Calibration%20with%20Contextualized%20Hybrid%20Model/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Joint Optimization of Ranking and Calibration with Contextualized Hybrid Model">Joint Optimization of Ranking and Calibration with Contextualized Hybrid Model</span>
            <span class="post-date" title="2023-12-30 20:43:00">2023/12/30</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/11/20/Multi-Scenario%20Ranking%20with%20Adaptive%20Feature%20Learning/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Multi-Scenario Ranking with Adaptive Feature Learning">Multi-Scenario Ranking with Adaptive Feature Learning</span>
            <span class="post-date" title="2023-11-20 20:08:00">2023/11/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/11/20/Towards%20Deeper,%20Lighter%20and%20Interpretable%20Cross%20Network%20for%20CTR%20Prediction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Towards Deeper, Lighter and Interpretable Cross Network for CTR Prediction">Towards Deeper, Lighter and Interpretable Cross Network for CTR Prediction</span>
            <span class="post-date" title="2023-11-20 20:08:00">2023/11/20</span>
        </a>
        
        
        <a  class="All ML_DL_LLM "
           href="/2023/10/20/Self-Attention%20with%20Relative%20Position%20Representations/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Self-Attention with Relative Position Representations">Self-Attention with Relative Position Representations</span>
            <span class="post-date" title="2023-10-20 20:08:00">2023/10/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/10/15/RankFlow%20Joint%20Optimization%20of%20Multi-Stage%20Cascade%20Ranking%20Systems%20as%20Flows/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RankFlow Joint Optimization of Multi-Stage Cascade Ranking Systems as Flows">RankFlow Joint Optimization of Multi-Stage Cascade Ranking Systems as Flows</span>
            <span class="post-date" title="2023-10-15 13:08:00">2023/10/15</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/10/11/SHARK%20A%20Lightweight%20Model%20Compression%20Approach%20for%20Large-scale%20Recommender%20Systems/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SHARK A Lightweight Model Compression Approach for Large-scale Recommender Systems">SHARK A Lightweight Model Compression Approach for Large-scale Recommender Systems</span>
            <span class="post-date" title="2023-10-11 20:43:00">2023/10/11</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2023/09/21/Say%20Good%20Night%20To%20Insomnia/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Say Good Night To Insomnia">Say Good Night To Insomnia</span>
            <span class="post-date" title="2023-09-21 20:43:00">2023/09/21</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/09/20/Scenario-Adaptive%20Feature%20Interaction%20for%20Click-Through%20Rate%20Prediction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Scenario-Adaptive Feature Interaction for Click-Through Rate Prediction">Scenario-Adaptive Feature Interaction for Click-Through Rate Prediction</span>
            <span class="post-date" title="2023-09-20 20:43:00">2023/09/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/08/20/Gini%20Coefficient%20%E5%9F%BA%E5%B0%BC%E7%B3%BB%E6%95%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Gini Coefficient 基尼系数">Gini Coefficient 基尼系数</span>
            <span class="post-date" title="2023-08-20 20:08:00">2023/08/20</span>
        </a>
        
        
        <a  class="All ML_DL_LLM "
           href="/2023/08/20/Pairwise%20%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Pairwise 损失函数计算">Pairwise 损失函数计算</span>
            <span class="post-date" title="2023-08-20 20:08:00">2023/08/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/08/13/A%20Simple%20Framework%20for%20Contrastive%20Learning%20of%20Visual%20Representations/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="A Simple Framework for Contrastive Learning of Visual Representations">A Simple Framework for Contrastive Learning of Visual Representations</span>
            <span class="post-date" title="2023-08-13 20:43:00">2023/08/13</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/07/20/Delving%20into%20Deep%20Imbalanced%20Regression/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Delving into Deep Imbalanced Regression">Delving into Deep Imbalanced Regression</span>
            <span class="post-date" title="2023-07-20 20:43:00">2023/07/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/07/18/CASPR:%20Customer%20Activity%20Sequence-based%20Prediction%20and%20Representation/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CASPR Customer Activity Sequence-based Prediction and Representation">CASPR Customer Activity Sequence-based Prediction and Representation</span>
            <span class="post-date" title="2023-07-18 20:00:00">2023/07/18</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/07/13/DCN%20V2%20Improved%20Deep%20&%20Cross%20Network%20and%20Practical%20Lessons%20for%20Web-scale%20Learning%20to%20Rank%20Systems/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DCN V2 Improved Deep &amp; Cross Network and Practical Lessons for Web-scale Learning to Rank Systems">DCN V2 Improved Deep &amp; Cross Network and Practical Lessons for Web-scale Learning to Rank Systems</span>
            <span class="post-date" title="2023-07-13 20:00:00">2023/07/13</span>
        </a>
        
        
        <a  class="All ML_DL_LLM "
           href="/2023/07/05/Learning%20to%20Rank%20From%20Pairwise%20Approach%20to%20Listwise%20Approach/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Learning to Rank From Pairwise Approach to Listwise Approach">Learning to Rank From Pairwise Approach to Listwise Approach</span>
            <span class="post-date" title="2023-07-05 20:08:00">2023/07/05</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/07/03/Billion-user%20Customer%20Lifetime%20Value%20Prediction%20An%20Industrial-scale%20Solution%20from%20Kuaishou/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Billion-user Customer Lifetime Value Prediction An Industrial-scale Solution from Kuaishou">Billion-user Customer Lifetime Value Prediction An Industrial-scale Solution from Kuaishou</span>
            <span class="post-date" title="2023-07-03 20:00:00">2023/07/03</span>
        </a>
        
        
        <a  class="All ML_DL_LLM "
           href="/2023/06/29/Ord2Seq%20Regarding%20Ordinal%20Regression%20as%20Label%20Sequence%20Prediction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Ord2Seq Regarding Ordinal Regression as Label Sequence Prediction">Ord2Seq Regarding Ordinal Regression as Label Sequence Prediction</span>
            <span class="post-date" title="2023-06-29 20:08:00">2023/06/29</span>
        </a>
        
        
        <a  class="All ML_DL_LLM "
           href="/2023/06/21/Selective-Supervised%20Contrastive%20Learning%20with%20Noisy%20Labels/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Selective-Supervised Contrastive Learning with Noisy Labels">Selective-Supervised Contrastive Learning with Noisy Labels</span>
            <span class="post-date" title="2023-06-21 20:08:00">2023/06/21</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/06/20/Contrastive%20Multi-view%20Framework%20for%20Customer%20Lifetime%20Value%20Prediction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Contrastive Multi-view Framework for Customer Lifetime Value Prediction">Contrastive Multi-view Framework for Customer Lifetime Value Prediction</span>
            <span class="post-date" title="2023-06-20 20:43:00">2023/06/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/06/18/Ads_Target%20CPX%20v.s.%20Max%20Return/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Ads_Target CPX v.s. Max Return">Ads_Target CPX v.s. Max Return</span>
            <span class="post-date" title="2023-06-18 00:11:10">2023/06/18</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/06/18/Ads_%E9%A2%84%E6%9C%9F%E8%8A%B1%E8%B4%B9%E4%B8%8E%E5%90%8E%E9%AA%8C%E9%A2%84%E6%9C%9F%E8%8A%B1%E8%B4%B9/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Ads_预期花费与后验预期花费">Ads_预期花费与后验预期花费</span>
            <span class="post-date" title="2023-06-18 00:10:10">2023/06/18</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/06/15/MAE%20v.s.%20MSE%20%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E6%AF%94%E8%BE%83/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MAE v.s. MSE 损失函数比较">MAE v.s. MSE 损失函数比较</span>
            <span class="post-date" title="2023-06-15 20:43:00">2023/06/15</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/06/13/A%20Deep%20Probabilistic%20Model%20For%20Customer%20Lifetime%20Value%20Prediction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="A Deep Probabilistic Model For Customer Lifetime Value Prediction">A Deep Probabilistic Model For Customer Lifetime Value Prediction</span>
            <span class="post-date" title="2023-06-13 20:43:00">2023/06/13</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2023/05/30/Jen-Hsun%20Huang%20Stanford%20student%20and%20Entrpreneur,%20co-founder%20and%20CEO%20of%20NVIDIA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Jen-Hsun Huang Stanford student and Entrpreneur, co-founder and CEO of NVIDIA">Jen-Hsun Huang Stanford student and Entrpreneur, co-founder and CEO of NVIDIA</span>
            <span class="post-date" title="2023-05-30 20:43:00">2023/05/30</span>
        </a>
        
        
        <a  class="All Rethinking "
           href="/2023/05/20/2022%20Annual%20Summary/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2022 Annual Summary">2022 Annual Summary</span>
            <span class="post-date" title="2023-05-20 20:00:00">2023/05/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/05/12/Contrastive%20Learning%20for%20Conversion%20Rate%20Prediction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Contrastive Learning for Conversion Rate Prediction">Contrastive Learning for Conversion Rate Prediction</span>
            <span class="post-date" title="2023-05-12 20:43:00">2023/05/12</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/01/20/Follow%20the%20Prophet%20Accurate%20Online%20Conversion%20Rate%20Prediction%20in%20the%20Face%20of%20Delayed%20Feedback/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Follow the Prophet Accurate Online Conversion Rate Prediction in the Face of Delayed Feedback">Follow the Prophet Accurate Online Conversion Rate Prediction in the Face of Delayed Feedback</span>
            <span class="post-date" title="2023-01-20 20:08:00">2023/01/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/09/20/Tree%20based%20Progressive%20Regression%20Model%20for%20Watch-Time%20Prediction%20in%20Short-video%20Recommendation/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Tree based Progressive Regression Model for Watch-Time Prediction in Short-video Recommendation">Tree based Progressive Regression Model for Watch-Time Prediction in Short-video Recommendation</span>
            <span class="post-date" title="2022-09-20 20:08:00">2022/09/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/08/12/Field-aware%20Calibration%20A%20Simple%20and%20Empirically%20Strong%20Method%20for%20Reliable%20Probabilistic%20Predictions/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Field-aware Calibration A Simple and Empirically Strong Method for Reliable Probabilistic Predictions">Field-aware Calibration A Simple and Empirically Strong Method for Reliable Probabilistic Predictions</span>
            <span class="post-date" title="2022-08-12 20:43:00">2022/08/12</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/05/21/TabTransformer%20Tabular%20Data%20Modeling%20Using%20Contextual%20Embeddings/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TabTransformer Tabular Data Modeling Using Contextual Embeddings">TabTransformer Tabular Data Modeling Using Contextual Embeddings</span>
            <span class="post-date" title="2022-05-21 20:43:00">2022/05/21</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/05/20/FinalMLP:%20An%20Enhanced%20Two-Stream%20MLP%20Model%20for%20CTR%20Prediction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="FinalMLP An Enhanced Two-Stream MLP Model for CTR Prediction">FinalMLP An Enhanced Two-Stream MLP Model for CTR Prediction</span>
            <span class="post-date" title="2022-05-20 20:43:00">2022/05/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/05/15/H&M%20Recommendation%20Competition%20Top1%20%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="H&amp;M Recommendation Competition Top1 方案">H&amp;M Recommendation Competition Top1 方案</span>
            <span class="post-date" title="2022-05-15 23:55:00">2022/05/15</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/03/20/Deep%20Interest%20Highlight%20Network%20for%20Click-Through%20Rate%20Prediction%20in%20Trigger-Induced%20Recommendation/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Deep Interest Highlight Network for Click-Through Rate Prediction in Trigger-Induced Recommendation">Deep Interest Highlight Network for Click-Through Rate Prediction in Trigger-Induced Recommendation</span>
            <span class="post-date" title="2022-03-20 22:00:00">2022/03/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/03/20/Progressive%20Layered%20Extraction%20(PLE)%20A%20Novel%20Multi-Task%20Learning%20(MTL)%20Model%20for%20Personalized%20Recommendations/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Progressive Layered Extraction (PLE) A Novel Multi-Task Learning (MTL) Model for Personalized Recommendations">Progressive Layered Extraction (PLE) A Novel Multi-Task Learning (MTL) Model for Personalized Recommendations</span>
            <span class="post-date" title="2022-03-20 20:08:00">2022/03/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/03/12/Mechanism%20Design%20%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1_1_Learning-based%20Mechanism/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mechanism Design 机制设计_1_Learning-based Mechanism">Mechanism Design 机制设计_1_Learning-based Mechanism</span>
            <span class="post-date" title="2022-03-12 23:00:00">2022/03/12</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/02/20/Mechanism%20Design%20%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mechanism Design 机制设计_0_overview">Mechanism Design 机制设计_0_overview</span>
            <span class="post-date" title="2022-02-20 20:00:00">2022/02/20</span>
        </a>
        
        
        <a  class="All Rethinking "
           href="/2022/02/07/2021%20Annual%20Summary/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2021 Annual Summary">2021 Annual Summary</span>
            <span class="post-date" title="2022-02-07 12:11:00">2022/02/07</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2021/11/11/Cybernetics%20and%20Society%20%E6%8E%A7%E5%88%B6%E8%AE%BA%E4%B8%8E%E7%A4%BE%E4%BC%9A/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cybernetics and Society 控制论与社会">Cybernetics and Society 控制论与社会</span>
            <span class="post-date" title="2021-11-11 21:00:00">2021/11/11</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2021/09/10/Bias%20and%20Debias%20in%20Recommender%20System%20%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%20bias%20%E5%92%8C%20debias/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Bias and Debias in Recommender System 推荐系统中的 bias 和 debias">Bias and Debias in Recommender System 推荐系统中的 bias 和 debias</span>
            <span class="post-date" title="2021-09-10 21:00:00">2021/09/10</span>
        </a>
        
        
        <a  class="All ML_DL_LLM "
           href="/2021/08/11/Supervised%20Contrastive%20Learning/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Supervised Contrastive Learning">Supervised Contrastive Learning</span>
            <span class="post-date" title="2021-08-11 20:43:00">2021/08/11</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2021/06/20/Multi-Task%20Learning%20Using%20Uncertainty%20to%20Weigh%20Losses%20for%20Scene%20Geometry%20and%20Semantics/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Multi-Task Learning Using Uncertainty to Weigh Losses for Scene Geometry and Semantics">Multi-Task Learning Using Uncertainty to Weigh Losses for Scene Geometry and Semantics</span>
            <span class="post-date" title="2021-06-20 20:08:00">2021/06/20</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2021/05/20/Causal%20Inference%20%E5%9B%A0%E6%9E%9C%E6%8E%A8%E6%96%AD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Causal Inference 因果推断">Causal Inference 因果推断</span>
            <span class="post-date" title="2021-05-20 20:00:00">2021/05/20</span>
        </a>
        
        
        <a  class="All Rethinking "
           href="/2020/12/31/2020%20Annual%20Summary/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2020 Annual Summary">2020 Annual Summary</span>
            <span class="post-date" title="2020-12-31 23:11:00">2020/12/31</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2020/12/20/Shoe%20Dog%20%E9%9E%8B%E7%8B%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shoe Dog 鞋狗">Shoe Dog 鞋狗</span>
            <span class="post-date" title="2020-12-20 18:53:00">2020/12/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2020/11/08/The%20Essence%20of%20RecSys%20%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%B2%BE%E8%A6%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="The Essence of RecSys 推荐系统精要">The Essence of RecSys 推荐系统精要</span>
            <span class="post-date" title="2020-11-08 11:56:00">2020/11/08</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/10/01/Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hexo 博客搭建总结">Hexo 博客搭建总结</span>
            <span class="post-date" title="2020-10-01 20:11:00">2020/10/01</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_0_1_cpp%20%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_0_1_cpp 设计哲学">cpp_0_1_cpp 设计哲学</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_0_1_vscode%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_0_1_vscode 环境配置">cpp_0_1_vscode 环境配置</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_0_3_%E8%B0%B7%E6%AD%8C%20C++%20%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_0_3_谷歌 C++ 编程风格">cpp_0_3_谷歌 C++ 编程风格</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_0_2_%E5%A4%B4%E6%96%87%E4%BB%B6%20header%20file/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_0_2_头文件 headerfile">cpp_0_2_头文件 headerfile</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_1_1_%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_1_1_左值和右值">cpp_1_1_左值和右值</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_1_3_%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%20Rvalue%20reference/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_1_3_右值引用 Rvalue reference">cpp_1_3_右值引用 Rvalue reference</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_1_2_%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%20Lvalue%20reference/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_1_2_左值引用 Lvalue reference">cpp_1_2_左值引用 Lvalue reference</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_2_1_%E6%8C%87%E9%92%88%20Pointer_1_%E5%9C%B0%E5%9D%80%E5%92%8C%E6%8C%87%E9%92%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_2_1_指针 Pointer_1_地址和指针">cpp_2_1_指针 Pointer_1_地址和指针</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_2_2_%E6%8C%87%E9%92%88%20Pointer_2_%E7%A9%BA%E6%8C%87%E9%92%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_2_2_指针 Pointer_2_空指针">cpp_2_2_指针 Pointer_2_空指针</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_2_3_%E6%8C%87%E9%92%88%20Pointer_3_const%20%E4%B8%8E%E6%8C%87%E9%92%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_2_3_指针 Pointer_3_const 与指针">cpp_2_3_指针 Pointer_3_const 与指针</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_2_4_%E6%8C%87%E9%92%88%20Pointer_4_%E4%BC%A0%E5%9C%B0%E5%9D%80%20Pass%20by%20address/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_2_4_指针 Pointer_4_传地址 Pass by address">cpp_2_4_指针 Pointer_4_传地址 Pass by address</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_2_5_%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88_0_%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_2_5_智能指针_0_设计思想">cpp_2_5_智能指针_0_设计思想</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_2_6_%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88_1_shared_ptr/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_2_6_智能指针_1_shared_ptr">cpp_2_6_智能指针_1_shared_ptr</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_2_7_%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88_2_unique_ptr/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_2_7_智能指针_2_unique_ptr">cpp_2_7_智能指针_2_unique_ptr</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_3_0_constexpr%20%E5%85%B3%E9%94%AE%E5%AD%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_3_0_constexpr关键字">cpp_3_0_constexpr关键字</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_3_1_const%20%E5%85%B3%E9%94%AE%E5%AD%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_3_1_const 关键字">cpp_3_1_const 关键字</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_3_2_Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_3_2_Lambda 表达式">cpp_3_2_Lambda 表达式</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_5_1_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_5_1_面向对象_0_overview">cpp_5_1_面向对象_0_overview</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_5_2_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_1_%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_5_2_面向对象_1_类和成员函数">cpp_5_2_面向对象_1_类和成员函数</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_5_3_%E5%A4%9A%E6%80%81_0_%E8%99%9A%E5%87%BD%E6%95%B0%20Virtual%20Functions/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_5_3_多态_0_虚函数 Virtual Functions">cpp_5_3_多态_0_虚函数 Virtual Functions</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_6_0_%E6%A8%A1%E6%9D%BF%20template/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_6_0_模板 template">cpp_6_0_模板 template</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/08/20/Python_%E5%A4%9A%E8%BF%9B%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Python_多进程">Python_多进程</span>
            <span class="post-date" title="2020-08-20 20:08:00">2020/08/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2020/08/15/%E6%B7%B1%E5%BA%A6%E7%82%B9%E5%87%BB%E7%8E%87%E9%A2%84%E4%BC%B0%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E7%89%B9%E5%BE%81%E4%BA%A4%E5%8F%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深度点击率预估模型中的特征交叉">深度点击率预估模型中的特征交叉</span>
            <span class="post-date" title="2020-08-15 20:11:00">2020/08/15</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2020/07/18/Leetcode_hot_100%20%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Leetcode_hot_100 总结">Leetcode_hot_100 总结</span>
            <span class="post-date" title="2020-07-18 22:56:00">2020/07/18</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2020/04/13/Status%20as%20a%20Service%20%E5%9C%B0%E4%BD%8D%E5%8D%B3%E6%9C%8D%E5%8A%A1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Status as a Service 地位即服务">Status as a Service 地位即服务</span>
            <span class="post-date" title="2020-04-13 20:13:00">2020/04/13</span>
        </a>
        
        
        <a  class="All ML_DL_LLM "
           href="/2020/04/04/Faiss%20%E5%90%91%E9%87%8F%E6%A3%80%E7%B4%A2%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Faiss 向量检索库">Faiss 向量检索库</span>
            <span class="post-date" title="2020-04-04 20:11:00">2020/04/04</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2020/03/22/%E7%8B%BC%E4%BA%BA%E6%9D%80%E5%A6%82%E4%BD%95%E8%87%B4%E8%83%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="狼人杀如何致胜">狼人杀如何致胜</span>
            <span class="post-date" title="2020-03-22 02:12:57">2020/03/22</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2020/02/18/David%20Stern,%20who%20turned%20NBA%20into%20powerhouse/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="David Stern, who turned NBA into powerhouse">David Stern, who turned NBA into powerhouse</span>
            <span class="post-date" title="2020-02-18 22:56:00">2020/02/18</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/02/18/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux 常用命令总结">Linux 常用命令总结</span>
            <span class="post-date" title="2020-02-18 22:56:00">2020/02/18</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/02/13/Tensorflow%20API%20%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Tensorflow API 总结">Tensorflow API 总结</span>
            <span class="post-date" title="2020-02-13 22:56:00">2020/02/13</span>
        </a>
        
        
        <a  class="All ML_DL_LLM "
           href="/2020/02/03/Transformer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Transformer">Transformer</span>
            <span class="post-date" title="2020-02-03 11:56:00">2020/02/03</span>
        </a>
        
        
        <a  class="All ML_DL_LLM "
           href="/2020/01/11/Tricks%20in%20Data%20Mining%20Competitions%20%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%E6%8A%80%E5%B7%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Tricks in Data Mining Competitions 数据挖掘比赛技巧">Tricks in Data Mining Competitions 数据挖掘比赛技巧</span>
            <span class="post-date" title="2020-01-11 20:11:00">2020/01/11</span>
        </a>
        
        
        <a  class="All ML_DL_LLM "
           href="/2020/01/11/Word2Vec/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Word2Vec">Word2Vec</span>
            <span class="post-date" title="2020-01-11 20:11:00">2020/01/11</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2020/01/11/Yoshua%20Bengio%20%E5%AF%B9%20ML%20%E7%A0%94%E7%A9%B6%E8%80%85%E7%9A%84%E5%BB%BA%E8%AE%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Yoshua Bengio 对 ML 研究者的建议">Yoshua Bengio 对 ML 研究者的建议</span>
            <span class="post-date" title="2020-01-11 20:11:00">2020/01/11</span>
        </a>
        
        
        <a  class="All Rethinking "
           href="/2019/12/31/2019%20Annual%20Summary/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2019 Annual Summary">2019 Annual Summary</span>
            <span class="post-date" title="2019-12-31 15:11:00">2019/12/31</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2019/12/11/Data%20Analysis%20Tutorial:(Part%20I)/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Data Analysis Tutorial:(Part I)">Data Analysis Tutorial:(Part I)</span>
            <span class="post-date" title="2019-12-11 20:11:00">2019/12/11</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2019/11/03/Marketing%20Management%20%E8%90%A5%E9%94%80%E7%AE%A1%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Marketing Management 营销管理">Marketing Management 营销管理</span>
            <span class="post-date" title="2019-11-03 13:03:00">2019/11/03</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2019/10/01/Interview%20record%20of%20ML%20intern%20in%202019/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Interview record of ML intern in 2019">Interview record of ML intern in 2019</span>
            <span class="post-date" title="2019-10-01 12:12:57">2019/10/01</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2019/05/01/Errors%20Archives%20%E6%8A%A5%E9%94%99%E5%BD%92%E6%A1%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Errors Archives 报错归档">Errors Archives 报错归档</span>
            <span class="post-date" title="2019-05-01 13:03:00">2019/05/01</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2019/03/20/Modeling%20Task%20Relationships%20in%20Multi-task%20Learning%20with%20Multi-gate%20Mixture-of-Experts/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Modeling Task Relationships in Multi-task Learning with Multi-gate Mixture-of-Experts">Modeling Task Relationships in Multi-task Learning with Multi-gate Mixture-of-Experts</span>
            <span class="post-date" title="2019-03-20 20:43:00">2019/03/20</span>
        </a>
        
        
        <a  class="All Rethinking "
           href="/2018/12/31/2018%20Annual%20Summary/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2018 Annual Summary">2018 Annual Summary</span>
            <span class="post-date" title="2018-12-31 20:17:00">2018/12/31</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/DivideConquer_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DivideConquer_0_overview">DivideConquer_0_overview</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/Hash_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hash_0_overview">Hash_0_overview</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/Heap_1_application/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Heap_1_application">Heap_1_application</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/IntervalProblem_%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IntervalProblem_区间问题">IntervalProblem_区间问题</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2018/06/10/LinkedList_%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="LinkedList_链表操作">LinkedList_链表操作</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/Trie_%E5%89%8D%E7%BC%80%E6%A0%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Trie_前缀树">Trie_前缀树</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/TwoPointers_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TwoPointers_0_overview">TwoPointers_0_overview</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/TwoPointers_1_%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TwoPointers_1_快慢指针">TwoPointers_1_快慢指针</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/TwoPointers_2_%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TwoPointers_2_左右指针">TwoPointers_2_左右指针</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/TwoPointers_4_Rabin_Karp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TwoPointers_4_Rabin_Karp">TwoPointers_4_Rabin_Karp</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/TwoPointers_3_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TwoPointers_3_滑动窗口">TwoPointers_3_滑动窗口</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/TwoPointers_5_%E9%93%BE%E8%A1%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TwoPointers_5_链表">TwoPointers_5_链表</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/TwoPointers_6_n%E6%95%B0%E4%B9%8B%E5%92%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TwoPointers_6_n数之和">TwoPointers_6_n数之和</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/TwoPointers_7_%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TwoPointers_7_荷兰国旗">TwoPointers_7_荷兰国旗</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/UnionFind_%E5%B9%B6%E6%9F%A5%E9%9B%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="UnionFind_并查集">UnionFind_并查集</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2018/04/05/Git%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git 使用指南">Git 使用指南</span>
            <span class="post-date" title="2018-04-05 22:56:00">2018/04/05</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Stack_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Stack_0_overview">Stack_0_overview</span>
            <span class="post-date" title="2018-01-19 01:10:00">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Stack_1_%E5%8D%95%E8%B0%83%E6%A0%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Stack_1_单调栈">Stack_1_单调栈</span>
            <span class="post-date" title="2018-01-19 01:09:00">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Stack_2_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Stack_2_表达式解码">Stack_2_表达式解码</span>
            <span class="post-date" title="2018-01-19 01:08:00">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Sort_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Sort_0_overview">Sort_0_overview</span>
            <span class="post-date" title="2018-01-19 00:10:00">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Sort_1_mergeSort_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Sort_1_mergeSort_归并排序">Sort_1_mergeSort_归并排序</span>
            <span class="post-date" title="2018-01-19 00:09:01">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Sort_1_insertionSort_%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Sort_1_insertionSort_插入排序">Sort_1_insertionSort_插入排序</span>
            <span class="post-date" title="2018-01-19 00:09:00">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Sort_2_quickSort_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Sort_2_quickSort_快速排序">Sort_2_quickSort_快速排序</span>
            <span class="post-date" title="2018-01-19 00:08:01">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Sort_2_Partition_%E5%88%92%E5%88%86%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Sort_2_Partition_划分算法">Sort_2_Partition_划分算法</span>
            <span class="post-date" title="2018-01-19 00:08:00">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Sort_3_heapSort_%E5%A0%86%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Sort_3_heapSort_堆排序">Sort_3_heapSort_堆排序</span>
            <span class="post-date" title="2018-01-19 00:07:00">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Sort_4_application_%E6%8E%92%E5%BA%8F%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Sort_4_application_排序题">Sort_4_application_排序题</span>
            <span class="post-date" title="2018-01-19 00:06:00">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Greedy_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Greedy_0_overview">Greedy_0_overview</span>
            <span class="post-date" title="2018-01-07 01:10:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Graph_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Graph_0_overview">Graph_0_overview</span>
            <span class="post-date" title="2018-01-07 00:10:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Graph_1_dfs_%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Graph_1_dfs_深度优先遍历">Graph_1_dfs_深度优先遍历</span>
            <span class="post-date" title="2018-01-07 00:09:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Graph_2_bfs_%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Graph_2_bfs_广度优先遍历">Graph_2_bfs_广度优先遍历</span>
            <span class="post-date" title="2018-01-07 00:08:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Graph_3_%E7%8E%AF%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Graph_3_环检测与拓扑排序">Graph_3_环检测与拓扑排序</span>
            <span class="post-date" title="2018-01-07 00:08:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Graph_4_%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Graph_4_岛屿问题">Graph_4_岛屿问题</span>
            <span class="post-date" title="2018-01-07 00:06:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Graph_5_Kruskal/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Graph_5_Kruskal">Graph_5_Kruskal</span>
            <span class="post-date" title="2018-01-07 00:05:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Graph_6_Prim/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Graph_6_Prim">Graph_6_Prim</span>
            <span class="post-date" title="2018-01-07 00:04:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Graph_7_Dijstra/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Graph_7_Dijstra">Graph_7_Dijstra</span>
            <span class="post-date" title="2018-01-07 00:03:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/04/DP_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DP_0_overview">DP_0_overview</span>
            <span class="post-date" title="2018-01-04 01:10:00">2018/01/04</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/04/DP_1_%E5%A4%87%E5%BF%98%E5%BD%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DP_1_备忘录">DP_1_备忘录</span>
            <span class="post-date" title="2018-01-04 01:09:00">2018/01/04</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/04/DP_2_%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DP_2_最值问题">DP_2_最值问题</span>
            <span class="post-date" title="2018-01-04 01:08:00">2018/01/04</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/04/DP_3_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%BF%98%E6%98%AF%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DP_3_自顶向下还是自底向上">DP_3_自顶向下还是自底向上</span>
            <span class="post-date" title="2018-01-04 01:07:01">2018/01/04</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/04/DP_3_%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DP_3_背包问题">DP_3_背包问题</span>
            <span class="post-date" title="2018-01-04 01:07:00">2018/01/04</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/04/DP_4_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DP_4_买卖股票">DP_4_买卖股票</span>
            <span class="post-date" title="2018-01-04 01:06:00">2018/01/04</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/04/DP_5_%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DP_5_打家劫舍">DP_5_打家劫舍</span>
            <span class="post-date" title="2018-01-04 01:05:00">2018/01/04</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/04/DP_6_%E9%AB%98%E7%BB%B4%20dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DP_6_高维 dp">DP_6_高维 dp</span>
            <span class="post-date" title="2018-01-04 01:04:00">2018/01/04</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/03/cache_LFU/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cache_LFU">cache_LFU</span>
            <span class="post-date" title="2018-01-03 01:10:00">2018/01/03</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/03/cache_LRU/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cache_LRU">cache_LRU</span>
            <span class="post-date" title="2018-01-03 00:10:00">2018/01/03</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/Bit_%E4%BD%8D%E8%BF%90%E7%AE%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Bit_位运算">Bit_位运算</span>
            <span class="post-date" title="2018-01-02 04:00:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/Bipartite_%E4%BA%8C%E5%88%86%E5%9B%BE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Bipartite_二分图">Bipartite_二分图</span>
            <span class="post-date" title="2018-01-02 03:00:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_0_overview">BinaryTree_0_overview</span>
            <span class="post-date" title="2018-01-02 02:10:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_1_%E5%88%86%E8%A7%A3%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_1_分解问题">BinaryTree_1_分解问题</span>
            <span class="post-date" title="2018-01-02 02:09:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_2_%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_2_路径问题">BinaryTree_2_路径问题</span>
            <span class="post-date" title="2018-01-02 02:08:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_3_%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_3_迭代遍历">BinaryTree_3_迭代遍历</span>
            <span class="post-date" title="2018-01-02 02:07:01">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_3_%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_3_层序遍历">BinaryTree_3_层序遍历</span>
            <span class="post-date" title="2018-01-02 02:07:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_4_%E6%9E%84%E9%80%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_4_构造">BinaryTree_4_构造</span>
            <span class="post-date" title="2018-01-02 02:06:01">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_4_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E5%8C%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_4_二叉树和链表的互相转化">BinaryTree_4_二叉树和链表的互相转化</span>
            <span class="post-date" title="2018-01-02 02:06:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_5_%E5%BA%8F%E5%88%97%E5%8C%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_4_二叉树和链表的互相转化">BinaryTree_4_二叉树和链表的互相转化</span>
            <span class="post-date" title="2018-01-02 02:05:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_6_BST_%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_6_BST_特性">BinaryTree_6_BST_特性</span>
            <span class="post-date" title="2018-01-02 02:04:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_7_BST_%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E9%AA%8C%E8%AF%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_7_BST_查找插入删除验证">BinaryTree_7_BST_查找插入删除验证</span>
            <span class="post-date" title="2018-01-02 02:03:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_8_BST_%E6%9E%84%E9%80%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_8_BST_构造">BinaryTree_8_BST_构造</span>
            <span class="post-date" title="2018-01-02 02:02:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinarySearch_0_%E9%97%AD%E5%8C%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80%E6%90%9C%E7%B4%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinarySearch_0_闭区间搜索和左闭右开搜索">BinarySearch_0_闭区间搜索和左闭右开搜索</span>
            <span class="post-date" title="2018-01-02 01:10:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinarySearch_1_%E5%8D%95%E8%B0%83%E7%BB%93%E6%9E%84%E4%B8%8B%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinarySearch_1_单调结构下二分搜索">BinarySearch_1_单调结构下二分搜索</span>
            <span class="post-date" title="2018-01-02 01:09:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinarySearch_2_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinarySearch_2_旋转数组二分搜索">BinarySearch_2_旋转数组二分搜索</span>
            <span class="post-date" title="2018-01-02 01:08:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinarySearch_3_%E5%8D%95%E8%B0%83%E6%80%A7%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinarySearch_3_单调性应用问题的二分搜索">BinarySearch_3_单调性应用问题的二分搜索</span>
            <span class="post-date" title="2018-01-02 01:07:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/Backtrack_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Backtrack_0_overview">Backtrack_0_overview</span>
            <span class="post-date" title="2018-01-02 00:10:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/Backtrack_1_N%E7%9A%87%E5%90%8E%E5%92%8C%E8%A7%A3%E6%95%B0%E7%8B%AC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Backtrack_1_N皇后和解数独">Backtrack_1_N皇后和解数独</span>
            <span class="post-date" title="2018-01-02 00:09:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/Backtrack_2_%E7%94%9F%E6%88%90%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%AD%90%E9%9B%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Backtrack_2_生成排列组合子集">Backtrack_2_生成排列组合子集</span>
            <span class="post-date" title="2018-01-02 00:08:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/01/Array_1_0_%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Array_1_0_前缀和数组与差分数组">Array_1_0_前缀和数组与差分数组</span>
            <span class="post-date" title="2018-01-01 00:10:10">2018/01/01</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/01/Array_1_1_%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Array_1_差分数组">Array_1_差分数组</span>
            <span class="post-date" title="2018-01-01 00:09:10">2018/01/01</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/01/Array_2_%E8%8A%B1%E5%BC%8F%E6%90%9C%E7%B4%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Array_2_花式搜索">Array_2_花式搜索</span>
            <span class="post-date" title="2018-01-01 00:08:00">2018/01/01</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/01/Array_3_%E5%9B%BE%E5%83%8F%E7%BF%BB%E8%BD%AC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Array_3_图像翻转">Array_3_图像翻转</span>
            <span class="post-date" title="2018-01-01 00:07:00">2018/01/01</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/01/Array_4_%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Array_4_环形数组">Array_4_环形数组</span>
            <span class="post-date" title="2018-01-01 00:06:00">2018/01/01</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/01/Array_5_%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Array_5_矩阵操作">Array_5_矩阵操作</span>
            <span class="post-date" title="2018-01-01 00:05:00">2018/01/01</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="Toggle full screen shortcut key s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-Leetcode_hot_100 总结" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Leetcode_hot_100 总结</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Algorithm">Algorithm</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2025-04-28 17:20:54'>2020-07-18 22:56</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-text">哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">1.两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-text">49.字母异位词分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-text">128.最长连续序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">双指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-text">283.移动零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">11.盛最多水的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">15.三数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-text">42.接雨水</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-text">3.无重复字符的最长子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-text">438.找到字符串中所有字母异位词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E4%B8%B2"><span class="toc-text">子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#560-%E5%92%8C%E4%B8%BA-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">560.和为 K 的子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">239.滑动窗口最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-text">76.最小覆盖子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%95%B0%E7%BB%84"><span class="toc-text">普通数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-text">53.最大子数组和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-text">56.合并区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-text">189.轮转数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-text">238.除自身以外数组的乘积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0"><span class="toc-text">41.缺失的第一个正数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5"><span class="toc-text">矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6"><span class="toc-text">73.矩阵置零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-text">54.螺旋矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="toc-text">48.旋转图像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II"><span class="toc-text">240.搜索二维矩阵 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-text">160.相交链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">206.反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-text">234.回文链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-text">141.环形链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="toc-text">142.环形链表 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">21.合并两个有序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-text">2.两数相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-text">19.删除链表的倒数第 N 个结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">24.两两交换链表中的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">25.K 个一组翻转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#138-%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">138.随机链表的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">148.排序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">23.合并 K 个升序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#146-LRU-%E7%BC%93%E5%AD%98"><span class="toc-text">146.LRU 缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">94.二叉树的中序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text">104.二叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">226.翻转二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">101.对称二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="toc-text">543.二叉树的直径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">102.二叉树的层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">108.将有序数组转换为二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">98.验证二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">230.二叉搜索树中第K小的元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-text">199.二叉树的右视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-text">114.二叉树展开为链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">105.从前序与中序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-text">437.路径总和 III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">236.二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text">124.二叉树中的最大路径和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-text">图论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-text">200.岛屿数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90"><span class="toc-text">994.腐烂的橘子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#207-%E8%AF%BE%E7%A8%8B%E8%A1%A8"><span class="toc-text">207.课程表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-text">208.实现 Trie (前缀树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">46.全排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86"><span class="toc-text">78.子集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-text">17.电话号码的字母组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39.组合总和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-text">22.括号生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="toc-text">79.单词搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-text">131.分割回文串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-N-%E7%9A%87%E5%90%8E"><span class="toc-text">51.N 皇后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-text">35.搜索插入位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="toc-text">74.搜索二维矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-text">34.在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">33.搜索旋转排序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-text">153.寻找旋转排序数组中的最小值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-text">4.寻找两个正序数组的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-text">20.有效的括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-text">155.最小栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="toc-text">394.字符串解码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="toc-text">739.每日温度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><span class="toc-text">84.柱状图中最大的矩形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-text">堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">215.数组中的第K个最大的元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-text">347.前 K 个高频元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-text">295.数据流的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-text">贪心算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-text">121.买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-text">55.跳跃游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II"><span class="toc-text">45.跳跃游戏 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="toc-text">763.划分字母区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text">70.爬楼梯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="toc-text">118.杨辉三角</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198.打家劫舍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-text">279.完全平方数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-text">322.零钱兑换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-text">139.单词拆分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">300.最长递增子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">152.乘积最大子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-text">416.分割等和子集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-text">32.最长有效括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">多维动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-text">62.不同路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text">64.最小路径和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-text">5.最长回文子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">1143.最长公共子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-text">72.编辑距离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E5%B7%A7"><span class="toc-text">技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">136.只出现一次的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="toc-text">169.多数元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="toc-text">75.颜色分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-text">31.下一个排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="toc-text">287.寻找重复数</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div align="center">
<img src="/imgs/leetcode/0.png" width="80%"/>
</div>

<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><blockquote>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p>
<p>示例 1：输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p>
<p>示例 2：输入：nums = [3,2,4], target = 6 输出：[1,2]</p>
<p>示例 3：输入：nums = [3,3], target = 6 输出：[0,1]</p>
</blockquote>
<p>分析:<br>1.遍历数组, 同时 hash 记录当前已经保存过的数字的索引, 遇到互补元素则可以找到两数之和;  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; num2idx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (num2idx.<span class="built_in">find</span>(target - nums[i]) != num2idx.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;num2idx[target-nums[i]], i&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      num2idx[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a>49.字母异位词分组</h2><blockquote>
<p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。字母异位词是由重新排列源单词的所有字母得到的一个新单词。</p>
<p>示例 1: 输入: strs = [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”] 输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</p>
<p>示例 2: 输入: strs = [“”] 输出: [[“”]]</p>
<p>示例 3: 输入: strs = [“a”] 输出: [[“a”]]</p>
</blockquote>
<p>分析:<br>1.按照每一类异位词进行分组哈希, 然后遍历哈希表, 哈希函数设计成什么呢?<br>2.一种简单的做法是 26 个字符出现的次数拼起来的字符串, 对于 abd 来说就是 “11010000..00” 这样, 但是一个词出现的次数大于 10 次造成冲突, 所以在每个位置之间增加一个分隔符, 比如 1#1#0#1..#0#  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; group2strs;</span><br><span class="line">    <span class="keyword">auto</span> hash = [] (string s) &#123;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; <span class="built_in">cnt</span>(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span> c: s) &#123;</span><br><span class="line">        cnt[c - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>; </span><br><span class="line">      &#125;</span><br><span class="line">      string hashStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> c: cnt) &#123;</span><br><span class="line">        hashStr += <span class="built_in">to_string</span>(c) + <span class="string">&quot;#&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> hashStr;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s: strs) &#123;</span><br><span class="line">      group2strs[<span class="built_in">hash</span>(s)].<span class="built_in">push_back</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: group2strs) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(x.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128.最长连续序列"></a>128.最长连续序列</h2><blockquote>
<p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<p>示例 1：输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</p>
<p>示例 2：输入：nums = [0,3,7,2,5,8,4,6,0,1] 输出：9</p>
</blockquote>
<p>分析:<br>1.时间复杂度要求是 O(n), 排序之类的都不能用<br>2.这里关键是分析连续序列有什么特殊性? 对于连续的序列, 它的很多子序列对我们计算最长序列长度没有影响, 比如对 1,2,3,4 这个序列, 对于它的子序列, 例如 2,3,4 或者 3,4, 不会增加最大长度序列的可能性; 如果能想到研究对象缩短到研究, 当前的数字是否是某个最长序列的 [判断可能是一个最长连续序列的起点], 那么复杂度就不会增加; 也就是说, 我们对任意一个数字, 判断当前的数字是 [可能是一个最长连续序列的起点] 的时候, 才会进入内层统计长度, 因此时间复杂度是 O(n)<br>3.用一个 set 去保存元素, 然后遍历 set , 每个元素首先检查是否是第一个元素, 如果不是那么就不进入扫描最长连续长度   </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: s) &#123;</span><br><span class="line">      <span class="comment">// 判断可能是一个最长连续序列的起点</span></span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">count</span>(x - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cur = x;</span><br><span class="line">        <span class="comment">// 进入里面开始逐个判断以它为起点的最长长度</span></span><br><span class="line">        <span class="keyword">while</span> (s.<span class="built_in">count</span>(cur + <span class="number">1</span>)) &#123;</span><br><span class="line">          ++len;</span><br><span class="line">          ++cur;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(len, ans);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h2><blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。请注意，必须在不复制数组的情况下原地对数组进行操作。</p>
<p>示例 1: 输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0]</p>
<p>示例 2: 输入: nums = [0] 输出: [0]</p>
</blockquote>
<p>分析:<br>1.把所有的 0 移动到末尾, 等同于把所有的非0元素移动到最前面, 然后将后面的全部置为零; 要求就地复制元素实现, 维护快慢双指针, fast 检索所有非0的元素之后给到 slow<br>2.fast 检索完之后, 从 slow 开始后面的元素都设置成 0  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="comment">// fast 给到 slow 将非 0 元素移动到最前面</span></span><br><span class="line">    <span class="keyword">while</span> (fast &lt; len) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>) &#123;</span><br><span class="line">        nums[slow] = nums[fast];</span><br><span class="line">        ++slow;</span><br><span class="line">      &#125;</span><br><span class="line">      ++fast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把 slow 之后的都设置为 0 </span></span><br><span class="line">    <span class="keyword">while</span> (slow &lt; len) &#123;</span><br><span class="line">      nums[slow] = <span class="number">0</span>;</span><br><span class="line">      ++slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h2><blockquote>
<p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。说明：你不能倾斜容器。</p>
<p>示例 1：输入：[1,8,6,2,5,4,8,3,7] 输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p>示例 2：输入：height = [1,1] 输出：1</p>
</blockquote>
<p>分析:<br>1.我们找出来两个左右两个端点, 然后计算最大的盛出来的水量, 假设我们已经有了这么两个最优的端点, 盛出来水的量是什么?<br>直接求面积, 面积的公式是什么? 假设我们确定了左右两个指针 left, right, 长就是 right - left, 宽是什么 ? 其实和木桶原理有点像, 承载的水是两边比较低的那头, 也就是 min(left, right);<br>curArea = min(left, right) * (right - left)<br>2.所以怎么搜索最大的面积呢 ? 一开始肯定是从最左边和最右边两个端点开始, 计算一个 curArea; 然后怎么更新呢? 每次是移动左边的指针还是移动右边的指针? 因为面积是取决于左右两边的最小值, 也就是说, 我们需要每次更新的是比当前下界更高的那个下界, 才能有机会找到更大的面积, 因此我们每次移动的是当前的 left 和 right 中间较小的一个指针  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = height.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">int</span> curArea = <span class="built_in">min</span>(height[left], height[right]) * (right - left);</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, curArea);</span><br><span class="line">      <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">        ++left;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        --right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><blockquote>
<p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。</p>
<p>示例 1：输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]]<br>解释：<br>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。<br>nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。<br>nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br>注意，输出的顺序和三元组的顺序并不重要。</p>
<p>示例 2：输入：nums = [0,1,1] 输出：[]  解释：唯一可能的三元组和不为 0 。</p>
<p>示例 3：输入：nums = [0,0,0] 输出：[[0,0,0]]  解释：唯一可能的三元组和为 0 。</p>
</blockquote>
<p>分析:<br>1.因为只是判断存在性, 元素前后不存在先后顺序, 所以先排序<br>2.对所有的元素扫描, 固定住当前的第 i 个元素, 在后面的数组用双指针搜索 complement == nums[left] + nums[right] == - nums[i] 的情况<br>3.因为我们要的结果是不重复的三元组, 如果当前的元素和前面的一个元素相等, 就会多计算一次, 所以在找的时候直接过掉这一次; 在左右指针搜索的时候, 也要注意避免重复的结果 push  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 当前元素作为最小的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; ++i) &#123;</span><br><span class="line">      <span class="comment">// 最小的元素&gt;0, 后面都不用搜索了</span></span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果当前元素和前面元素相同, 不再重复判断, 否则会造成结果重复</span></span><br><span class="line">      <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> complement = -nums[i];</span><br><span class="line">      <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] + nums[right] == complement) &#123;</span><br><span class="line">          ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">          <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left<span class="number">+1</span>]) &#123;</span><br><span class="line">            ++left;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right<span class="number">-1</span>]) &#123;</span><br><span class="line">            --right;</span><br><span class="line">          &#125;</span><br><span class="line">          ++left;</span><br><span class="line">          --right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; complement) &#123;</span><br><span class="line">          ++left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &gt; complement) &#123;</span><br><span class="line">          --right;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.接雨水</h2><blockquote>
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>示例 1：输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p>
<p>示例 2：输入：height = [4,2,0,3,2,5] 输出：9</p>
</blockquote>
<p>分析:<br>1.需要分析接到的水量是怎么计算的, 从直观感觉来算, 对于 (示例图里面) 出现的【凹槽里面水】, 要计算接到的雨水数量, 怎么累计全部凹槽的雨水量呢 ? 我们先考虑对于1个位置来说, 比如针对第i个位置上, 最大能接到的水怎么算?<br>2.对于最左边和最右边的位置, 不管多高或者多低, 题意背景下都是接不到水的, 所以我们考察的是 [1, n-1] 这些位置上的 i 的获得水量, 针对第i个位置上, 水量怎么计算呢?<br>3.类似木桶原理, 对于第i个位置上的接水量, 第一感觉上取决于左边和右边的较低的一方, 但是还有一种情况是考虑凹槽是 [T字型] 的这种情况, 所以就不可以仅考虑 i 位置相邻的 [i-1, i+1] 的情况, 而是要确定位置 i 左右两侧各自最高度的的情况, 然后再去取左右两侧所有最高度的最小高度; 同时, 对于 i 位置自己本身也是有高度的, 假设左边柱子最高的高度是比位置i还要低的, 那么计算一边的最低位置也要考虑算自己<br>4.总结: 对于位置 i, 能接雨水的量为: min(i左侧所有(含i)最高柱子, 右侧所有(含有i)最高柱子) - height[i]  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">water[i] = <span class="built_in">min</span>(<span class="built_in">max</span>(height[<span class="number">0.</span>.i]), <span class="built_in">max</span>(height[i..n<span class="number">-1</span>])) - height[i];</span><br></pre></td></tr></table></figure>
<p>5.代码思路: 从左往右累加第 i 个位置上的雨水值; 对于第 i 个位置, 分别计算它左侧 (包括自己) 的最高值, 计算右侧的最高值, 然后取二者的最小值, 在减去自己位置 i 的高度, 得到的就是第 i 个位置上的接水量, 因此我们得到最 naive 的版本  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> leftSideMax = <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> rightSideMax = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        leftSideMax = <span class="built_in">max</span>(leftSideMax, height[j]);</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">        rightSideMax = <span class="built_in">max</span>(rightSideMax, height[j]);</span><br><span class="line">      &#125;</span><br><span class="line">      ans += <span class="built_in">min</span>(leftSideMax, rightSideMax) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>6.naive 版本显示超时, 超时的原因是第i个位置上计算时, 每次计算左边右边的最大值都会重复遍历一遍, 可以用备忘录把这个记下来, 其实就是记录下来了左边或者右边最大高度的状态转移关系 (将这道题当做动态规划来做); 状态初始条件是什么? 比如对于 leftMaxMemo[0] 记录的是第0个元素左边的最大, rightMaxMemo[0] 记录的是右边最后一个元素的最大, 为了后续结果计算不影响, 我们将左边最大和右边最大分别设置成最左边的1个元素高度和右边最后一个元素的高度;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftMaxMemo</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightMaxMemo</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始条件</span></span><br><span class="line">leftMaxMemo[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">rightMaxMemo[n<span class="number">-1</span>] = height[n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态转移</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">  leftMaxMemo[i] = <span class="built_in">max</span>(height[i], leftMaxMemo[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态转移</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">  rightMaxMemo[i] = <span class="built_in">max</span>(height[i], rightMaxMemo[i<span class="number">+1</span>]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>7.有了状态转移的备忘录, solution 如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = height.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftMaxMemo</span><span class="params">(len)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightMaxMemo</span><span class="params">(len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始条件: 设置第0位置元素左边最大为第 0 个元素的高度, 设置第 n-1 位置元素右边最大为第 n-1 个元素的高度</span></span><br><span class="line">    <span class="comment">// 不影响状态转移计算的结果</span></span><br><span class="line">    leftMaxMemo[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    rightMaxMemo[len<span class="number">-1</span>] = height[len<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造左侧最大的 memo: 状态转移为 max(height[i], leftMaxMemo[i-1])</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">      leftMaxMemo[i] = <span class="built_in">max</span>(height[i], leftMaxMemo[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造右侧侧最大的 memo 状态转移为 max(height[i], rightMaxMemo[i-1])</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">      rightMaxMemo[i] = <span class="built_in">max</span>(height[i], rightMaxMemo[i<span class="number">+1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len<span class="number">-2</span>; ++i) &#123;</span><br><span class="line">      ans += <span class="built_in">min</span>(leftMaxMemo[i], rightMaxMemo[i]) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>8.左右双指针两边向中间逼近思路 (可以先参考下另一个问题 11.盛最多水的容器 再回来看这个问题)<br>在动态规划的方法中, 我们考察的是 左侧 [0..i] 区间 和右侧 [i..n-1] 区间的各自区间最大值, 但我们最终是关心 min(leftSideMax, rightSideMax), 也就是只关心两边各自最大中的 [最小的一个]<br>假如我们知道在 leftMax &lt; rightMax 的情况下, 那么右边最大的是多少暂时不重要, 只需要关心 height[i] 和 已经被确认是较低的 leftMax 去运算<br>而且我们发现动态规划的时候, 左边指针单项往右扫, 右边指针单项向右扫, 扫完一个位置之后都是就不回来了, 每个位置上只扫一次, 在这种设定下, 实质上考察 左侧[0..left] 区间和 右侧[right..n-1] 区间, 且 left 指针始终向右扫, right始终向左扫  </p>
<p>9.我们只对维护左边和右边两个指针去保存, 而不是按照整个数组去保存, 看下能否实现: 用左右两个指针去扫描, 判断哪个指针扫过的最高柱子更小, 就移动哪个指针, 同时累加当前的扫过的接水量  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> leftMaxPtr  = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rightMaxPtr = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (leftMaxPtr &lt; rightMaxPtr) &#123;</span><br><span class="line">      <span class="comment">// 左右指针向中央逼近, 只找两边各自最大的里面更小的一个</span></span><br><span class="line">      leftMax  = <span class="built_in">max</span>(leftMax,  height[leftMaxPtr]);</span><br><span class="line">      rightMax = <span class="built_in">max</span>(rightMax, height[rightMaxPtr]);</span><br><span class="line">      <span class="comment">// 哪边更小, 累加哪边的雨水, 同时也移动哪边的指针;</span></span><br><span class="line">      <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">        ans += leftMax - height[leftMaxPtr];</span><br><span class="line">        ++leftMaxPtr;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans += rightMax - height[rightMaxPtr];</span><br><span class="line">        --rightMaxPtr;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><blockquote>
<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1: 输入: s = “abcabcbb” 输出: 3  解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>示例 2：输入: s = “bbbbb” 输出: 1 解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p>示例 3: 输入: s = “pwwkew” 输出: 3 解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
</blockquote>
<p>分析:<br>1.用滑动窗口对任何一个子串进行无重复判断, 维护窗口内我们搜的是最长的不重复子串<br>2.为了判断窗口内是无重复的, 我们引入一个 hash表 去记录窗口内每个字符出现的次数<br>3.如果当前右边指针指向字符发生了重复, 那么就移动左边的窗口  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 记录无重复窗口里面的字符出现次数</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; noRepeatWindowCharCnt;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">      <span class="type">char</span> rc = s[r];</span><br><span class="line">      ++r;</span><br><span class="line">      noRepeatWindowCharCnt[rc] += <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 如果右边指针出现了重复元素, 窗口左侧持续收缩, 直到窗口里面完全无重复 (noRepeatWindowCharCnt[rc] == 1)</span></span><br><span class="line">      <span class="keyword">while</span> (noRepeatWindowCharCnt[rc] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> lc = s[l];</span><br><span class="line">        ++l;</span><br><span class="line">        --noRepeatWindowCharCnt[lc];</span><br><span class="line">      &#125;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, r - l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438.找到字符串中所有字母异位词"></a>438.找到字符串中所有字母异位词</h2><blockquote>
<p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p>示例 1:输入: s = “cbaebabacd”, p = “abc” 输出: [0,6]<br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</p>
<p>示例 2: 输入: s = “abab”, p = “ab” 输出: [0,1,2]<br>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的异位词。</p>
</blockquote>
<p>分析:<br>1.先采用模板的方法: 用滑动窗口搜索每个窗口内是否每个字母出现的次数和需要的次数是一致的; 首先构建一个 hash table 将需要的次数统计一下<br>2.开始滑动, 每次滑动的时候记录一下当前窗口内每个字符出现的次数, 如何判定所有的次数和整体的次数相等? 一种简单的方法是再引入一个窗口内满足条件的总次数, 每次判定当前右边指针指向的那个字符和我们想要的这个字符出现次数是匹配的情况下, ++valid, 如果 validCnt = p.size(); 那么就推出去结果  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: p)</span><br><span class="line">      ++need[c];</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="type">char</span> r = s[right];</span><br><span class="line">      ++right;</span><br><span class="line">      <span class="keyword">if</span> (need.<span class="built_in">count</span>(r)) &#123;</span><br><span class="line">        ++window[r];</span><br><span class="line">        <span class="keyword">if</span> (need[r] == window[r])</span><br><span class="line">          ++valid;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (right - left &gt;= p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (valid == need.<span class="built_in">size</span>()) &#123;</span><br><span class="line">          ans.<span class="built_in">push_back</span>(left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> l = s[left];</span><br><span class="line">        ++left;</span><br><span class="line">        <span class="keyword">if</span> (need.<span class="built_in">count</span>(l)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (need[l] == window[l]) &#123;</span><br><span class="line">            --valid;</span><br><span class="line">          &#125;</span><br><span class="line">          --window[l];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>滑动窗口的方法可以采用更简单的方式, 用 vector<int>pCnt(26, 0) 保存 p 中各个字符出现的次数, 用 vector<int>sCnt(26,0) 保存当前遍历的 s 子串中各个字符出现的次数, 并且用一个长度为 pLen 的滑动窗口来维护 sCnt 的变化, 然后 push 进去判断相等情况下的 index, 代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sLen = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> pLen = p.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (pLen &gt; sLen) &#123;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sCnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pCnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pLen; ++i) &#123;</span><br><span class="line">      ++pCnt[p[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">      ++sCnt[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sCnt == pCnt) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; sLen - pLen + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">      sCnt[s[i<span class="number">-1</span>] - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">      sCnt[s[i + pLen - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (sCnt == pCnt) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h2><h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560.和为 K 的子数组"></a>560.和为 K 的子数组</h2><blockquote>
<p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。子数组是数组中元素的连续非空序列。</p>
<p>示例 1：输入：nums = [1,1,1], k = 2 输出：2</p>
<p>示例 2：输入：nums = [1,2,3], k = 3 输出：2</p>
</blockquote>
<p>分析:<br>1.题目中要求的是计算数组中连续子数组的求和 == k的情况, 我们看到连续子数组求和马上联想到前缀和数组看看能不能加快计算, 因为要求的是连续子数组和 == k, 那么其实转化到前缀和数组上就是问两个前缀和的差 == k的情况<br>2.我们用带包含的定义 preSum[i] 是包含第 i 个元素的前缀和, 也就是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preSum[i] = preSum[i - <span class="number">1</span>] + num[i]</span><br></pre></td></tr></table></figure>
<p>3.对于任意的两个下标 i 和 j（i &lt; j），如果 prefixSum[j] - prefixSum[i] = k，即从第 i 个位置到第 j 个位置的元素之和等于 k, 那么说明从第 i+1 个位置到第 j 个位置的连续子数组的和为 k<br>先遍历 1 次数组, 得到前缀和数组, 开一个哈希表来存储每种前缀和出现的次数. 在遍历的过程中, 我们检查是否存在 prefixSum[j] - k的前缀和, 如果存在，说明从某个位置到当前位置的连续子数组的和为 k, 我们将对应的次数累加到结果中<br>再遍历一次数组，累加出和为 k 的连续子数组的个数，最终时间复杂度为 O(n)  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 构建包含i的前缀数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span>&gt; <span class="title">preSum</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    preSum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      preSum[i] = preSum[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// preSum2Cnt 记录每一种前缀和出现的次数</span></span><br><span class="line">    unordered_map&lt;<span class="type">long</span>, <span class="type">int</span>&gt; preSum2Cnt;</span><br><span class="line">    preSum2Cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="comment">// 如果 preSum[i] - k 这种前缀和是存在的, 那么答案累加这种前缀和的次数, 同时累加这种前缀和出现的次数</span></span><br><span class="line">      <span class="keyword">if</span> (preSum2Cnt.<span class="built_in">find</span>(preSum[i] - k) != preSum2Cnt.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        ans += preSum2Cnt[preSum[i] - k];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 累加前缀和出现的次数</span></span><br><span class="line">      preSum2Cnt[preSum[i]] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对每个位置 i, 计算前缀和只需用 1 次, 因此前缀和计算和累加前缀和是可以同时进行, 不需要开数组, 只维护当前那个前缀和出现的次数  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> preSum = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">long</span>, <span class="type">int</span>&gt; preSum2Cnt;</span><br><span class="line">    preSum2Cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      preSum += nums[i];</span><br><span class="line">      <span class="keyword">if</span> (preSum2Cnt.<span class="built_in">find</span>(preSum - k) != preSum2Cnt.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        ans += preSum2Cnt[preSum - k];</span><br><span class="line">      &#125;</span><br><span class="line">      preSum2Cnt[preSum] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h2><blockquote>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值 。</p>
<p>示例 1：输入：nums = [1,3,-1,-3,5,3,6,7], k = 3 输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
<p>示例 2：输入：nums = [1], k = 1 输出：[1]</p>
</blockquote>
<p>分析:<br>1.核心思路是如果有一个数据结构能模拟窗口滑动的移动, 那么问题就解决了, 有没有这样的一个数据结构呢? 既要随时取出来最大的元素, 同时满足一个窗口大小是固定的; 为了满足取出来最大的元素, 想到可以持续用大顶堆取顶部元素 pq.top(), 依次取出来最大的那个元素<br>2.但是怎么模拟窗口大小固定的呢? 可以持续往大顶堆加入元素, 但是保存我们要的结果的时候需要判断一下是否在固定长度的窗口内; 也就是说, 在移动过程中, 队列持续加入元素, 但是最大元素可能不在窗口里面, 需要移除出去最大的元素, 需要注意是要持续移动直到不在窗口内的所有最大元素都移除出去<br>3.判断不在窗口内方法是队列元素增加一个维度是 index , 如果判断当前窗口添加元素后最大元素应该排除出去, 这时候有 窗口的维护是 [i-k+1, i] 这么 k 个元素, 也就是说窗口元素包含的下界是 [i-k+1], 所以 q.top().second &lt; i - k + 1 都要移除出去<br>4.举个例子 [9,10,9,-7,-4,-8,2,-6] 窗口大小是 5  </p>
<p>移动方法是:<br>[9,10,9,-7,-4,-8,2,-6]  [9,10,9,-7,-4] max = 10<br>[9,10,9,-7,-4,-8,2,-6]  i = 5 队列放入-8 [9,10,9,-7,-4,-8] max=10<br>[9,10,9,-7,-4,-8,2,-6]  i = 6 队列放入2 [9,10,9,-7,-4,-8,2] 最大元素 10 不应该在窗口里面, 删掉10, 变成 [9,9,-7,-4,-8,2], 最大元素9从队列删除, 变成 [9,-7,-4,-8,2] max = 9<br>[9,10,9,-7,-4,-8,2,-6]  i = 7 放入-6 [9,-7,-4,-8,2,-6], 删除最左边的9, max=2<br>所以最后是 [10,10,9,2]  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">auto</span> cmp = [] (<span class="type">const</span> pii&amp; a, <span class="type">const</span> pii&amp; b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 建一个 pii 类型大顶堆, 维护 &lt;元素值, index&gt; pair</span></span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, <span class="keyword">decltype</span>(cmp)&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">      pq.<span class="built_in">push</span>(&#123;nums[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans&#123;pq.<span class="built_in">top</span>().first&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; len; ++i) &#123;</span><br><span class="line">      <span class="comment">// 开始滑动窗口, 放入元素</span></span><br><span class="line">      pq.<span class="built_in">push</span>(&#123;nums[i], i&#125;);</span><br><span class="line">      <span class="comment">// 当最大元素已经不在窗口内, 持续将最大元素赶出队列</span></span><br><span class="line">      <span class="comment">// [i-k+1, i] 是当前的窗口 索引搜索的边界是 idx &lt; i - k + 1</span></span><br><span class="line">      <span class="keyword">while</span> (pq.<span class="built_in">top</span>().second &lt; i - k + <span class="number">1</span>) &#123;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a>76.最小覆盖子串</h2><blockquote>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。<br>注意：对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>
<p>示例 1：输入：s = “ADOBECODEBANC”, t = “ABC” 输出：”BANC” 解释：最小覆盖子串 “BANC” 包含来自字符串 t 的 ‘A’、’B’ 和 ‘C’。</p>
<p>示例 2：输入：s = “a”, t = “a” 输出：”a” 解释：整个字符串 s 是最小覆盖子串。</p>
<p>示例 3: 输入: s = “a”, t = “aa” 输出: “” 解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。</p>
</blockquote>
<p>分析:<br>1.我们用滑动窗口处理这个最小覆盖子串的搜索问题, 初始化左右指针 left/right 都是起始位置, 对于判定子串是否覆盖, 我们先建立一个 unordered_map<char, int> need, 用于记录我们 t 字符串的计数统计, 然后维护另一个 unordered_map<char, int> window 记录我们当前的窗口内字符的出现个数情况; 这里 window 窗口内包含了其他字符出现次数统计, 所以我们还需要另一个字段 valid 区标记已经有多少个字符是满足 need 的情况, 当 valid == need.size() 我们判定能完全满足<br>2.因为我们需要记录下来最小的覆盖子串的字符串, 最简单的方法是记录下来满足条件的时候的位置, 以及是当前覆盖子串长度; 然后不断更新这个长度;<br>3.我们再理一下思路: 先对 t 字符扫描进 need 统计需要的情况; 左右指针从 0 处初始化, 右边指针持续向右扫, 如果存在在当前的字符里面, 满足在 need 中需要, 那么就对 window[rc] += 1, 然后再判断是否满足覆盖的条件, valid == need.size(), 如果满足那么就尝试更新长度, 并且判断左边界缩减, 左边界缩减的条件是什么? 左指针所在的字符是需要的字符中的, —valid, 且窗口中 —window[lc]  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c: t) &#123;</span><br><span class="line">      ++need[c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> valid = <span class="number">0</span>;              <span class="comment">// valid 记录有多少个独立的字符是满足计数条件的</span></span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ansStart = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ansLen = s.<span class="built_in">size</span>() + <span class="number">1</span>;  <span class="comment">// 初始化默认按照最长长度 + 1来</span></span><br><span class="line">    <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">      <span class="type">char</span> rc = s[r];</span><br><span class="line">      ++r;</span><br><span class="line">      <span class="keyword">if</span> (need.<span class="built_in">count</span>(rc)) &#123;</span><br><span class="line">        ++window[rc];</span><br><span class="line">        <span class="keyword">if</span> (window[rc] == need[rc]) &#123;</span><br><span class="line">          ++valid;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (valid == need.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l &lt; ansLen) &#123;</span><br><span class="line">          ansStart = l;</span><br><span class="line">          ansLen = r - l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> lc = s[l];</span><br><span class="line">        ++l;</span><br><span class="line">        <span class="keyword">if</span> (need.<span class="built_in">count</span>(lc)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (window[lc] == need[lc]) &#123;</span><br><span class="line">            --valid;</span><br><span class="line">          &#125;</span><br><span class="line">          --window[lc];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansLen == s.<span class="built_in">size</span>() + <span class="number">1</span> ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(ansStart, ansLen);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h2><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53.最大子数组和"></a>53.最大子数组和</h2><blockquote>
<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组 是数组中的一个连续部分。</p>
<p>示例 1：输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p>
<p>示例 2：输入：nums = [1] 输出：1  </p>
<p>示例 3：输入：nums = [5,4,-1,7,8] 输出：23</p>
</blockquote>
<p>分析:<br>因为数组是有正有负的, 这里定义的状态是, 以 nums[i] 为结尾的最大子数组和为dp[i], 那么dp [i] 怎么做选择<br>1.nums[i] 自成一派 dp[i] = nums[i]<br>2.nums[i] 和之前的数组 dp[i-1] 合并起来, 即 dp[i] = dp[i-1] + nums[i]<br>状态转移汇总: dp[i] = max(nums[i], dp[i-1] + nums[i])  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(len, INT_MIN)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> ans = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      <span class="comment">// dp[i], 表示以 i 为结尾的最大连续子数组和</span></span><br><span class="line">      <span class="comment">// 状态转移: 要么是和前面的加起来最大, 要么自成一派最大</span></span><br><span class="line">      dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">      ans = <span class="built_in">max</span>(dp[i], ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a>56.合并区间</h2><blockquote>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<p>示例 1：输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>
<p>示例 2：输入：intervals = [[1,4],[4,5]] 输出：[[1,5]] 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p>
</blockquote>
<p>分析:<br>1.对所有的区间的左端点先排序<br>2.新增一个 merged 空数组, 然后遍历排序后的数组, 逐个加入到数组里面, 怎么依次往里面 merge 呢?<br>(i). 如果当前区间 cur 的左边的端点比 merged 数组中最后一个区间的右端点还大, 那么我们直接放入到 merged 末尾<br>(ii). 如果当前区间 cur 的左边端点比 merged 数组最后一个 区间 的右端点小, 那么更新最后一个数组的右端点更新成 max(cur<em>右端点, last</em>右端点)  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">    <span class="type">int</span> len = intervals.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; merged;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [] (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    merged.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> l = intervals[i][<span class="number">0</span>];</span><br><span class="line">      <span class="type">int</span> r = intervals[i][<span class="number">1</span>];</span><br><span class="line">      <span class="type">int</span> lastR = merged.<span class="built_in">back</span>()[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 如果当前区间的左端点 比 最后一个区间的右端点还大, 直接放到最后一个, 没有重合无需合并</span></span><br><span class="line">      <span class="keyword">if</span> (l &gt; lastR) &#123;</span><br><span class="line">        merged.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">      <span class="comment">// 否则将 cur区间 和最后一个区间合并</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        merged.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(merged.<span class="built_in">back</span>()[<span class="number">1</span>], r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merged;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189.轮转数组"></a>189.轮转数组</h2><blockquote>
<p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>
<p>示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4]<br>解释:<br>向右轮转 1 步: [7,1,2,3,4,5,6]<br>向右轮转 2 步: [6,7,1,2,3,4,5]<br>向右轮转 3 步: [5,6,7,1,2,3,4]</p>
<p>示例 2: 输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100]<br>解释:<br>向右轮转 1 步: [99,-1,-100,3]<br>向右轮转 2 步: [3,99,-1,-100]</p>
</blockquote>
<p>分析:<br>1.向右旋转有个 k 个位置的效果有个先分步反转然后整体反转的等效作用方式, 把反转过程分解成分开2个部分反转结果的反转<br>2.理解过程如下:<br>数组是           ——-&gt;—&gt;  k = 3 (1)<br>翻转完成的效果是   —&gt;——-&gt;        (2)<br>这个可以怎么从效果 (1) 到效果 (2) 呢? 我们可以分别将整个数组分成两个部分分别反转j<br>——-&gt;  反转后得到  &lt;——-<br>—&gt; 反转后得到 &lt;—<br>然后我们现在得到的是 &lt;——-&lt;—      (3)<br>我们发现我们要的 (2) 和 现在得到的(3) 是个对称图形, 如果对 (3) 整体翻转一下, 就得到了我们要的 (2) 的效果</p>
<p>3.一开始额外判断一下 k 是否是 nums.size() 的倍数, 可以直接取模, 化简运算  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k %= len;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>() - k);  <span class="comment">// 反转 k 之前的</span></span><br><span class="line">    <span class="built_in">reverse</span>(nums.<span class="built_in">end</span>() - k, nums.<span class="built_in">end</span>());    <span class="comment">// 反转 k 之后的</span></span><br><span class="line">    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238.除自身以外数组的乘积"></a>238.除自身以外数组的乘积</h2><blockquote>
<p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<p>示例 1: 输入: nums = [1,2,3,4] 输出: [24,12,8,6]</p>
<p>示例 2: 输入: nums = [-1,1,0,-3,3] 输出: [0,0,9,0,0]</p>
</blockquote>
<p>分析:<br>1.我们不妨想一下出题人想考我们什么, 想要 [除自身以外数组的乘积] 可以直接全部乘起来然后除以 [自身], 但是这种直觉的想法有个问题是无法处理自身为 0 的问题, 所以提示了不要使用除法<br>2.思路上很类似于接雨水的思路, 我们首先构造一个左侧乘积数组, 对于某个元素 i 来说, lProduct[i] 是它严格左侧所有的乘积; 同理右侧侧乘积数组 rProduct[i] 是它严格右侧所有的乘积, 然后遍历取 lProduct[i] * rProduct[i]; 对于边界条件设定 lProduct[0] = 1 = rProduct[len - 1]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lProduct</span><span class="params">(len, <span class="number">1</span>)</span></span>; <span class="comment">// 存储左侧所有元素乘积</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rProduct</span><span class="params">(len, <span class="number">1</span>)</span></span>; <span class="comment">// 存储右侧所有元素乘积</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      lProduct[i] = lProduct[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">      rProduct[i] = rProduct[i<span class="number">+1</span>] * nums[i<span class="number">+1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      ans[i] = lProduct[i] * rProduct[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41.缺失的第一个正数"></a>41.缺失的第一个正数</h2><blockquote>
<p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p>
<p>示例 1：输入：nums = [1,2,0] 输出：3</p>
<p>示例 2：输入：nums = [3,4,-1,1] 输出：2</p>
<p>示例 3：输入：nums = [7,8,9,11,12] 输出：1</p>
</blockquote>
<p>分析:<br>1.题目要求 O(n) 时间 和 O(1) 空间; 如果没有限制这个我们估计怎么做, 遍历放哈希表, 然后从1开始枚举看哪个不存在在哈希表, 但是会引入到 O(n) 空间<br>2.这个题目需要引入一种原地哈希的思路, 在原始的数组中修改, 这样才能不引入额外的空间<br>3.对于一个长度为 N 的数组, 未出现的最小正数的范围在 [1, N+1], 如果 [1,N] 都出现了, 那么第一个没出现的正数就是 N+1; 否则就是在 [1, N] 中没有出现的最小正整数; 所以我们想对 [1, N] 范围的数放入哈希表<br>4.怎么把 [1, N] 范围的数放入哈希表, 但是有不建立新的哈希表呢? 放在原始的数组里面: 我们对数组进行遍历, 对于遍历到的数字 x, 如果它在 [1, N] 范围内, 那么就将 x - 1 这个[位置] 打上 [某种标记], 因此遍历结束之后, 如果所有 [位置] 都有标记, 那么缺失的就是 N+1 这个数字; 否则就是没有打上标记的的位置 + 1 这个数字就是第一个缺失的正数<br>5.举个例子, 数组长度是 5, 我们对于数字 1, 我们对 0 位置上打标记, 全打完所有标记之后, 没打上标记的位置就是 + 1, 就是缺失的数字: 比如我们发现, 我们在 2 位置没有标记, 那么就说明 3 这个数字缺失了<br>6.到此为止, 我们只需要设计某种标记的规则, 就能完成上面的操作; 对于负数, 这种不在我们考虑的范围内, 只需要排除它对我们后续的干扰就行, 这里一种设计方法是打一个较大的正数 N + 2, 这样数组里面的数字就都是正数了, 遍历数字的时候, 如果绝对值 超出 N 的一律不考虑<br>7.我们可以将 [标记] 的产生, 设置成 打了[负号] 的 [负数], 也称为 [负数标记]; 比如一个数字 3, 我们让它在 nums[2] 位置上的负数 -nums[2]<br>8.举个完整的例子:<br> 3,4,-1, 1, 9,-5    第一步, n = 6 将负数替换成 n + 2 = 8<br> 3,4, 8, 1, 9, 8    第二步, 做完上一步所有数字都是正数了, 对所有不大于 6 的数字, 标记为负数, 标记的方法是 nums[num - 1] = - 原始数字的绝对值<br>-3,4,-8,-1, 9, 8    第三步, 做完上一步已经标记好正数了, 如果现在还有正数就是缺失的那个数字, 缺失数字对应的是 i + 1  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 把负数都标记成 len + 2, 至少是标记为 len + 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; x: nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        x = len + <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> num = <span class="built_in">abs</span>(nums[i]);   <span class="comment">// 先取出来绝对值, 用于下面判断这个数之前不是负数</span></span><br><span class="line">      <span class="comment">// 对剩下的真正的正数 (之前的负数不需要再考虑), 也就是 num &lt;= len 的数, 搞上 [负数标记]</span></span><br><span class="line">      <span class="keyword">if</span> (num &lt;= len) &#123;</span><br><span class="line">        nums[num - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[num - <span class="number">1</span>]); <span class="comment">// 打上负数标记, 直接对这个数字取一个负数;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历已经打好标记的结果, 找第1个剩下的正数, 找到了, 那么就返回 i + 1</span></span><br><span class="line">    <span class="comment">// 第一个大于 0 的数 index + 1 就是缺失正数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果遍历完找不到, 那么第 1 个缺失的正数就是 len + 1</span></span><br><span class="line">    <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h2 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73.矩阵置零"></a>73.矩阵置零</h2><blockquote>
<p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。</p>
<p>示例 1：输入：matrix = [<br>[1,1,1],<br>[1,0,1],<br>[1,1,1]<br>]<br>输出：[<br>[1,0,1],<br>[0,0,0],<br>[1,0,1]<br>]</p>
<p>示例 2：输入：matrix = [<br>[0,1,2,0],<br>[3,4,5,2],<br>[1,3,1,5]<br>]<br>输出：[<br>[0,0,0,0],<br>[0,4,5,0],<br>[0,3,1,0]<br>]</p>
</blockquote>
<p>分析:<br>1.如果扫描每个位置, 扫到 0 之后再去动所在的行和列, 每个位置和其他位置置为零的过程有较多重复操作<br>2.采用空间换时间的思想, 开一个数组标记哪一行哪一列是有 0 的, 全标记完再开始根据标记结果去设置 0<br>(i). 我们先扫描一遍矩阵, 并用引入两个额外的数组去标记, 这行和这列是否存在过 0<br>(ii). 然后再扫描一遍矩阵, 如果存在这行或者这列为 0 的情况, 那么全部标记为 0  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">rowHasZeroFlag</span><span class="params">(m, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">colHasZeroFlag</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span> ; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">          rowHasZeroFlag[i] = <span class="literal">true</span>;</span><br><span class="line">          colHasZeroFlag[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span> ; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rowHasZeroFlag[i] || colHasZeroFlag[j]) &#123;</span><br><span class="line">          matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54.螺旋矩阵"></a>54.螺旋矩阵</h2><blockquote>
<p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p>
<p>示例 1：输入：<br>matrix = [<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>] 输出：[1,2,3,6,9,8,7,4,5]</p>
<p>示例 2：输入：<br>matrix = [<br>  [1,2,3,4],<br>  [5,6,7,8],<br>  [9,10,11,12]<br>] 输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
</blockquote>
<p>分析:<br>1.模拟旋转的过程, 维护上下左右四个终极边界, left, right, top, bottom, 然后在旋转过程中缩小边界, 直到边界发生某种重合; 向右和向下是必有的, 但是有时候向左和向上不是必须的, 因此需要一个判断; 判断可以回转的情况是两个边界不重合, 也就是 left &lt; right &amp;&amp; top &lt; bottom<br>2.每次单项移动的时候, 都是卡着一个边界去移动  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> rowNum = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> colNum = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// left/right/top/bottom 模拟当前可执行螺旋的四个方向的边界</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = colNum - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bottom = rowNum - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> c = left; c &lt;= right; ++c) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(matrix[top][c]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> r = top + <span class="number">1</span>; r &lt;= bottom; ++r) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(matrix[r][right]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在需要缩小的情况下</span></span><br><span class="line">      <span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">        <span class="comment">// 先往左缩小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = right - <span class="number">1</span>; c &gt; left; --c) &#123;</span><br><span class="line">          ans.<span class="built_in">push_back</span>(matrix[bottom][c]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再向上缩小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = bottom; r &gt; top; --r) &#123;</span><br><span class="line">          ans.<span class="built_in">push_back</span>(matrix[r][left]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 缩小一圈边界</span></span><br><span class="line">      ++left;</span><br><span class="line">      --right;</span><br><span class="line">      ++top;</span><br><span class="line">      --bottom;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.旋转图像</h2><blockquote>
<p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。<br>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<p>示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[[7,4,1],[8,5,2],[9,6,3]]</p>
<p>示例 2： 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p>
</blockquote>
<p>分析:<br>1.图像是顺时针旋转了90度, 不太好直接看出来旋转后的对应关系, 可以尝试水平翻转, 垂直翻转，或者转置等操作的组合; 看一下翻转一步之后，距离目标状态还能怎么操作一下就能达到同样的效果<br>2.<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>]<br>先以中间一行为轴, 上下对称做个翻转<br>[<br>  [7,8,9],<br>  [4,5,6]<br>  [1,2,3],<br>]<br>然后做一个转置<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]<br>3.总结翻转的公式<br>水平线上下翻转: matrix[row][col] =&gt; matrix[n-row-1][col]<br>转置操作: matrix[row][col] =&gt; matrix[col][row]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 沿着水平线上下翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(matrix[i][j], matrix[n - i - <span class="number">1</span>][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 矩阵转置操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240.搜索二维矩阵 II"></a>240.搜索二维矩阵 II</h2><blockquote>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。每列的元素从上到下升序排列</p>
<p>示例 1：输入：matrix = [<br>  [1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]<br>  ], target = 5 输出：true  </p>
<p>示例 2：输入：matrix = [<br>  [1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]<br>  ], target = 20 输出：false  </p>
</blockquote>
<p>分析:<br>1.二维矩阵搜索, 其实这个搜索也是有序的, 从上到下, 从左往右有序, 最小的永远在左上角, 最大的永远在右下角, 但是右上角和左下角哪个更大我们不知道<br>2.最基础的方法可以对逐行进行二分搜索, 每一行是 logn复杂度, 总时间复杂度 nlogn<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rowNum = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; rowNum; ++row) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">binary_search</span>(matrix[row].<span class="built_in">begin</span>(), matrix[row].<span class="built_in">end</span>(), target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>3.这个矩阵的特点我们得充分利用下, 因为右边总比左边大, 下边总比上边大, 我们可以先卡一个最大的子坐标, 另一个从 0 开始搜索, 比如从右上角 (0, n - 1) 元素开始搜索, 如果当前搜索元素比目标元素小, 那么就往下搜索, 纵坐标不动; 如果当前搜索元素比目标元素大, 那么就缩小右边界  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rowNum = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> colNum = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> y = colNum - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (x &lt; rowNum &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix[x][y] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[x][y] &lt; target) &#123;</span><br><span class="line">        ++x;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[x][y] &gt; target) &#123;</span><br><span class="line">        --y;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h2><blockquote>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。<br>图示两个链表在节点 c1 开始相交：<br>题目数据 保证 整个链式结构中不存在环。<br>注意，函数返回结果后，链表必须 保持其原始结构 。<br>自定义评测：<br>评测系统 的输入如下（你设计的程序 不适用 此输入）：<br>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0<br>listA - 第一个链表<br>listB - 第二个链表<br>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数<br>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数<br>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p>
<p>示例 1：<br>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。<br>— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</p>
<p>示例 2：<br>输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Intersected at ‘2’<br>解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。<br>在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p>
<p>示例 3：<br>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。<br>由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 null 。</p>
</blockquote>
<p>分析:<br>1.这个题如果看了答案只能感觉很巧妙, 但是不看答案又想不出来这个巧妙的答案, 先用比较基础的方法: 用一个 hashset 保存 headA 下的所有节点, 然后和另一个链表逐个对比就能找到公共节点, 但是需要额外的空间<br>2.需要充分利用”相交”这个信息, 一种解决的方式是, 将两条链表按照前后两种不同的顺序拼接在一起, 例如如下的两条链表公共节点是c1<br>a1-&gt;a2-&gt;c1-&gt;c2<br>b1-&gt;b2-&gt;b3-&gt;c1-&gt;c2<br>拼接之后得到两条长度相同的链表<br>a1-&gt;a2-&gt;c1-&gt;c2-&gt;b1-&gt;b2-&gt;b3-&gt;c1-&gt;c2<br>b1-&gt;b2-&gt;b3-&gt;c1-&gt;c2-&gt;a1-&gt;a2-&gt;c1-&gt;c2<br>这样我们同时遍历这两个链表, 找到的第一个相同的节点就是 c1 就是链表交点<br>3.在实际遍历的时候, 可以想象这两个链表已经被拼接起来, 但不实际地去开辟额外空间, 只在原来的两条链表上面走  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    ListNode* pa = headA;</span><br><span class="line">    ListNode* pb = headB;</span><br><span class="line">    <span class="keyword">while</span> (pa != pb) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pa) &#123;</span><br><span class="line">        pa = pa -&gt; next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将pa链接在b的开头</span></span><br><span class="line">        pa = headB;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (pb) &#123;</span><br><span class="line">        pb = pb -&gt; next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将pb链接在b的开头</span></span><br><span class="line">        pb = headA;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pa;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><blockquote>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p>示例 1：输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1]</p>
<p>示例 2：输入：head = [1,2] 输出：[2,1]</p>
<p>示例 3：输入：head = [] 输出：[]</p>
</blockquote>
<p>分析:<br>1.迭代:<br>反转的核心操作, 是要把当前的节点指向它前一个节点, 但是我们得迭代, 所以需要先记下来它前一个是谁和后一个是谁, 然后执行迭代操作更新, 因此就是用三个指针 pre, cur, next 这3个就能完成<br>原始状态 1 -&gt; 2 -&gt; 3 -&gt; nullptr<br>目标状态 nullptr &lt;- 1 &lt;- 2 &lt;- 3, 假设我们要操作 2 这个节点的反转 1 -&gt; 2 -&gt; 3 得到 1 &lt;- 2 -&gt; 3, 关键操作是将当前的节点反向指向它的前一个节点, 也就是cur -&gt; next = pre, 同时为了能迭代我们首先要记下来下一个节点, 然后再实施关键翻转操作  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    ListNode* next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      next = cur-&gt;next;   <span class="comment">// 先记下来它下一个是谁, 不然反转完当前之后, 没法走到下一个反转流程</span></span><br><span class="line">      cur-&gt;next = pre;    <span class="comment">// 执行核心的反转操作</span></span><br><span class="line">      pre = cur;          <span class="comment">// 执行迭代</span></span><br><span class="line">      cur = next;         <span class="comment">// 执行迭代</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.递归操作<br>想一下假设只有一个节点需要反转, 后面的都已经反转好了, 就差一步大功告成, 应该怎么反转?  </p>
<p>1 -&gt; [2 -&gt; 3 -&gt; 4 -&gt; nullptr]<br>1 -&gt; [nullptr &lt;- 2 &lt;- 3 &lt;- 4] 此时 newHead 指向4  让 1-&gt;next-&gt;next 指向1<br>1 &lt;- [2 &lt;- 3 &lt;- 4] 得到左边的结果, 但还差一步 1-&gt;next = nullptr<br>nullptr &lt;- 1 &lt;- [2 &lt;- 3 &lt;- 4]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h2><blockquote>
<p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
<p>示例 1：输入：head = [1,2,2,1] 输出：true</p>
<p>示例 2：输入：head = [1,2] 输出：false</p>
</blockquote>
<p>分析:<br>1.找到链表的中点, 然后反转后半部分, 用半部分和后半部分遍历, 先准备个反转链表和找到中点的操作, 反转链表写递归的更快, 找到中点用快慢指针一次遍历  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* newHead = <span class="built_in">reverse</span>(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ListNode* <span class="title">findMidNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head; </span><br><span class="line">    ListNode* fast = head; </span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      slow = slow-&gt;next;</span><br><span class="line">      fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* mid = <span class="built_in">findMidNode</span>(head);</span><br><span class="line">    ListNode* p1 = head;</span><br><span class="line">    ListNode* p2 = <span class="built_in">reverse</span>(mid);</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p1-&gt;val != p2-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p1 = p1-&gt;next;</span><br><span class="line">      p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h2><blockquote>
<p>给你一个链表的头节点 head ，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<p>示例 1：输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>示例 2：输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。</p>
</blockquote>
<p>分析:<br>1.快慢指针, 相遇就有环, 否则没环<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">      slow = slow-&gt;next;</span><br><span class="line">      fast = fast-&gt;next-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142.环形链表 II"></a>142.环形链表 II</h2><blockquote>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。不允许修改 链表。</p>
<p>示例 1：输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>示例 2：输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。</p>
<p>示例 3：输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。</p>
</blockquote>
<p>分析:<br>1.需要分析下相遇点有什么特点, 我们仍然采用快慢指针的方式来看, 起点快慢指针都指向非空的 head, 假设 slow 走了 k 步之后, fast 和 slow 相遇了, slow 走 k 步, 那么 fast 走 2k 步; fast 比 slow 多走出的 k 步是在环里面转圈, 所以这个相遇时候慢指针走过的 k 步的 k 的值正好就是环长度的 [整数倍]<br>2.假设 [相遇点] 距离 [环起点] 为 m , 原始头节点距离 [环起点] 为 k - m , fast 如果继续往前走 k - m 步到达环的起点, 但是我们不知道这个 m 是多少; 这里我们知道, 相遇之后原始头结点距离 [环起点] 距离 == [相遇点] 距离 [环起点] 继续走距离都是 k - m; 所以我们让快慢指针第一次相遇的时候, 让快慢指针的任意一个重新指向 head, 比如 slow 重新指向 head, 然后 slow 和 fast 指针同速前进 (每次走1步), (经过 k - m 步) 然后它俩一定相遇, 相遇的地方就是环的起点  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="comment">// 假设 [相遇点] 距离 [环起点] 为 m , 原始头节点距离 [环起点] 为 k - m , fast 如果继续往前走 k - m 步到达环的起点, 我们不知道这个 m 是多少; </span></span><br><span class="line">    <span class="comment">// 相遇之后原始头结点距离 [环起点] 距离 == [相遇点] 距离 [环起点] 继续走距离都是 k - m; </span></span><br><span class="line">    <span class="comment">// 我们让快慢指针第一次相遇的时候, 让快慢指针的任意一个重新指向 head, 比如 slow 重新指向 head, 然后 slow 和 fast 指针同速前进 (每次走1步), (经过 k - m 步) 然后他俩一定相遇, 相遇的地方就是环的起点;</span></span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">      slow = slow-&gt;next;</span><br><span class="line">      fast = fast-&gt;next-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">          slow = slow-&gt;next;</span><br><span class="line">          fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h2><blockquote>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例 1：输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4]</p>
<p>示例 2：输入：l1 = [], l2 = [] 输出：[]</p>
<p>示例 3：输入：l1 = [], l2 = [0] 输出：[0]</p>
</blockquote>
<p>分析:<br>1.合并有序链表的操作关键操作是分别用两个指针维护当前列表 list1/list2 的指针 p1 和 p2, 然后再用一个指针维护合并的指针, 这个合并指针好像一个针线头一样, 把两条线穿起来<br>2.先处理 p1 和 p2 同时非空的场景, 然后再处理剩下的唯一的链表有剩余的场景<br>3.为了方便处理有链表为空的情况, 额外设置一个 dummy 节点, 返回 dummy-&gt;next  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode* cur = dummy;</span><br><span class="line">    ListNode* p1 = list1;</span><br><span class="line">    ListNode* p2 = list2;</span><br><span class="line">    <span class="keyword">while</span> (p1 &amp;&amp; p2) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val) &#123;</span><br><span class="line">        cur-&gt;next = p1;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur-&gt;next = p2;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">      cur-&gt;next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2) &#123;</span><br><span class="line">      cur-&gt;next = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h2><blockquote>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例 1：输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807.</p>
<p>示例 2：输入：l1 = [0], l2 = [0] 输出：[0]</p>
<p>示例 3：输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1]</p>
</blockquote>
<p>分析:<br>1.纯模拟实现, 注意各种进位的判断, 可以先处理两个链表同时有节点的情况, 再单独处理一个链表有节点的情况, 然后再处理最后的一个进位的情况  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode* cur = dummy;</span><br><span class="line">    ListNode* p1 = l1;</span><br><span class="line">    ListNode* p2 = l2;</span><br><span class="line">    <span class="type">int</span> sum   = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> data  = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &amp;&amp; p2) &#123;</span><br><span class="line">      sum = p1-&gt;val + p2-&gt;val + carry;</span><br><span class="line">      data = sum % <span class="number">10</span>;</span><br><span class="line">      carry = sum / <span class="number">10</span>;</span><br><span class="line">      ListNode* tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(data);</span><br><span class="line">      cur-&gt;next = tmp;</span><br><span class="line">      p1 = p1-&gt;next;</span><br><span class="line">      p2 = p2-&gt;next;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* p = (p1) ? p1 : p2;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">      sum = p-&gt;val + carry;</span><br><span class="line">      data = sum % <span class="number">10</span>;</span><br><span class="line">      carry = sum / <span class="number">10</span>;</span><br><span class="line">      p-&gt;val = data;</span><br><span class="line">      cur-&gt;next = p;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      ListNode* finalNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">      cur-&gt;next = finalNode;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19.删除链表的倒数第 N 个结点"></a>19.删除链表的倒数第 N 个结点</h2><blockquote>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>示例 1：输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]</p>
<p>示例 2：输入：head = [1], n = 1 输出：[]</p>
<p>示例 3：输入：head = [1,2], n = 1 输出：[1]</p>
</blockquote>
<p>分析:<br>1.如果要删除倒数第 N 个节点, 也就是删除正数 nums-N+1 个节点, 为了删除 nums-N+1 的节点, 我们需要指针指向删除目标节点的前一个节点, 即正数 nums-N 个节点, 也就是倒数 N+1 个节点<br>2.一种方法是遍历一遍找到 N 等于几, 然后再遍历一遍执行删除操作<br>3.更方便的一种方式是先让 fast 先正好走到我们想要 slow 停下来的节点, 也就是待删除的节点的前一个节点, 然后再快慢同速度一起走, 直到 fast 为空, 这时候 slow 停下来的节点就是正数 nums-N 个节点; 其实我们脑洞开一点, 就好比等价于有另一个指针 (fast) 先执行倒着走一样, 它能先帮我们找到那个前一个节点<br>4.假设 [1,2,3,4,5], n=2, 为了防止空指针出现, 比如 5 个节点删除倒数第 5 个, 要用 dummy 去避免空指针; fast 指针可以从 head 开始, 然后 slow 指针多走一步从 dummy 开始, 这样就能直接达到走到待删除节点的下一个节点的效果; 增加 dummy 得到 [d,1,2,3,4,5], 所以, fast 从 1 出发走 2 步到 3, 然后走 3 步到空指针, slow 从 dummy 出发走 3 步到 3, 也就是 4 的前1个节点  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">                             <span class="comment">// 举例 [d,1,2,3,4,5], n=2, fast 停在3, slow 最终停在3</span></span><br><span class="line">    ListNode* slow = dummy;  <span class="comment">// slow 从 dummy 出发, 能够多走一步, 保证 slow 最终停在待删除节点前面</span></span><br><span class="line">    ListNode* fast = head;   <span class="comment">// fast 从 head 出发</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">      slow = slow-&gt;next;</span><br><span class="line">      fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    ListNode* ans = dummy-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> dummy;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h2><blockquote>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p>示例 1：输入：head = [1,2,3,4] 输出：[2,1,4,3]</p>
<p>示例 2：输入：head = [] 输出：[]</p>
<p>示例 3：输入：head = [1] 输出：[1]</p>
</blockquote>
<p>分析:<br>1.这个题意是想让我们按照每两个一组交换节点, 需要画图在纸上才能看清楚指针的变动顺序;<br>2.先设置一个 dummy, dummy-&gt;next = head:<br>3.我们尝试反转第一组, 因为需要一个前置节点才能开始连接, 因此声明一个 pre, 一开始pre = dummy;<br>先取出来 node1 和 node2<br>pre-&gt;next = node2;<br>node1-&gt;next = node2-&gt;next;<br>node2-&gt;next = node1;<br>pre = node1;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">    ListNode* pre = dummy;</span><br><span class="line">    <span class="keyword">while</span> (pre-&gt;next != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      ListNode* node1 = pre-&gt;next;</span><br><span class="line">      ListNode* node2 = pre-&gt;next-&gt;next;</span><br><span class="line">      pre-&gt;next = node2;</span><br><span class="line">      node1-&gt;next = node2-&gt;next;</span><br><span class="line">      node2-&gt;next = node1;</span><br><span class="line">      pre = node1;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* ans = dummy-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> dummy;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25.K 个一组翻转链表"></a>25.K 个一组翻转链表</h2><blockquote>
<p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。<br>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<p>示例 1：输入：head = [1,2,3,4,5], k = 2 输出：[2,1,4,3,5]</p>
<p>示例 2：输入：head = [1,2,3,4,5], k = 3 输出：[3,2,1,4,5]</p>
</blockquote>
<p>分析:<br>1.如果我们对链表内任意一个区间 [left, right] 可以实施反转, 我们只需要对所有的区间实施相同的反转; 如何对链表内任意一个区间实施反转 ? 采用 [区间内头插法反转]  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动 pre 到指向区间前一个节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">  pre = pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* cur = pre-&gt;next;   <span class="comment">// cur 节点是反转区域第1个节点, 也是反转区域最后一个节点, 始终不动</span></span><br><span class="line">ListNode* next;              <span class="comment">// next 是要执行头插的节点, 每次移动到反转区域的第1个元素, 并一直迭代</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left; ++i) &#123;</span><br><span class="line">  next = cur-&gt;next;         <span class="comment">// 找到头插节点</span></span><br><span class="line">  cur-&gt;next = next-&gt;next;   <span class="comment">// 隔过去待头插入的节点</span></span><br><span class="line">  next-&gt;next = pre-&gt;next;   <span class="comment">// 执行头插: 插入头节点到区间第1个节点</span></span><br><span class="line">  pre-&gt;next = next;         <span class="comment">// 链接 pre -&gt; 头插元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.应用 [区间内头插法反转] 的操作可以对任意区间进行反转, 我们只需要对多个区间采取相同的操作; 每个[区间内头插法反转] 操作完成之后, 我们将 pre 和 cur 顺序往下移动一个区间, 再下一个区间进行 [区间内头插法]<br>3.先求出来区间的总长度; 然后一个区间一个区间地做 [区间内头插法反转]  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">    ListNode* t = head;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 先求出来链表的长度</span></span><br><span class="line">    <span class="keyword">while</span> (t) &#123;</span><br><span class="line">      ++len;</span><br><span class="line">      t = t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* pre = dummy;</span><br><span class="line">    ListNode* cur = pre-&gt;next;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="keyword">while</span> (len &gt;= k) &#123;</span><br><span class="line">      <span class="comment">// 执行区间内头插法反转</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = next-&gt;next;</span><br><span class="line">        next-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = next;</span><br><span class="line">      &#125;</span><br><span class="line">      pre = cur;        <span class="comment">// 下一个 pre 指向 cur 也就是区间内的最后1个元素</span></span><br><span class="line">      cur = pre-&gt;next;  <span class="comment">// cur 进入到新区间的第1个元素</span></span><br><span class="line">      len -= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138.随机链表的复制"></a>138.随机链表的复制</h2><blockquote>
<p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。<br>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。例如，如果原链表中有 X 和 Y 两个节点，其中 X.random —&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random —&gt; y 。 返回复制链表的头节点。<br>用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：<br>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。<br>你的代码 只 接受原链表的头节点 head 作为传入参数。</p>
<p>示例 1： 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p>
<p>示例 2： 输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]]</p>
<p>示例 3： 输入：head = [[3,null],[3,0],[3,null]] 输出：[[3,null],[3,0],[3,null]]</p>
</blockquote>
<p>分析:<br>1.如果没有随机指针, 我们遍历复制就行, 因为有随机指针的存在, 当我们想复制某个节点的时候, 它的随机指针指向的那个节点可能还没创建, 因此不太好复制<br>2.这里有个非常巧妙的办法, 先复制在拆分, 对于链表 a-&gt;b-&gt;c, 我们可以在每个元素之后先建一个a-&gt;a’-&gt;b-&gt;b’-&gt;c-&gt;c’, 然后我们对所有a’和b’和c’找到随机指针指向的节点是它原来节点的随机指针指向的节点对应的后继节点, 然后重新遍历一遍, 按照 [原来节点] 和 [复制节点] 拆分出来; 因为随机指针可以指向空值, 给复制节点找随机指针指向的结点的时候, 需要判断一下能否指向一个节点  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment"> public:</span></span><br><span class="line"><span class="comment">  int val;</span></span><br><span class="line"><span class="comment">  Node* next;</span></span><br><span class="line"><span class="comment">  Node* random;</span></span><br><span class="line"><span class="comment">  Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">    val = _val;</span></span><br><span class="line"><span class="comment">    next = NULL;</span></span><br><span class="line"><span class="comment">    random = NULL;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    Node* p = head;</span><br><span class="line">    <span class="comment">// 先复制串联镜像节点 a-&gt;a&#x27;-&gt;b-&gt;b&#x27;-&gt;c-&gt;c</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      Node* node = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">      node-&gt;next = p-&gt;next;</span><br><span class="line">      p-&gt;next = node;</span><br><span class="line">      p = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = head;</span><br><span class="line">    Node* cp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 给复制节点们找到对应的随机指针的正确指向</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      cp = p-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;random != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cp-&gt;random = p-&gt;random-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      p = cp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = head;</span><br><span class="line">    cp = head-&gt;next;</span><br><span class="line">    Node* newHead = cp;</span><br><span class="line">    <span class="comment">// p 和 cp 各自串自己的糖葫芦</span></span><br><span class="line">    <span class="keyword">while</span> (cp-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      p-&gt;next = cp-&gt;next;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">      cp-&gt;next = p-&gt;next;</span><br><span class="line">      cp = cp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148.排序链表"></a>148.排序链表</h2><blockquote>
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<p>示例 1：输入：head = [4,2,1,3] 输出：[1,2,3,4]</p>
<p>示例 2：输入：head = [-1,5,3,4,0] 输出：[-1,0,3,4,5]</p>
<p>示例 3：输入：head = [] 输出：[]</p>
</blockquote>
<p>分析:<br>1.采用分治 (归并) 的方法, 每次先找到链表的中点, 强行断开, 然后执行归并排序<br>2.每次找中点的时候, 用快慢指针找中点, 注意这里的中点是偏小的那一个, 也就是 slow 前面的 pre 指针, 这样比较适合前后断开的操作<br>3.合并的时候, 执行的是两个有序链表的合并操作<br>4.归并排序的思路 + 快慢指针找中点 + 有序链表合并之后可以完成该操作  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">findMidNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* pre;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      pre = slow;</span><br><span class="line">      slow = slow-&gt;next;</span><br><span class="line">      fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ListNode* <span class="title">mergeSortedList</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode* cur = dummy;</span><br><span class="line">    ListNode* p1 = list1;</span><br><span class="line">    ListNode* p2 = list2;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val) &#123;</span><br><span class="line">        cur-&gt;next = p1; </span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur-&gt;next = p2;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = (p1 != <span class="literal">nullptr</span>) ? p1 : p2;</span><br><span class="line">    ListNode* ret = dummy-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> dummy;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* p1 = head;</span><br><span class="line">    ListNode* mid = <span class="built_in">findMidNode</span>(head);</span><br><span class="line">    ListNode* p2 = mid-&gt;next;</span><br><span class="line">    mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    p1 = <span class="built_in">sortList</span>(p1);</span><br><span class="line">    p2 = <span class="built_in">sortList</span>(p2);</span><br><span class="line">    ListNode* ans = <span class="built_in">mergeSortedList</span>(p1, p2);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23.合并 K 个升序链表"></a>23.合并 K 个升序链表</h2><blockquote>
<p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p>示例 1：输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
<p>示例 2：输入：lists = [] 输出：[]</p>
<p>示例 3：输入：lists = [[]] 输出：[]</p>
</blockquote>
<p>分析:<br>1.如果是合并 2 个升序链表, 我们可以维护两个指针去比较, 如果是 k 个链表, 则不太好比较<br>2.如果想维护 k 个链表里面的最小值, 那么需要引入一个小顶堆去找到最小节点, 来多少个链表我们都不管, 我们每次都取最小的那个节点: 每次取出来最小的那个节点, 然后链接到生成的链表的末尾, 看下后续还有无其他的节点, 有的话放入队列一起比较, 直到最后队列元素为空  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [] (ListNode* p1, ListNode* p2) &#123;</span><br><span class="line">      <span class="keyword">return</span> p2-&gt;val &lt; p1-&gt;val; </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 采用一个按照值排序的有限队列</span></span><br><span class="line">    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, <span class="keyword">decltype</span>(cmp)&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> head: lists) &#123;</span><br><span class="line">      <span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(head);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode* cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      cur-&gt;next = pq.<span class="built_in">top</span>();</span><br><span class="line">      pq.<span class="built_in">pop</span>();</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(cur-&gt;next);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* ans = dummy-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> dummy;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146.LRU 缓存"></a>146.LRU 缓存</h2><blockquote>
<p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
<p>示例：<br>输入<br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>输出<br>[null, null, null, 1, null, -1, null, -1, 3, 4]<br>解释<br>LRUCache lRUCache = new LRUCache(2);<br>lRUCache.put(1, 1); // 缓存是 {1=1}<br>lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}<br>lRUCache.get(1);    // 返回 1<br>lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}<br>lRUCache.get(2);    // 返回 -1 (未找到)<br>lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}<br>lRUCache.get(1);    // 返回 -1 (未找到)<br>lRUCache.get(3);    // 返回 3<br>lRUCache.get(4);    // 返回 4</p>
</blockquote>
<p>分析:<br>1.我们回忆一下 LRU cache 要实现什么, 首先考虑是构造一个队列, 用于模拟的访问 cache 的时间顺序关系; 另外, 因为要 O(1) 实现查找, 所以需要一个哈希表指向节点; 因为还要 O(1) 的复杂度实现插入和删除, 就需要搞一个双端链表去模拟加入的时序关系; 构造一个双端链表的中间结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DLinkedListNode</span> &#123;</span><br><span class="line">  <span class="type">int</span> key;</span><br><span class="line">  <span class="type">int</span> value;</span><br><span class="line">  DLinkedListNode* pre;</span><br><span class="line">  DLinkedListNode* next;</span><br><span class="line">  <span class="built_in">DLinkedListNode</span>(): <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">DLinkedListNode</span>(<span class="type">int</span> _key, <span class="type">int</span> _value): <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">pre</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">int</span> totalCapacity;</span><br><span class="line">  DLinkedListNode* dummyHead;</span><br><span class="line">  DLinkedListNode* dummyTail;</span><br><span class="line">  unordered_map&lt;<span class="type">int</span>, DLinkedListNode*&gt; key2node;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    totalCapacity = capacity;</span><br><span class="line">    dummyHead = <span class="keyword">new</span> <span class="built_in">DLinkedListNode</span>();</span><br><span class="line">    dummyTail = <span class="keyword">new</span> <span class="built_in">DLinkedListNode</span>();</span><br><span class="line">    dummyHead-&gt;next = dummyTail;</span><br><span class="line">    dummyTail-&gt;pre = dummyHead;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果待查询 key 不存在, 是个无效的查询, 直接返回 -1 </span></span><br><span class="line">  <span class="comment">// 如果存在, 移动 key 所在的 node 到开头</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!key2node.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DLinkedListNode* node = key2node[key];</span><br><span class="line">    <span class="built_in">moveNodeToHead</span>(node);</span><br><span class="line">    <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果待添加的 key 不存在, 加入哈希表 </span></span><br><span class="line">  <span class="comment">// 如果已经存在了, 移动在链表头, 重写 value</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!key2node.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">      DLinkedListNode* node = <span class="keyword">new</span> <span class="built_in">DLinkedListNode</span>(key, value);</span><br><span class="line">      key2node[key] = node;</span><br><span class="line">      <span class="built_in">addNodeToHead</span>(node);</span><br><span class="line">      ++size;</span><br><span class="line">      <span class="keyword">if</span> (size &gt; totalCapacity) &#123;</span><br><span class="line">        <span class="comment">// 返回待删除的节点的指针</span></span><br><span class="line">        DLinkedListNode* node = <span class="built_in">removeNodeTailNode</span>();</span><br><span class="line">        key2node.<span class="built_in">erase</span>(node-&gt;key);</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">        --size;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      DLinkedListNode* node = key2node[key];</span><br><span class="line">      node-&gt;value = value;</span><br><span class="line">      <span class="built_in">moveNodeToHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">moveNodeToHead</span><span class="params">(DLinkedListNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">removeNode</span>(node);</span><br><span class="line">    <span class="built_in">addNodeToHead</span>(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 双端操作: 先把 node 向 前后节点建立联系, 然后前后节点和 node 向 前后节点建立联系</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addNodeToHead</span><span class="params">(DLinkedListNode* node)</span> </span>&#123;</span><br><span class="line">    node-&gt;pre = dummyHead;</span><br><span class="line">    node-&gt;next = dummyHead-&gt;next; </span><br><span class="line">    dummyHead-&gt;next-&gt;pre = node; </span><br><span class="line">    dummyHead-&gt;next = node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(DLinkedListNode* node)</span>  </span>&#123;</span><br><span class="line">    node-&gt;pre-&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">DLinkedListNode* <span class="title">removeNodeTailNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DLinkedListNode* node = dummyTail-&gt;pre; </span><br><span class="line">    <span class="built_in">removeNode</span>(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h2><blockquote>
<p>给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</p>
<p>示例 1：输入：root = [1,null,2,3] 输出：[1,3,2]</p>
<p>示例 2：输入：root = [] 输出：[]</p>
<p>示例 3：输入：root = [1] 输出：[1]</p>
</blockquote>
<p>分析:<br>1.递归方法比较简单, 这里用迭代方法<br>2.迭代方法的本质是需要记录下来 [上一个访问的根节点], 因为二叉树这个结构只有向下遍历操作没法直接往回回溯, 所以需要引入栈去记录下来最近一次上一个根节点是哪个节点  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;TreeNode*&gt; preRoot;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !preRoot.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        preRoot.<span class="built_in">push</span>(root);</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">      &#125;</span><br><span class="line">      root = preRoot.<span class="built_in">top</span>();</span><br><span class="line">      preRoot.<span class="built_in">pop</span>();</span><br><span class="line">      ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">      root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h2><blockquote>
<p>给定一个二叉树 root ，返回其最大深度。</p>
<p>二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<p>示例 1：输入：root = [3,9,20,null,null,15,7] 输出：3</p>
<p>示例 2：输入：root = [1,null,2] 输出：2<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><br>返回它的最大深度 3 。</p>
</blockquote>
<p>分析:<br>1.采用分解问题的思维, 当前 root 节点最大深度, 等于它的左子树最大深度和右子树最大深度之间的最大值 + 1, 因此可以写出递归代码  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lMaxDepth = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rMaxDepth = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(lMaxDepth, rMaxDepth) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h2><blockquote>
<p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p>
<p>示例 1：输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1]</p>
<p>示例 2：输入：root = [2,1,3] 输出：[2,3,1]</p>
<p>示例 3：输入：root = [] 输出：[]</p>
</blockquote>
<p>分析:<br>1.采用分解问题的思维, 原问题翻转之后的效果等于左子树翻转完, 右子树翻转完之后再左右翻转<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* lInverted = <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">    TreeNode* rInverted = <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">    root-&gt;left = rInverted;</span><br><span class="line">    root-&gt;right = lInverted;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h2><blockquote>
<p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
<p>示例 1：输入：root = [1,2,2,3,4,4,3] 输出：true</p>
<p>示例 2：输入：root = [1,2,2,null,3,null,3] 输出：false</p>
</blockquote>
<p>分析:<br>1.采用分解的思维: 对于原问题来说, 给定一个根节点, 需要判定左子树和右子树是对称的,  怎么判定左子树和右子树是对称的<br>2.要想判定左子树和右子树对称性, 需要生成两个指针来同时遍历, 一个向左一个向右, 然后1生2, 2生4, 4生成8…  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// p 和 q 是两个同时遍历具有对称性的指针</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">check</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="built_in">check</span>(p-&gt;right, q-&gt;left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543.二叉树的直径"></a>543.二叉树的直径</h2><blockquote>
<p>给你一棵二叉树的根节点，返回该树的 直径 。二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。<br>两节点之间路径的 长度 由它们之间边数表示。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> / \   </span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>  </span><br></pre></td></tr></table></figure></p>
<p>示例 1：输入：root = [1,2,3,4,5] 输出：3 解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。</p>
<p>示例 2：输入：root = [1,2] 输出：1</p>
</blockquote>
<p>分析:<br>1.具体到一个根节点, 它所在的直径等于最大深度等于什么?<br>2.如果能想到对于一个根节点, 它的直径等于 [左子树数的最大深度] 和 [右子树的最大深度] 之和<br>3.我们写一个最大深度的函数, 然后不断更新这个最大深度<br>4.一个二叉树的的最大深度是怎么来的 ? 是另一个可以用分解的思维去思考的问题, 对于一个根节点来说, 它的最大深度等于 max(左子树的最大深度, 右子树的最大深度) + 1  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 写一个求最大深度的函数</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lMaxDepth = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rMaxDepth = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 对于一个根节点而言, 它的直径等于 [左子树数的最大深度] 和 [右子树的最大深度] 之和;</span></span><br><span class="line">    <span class="type">int</span> diameter = lMaxDepth + rMaxDepth;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, diameter);</span><br><span class="line">    <span class="comment">// 对于一个根节点而言, 最大深度等于 max(lMaxDepth, rMaxDepth) + 1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(lMaxDepth, rMaxDepth) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">maxDepth</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h2><blockquote>
<p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p>
<p>示例 1：输入：root = [3,9,20,null,null,15,7] 输出：[[3],[9,20],[15,7]]<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3 </span><br><span class="line"> / \</span><br><span class="line">9   20</span><br><span class="line">    / \   </span><br><span class="line">  15   7 </span><br></pre></td></tr></table></figure><br>示例 2：输入：root = [1] 输出：[[1]]</p>
<p>示例 3：输入：root = [] 输出：[]</p>
</blockquote>
<p>分析:<br>1.层序遍历用队列模拟  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; levelVec;</span><br><span class="line">      <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="type">int</span> val = node-&gt;val;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        levelVec.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        --len;</span><br><span class="line">      &#125;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(levelVec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h2><blockquote>
<p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。<br>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<p>示例 1：输入：nums = [-10,-3,0,5,9] 输出：[0,-3,9,-10,null,5] 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</p>
<p>示例 2：输入：nums = [1,3] 输出：[3,1] 解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</p>
</blockquote>
<p>分析:<br>1.BST 的中序遍历正好是有序序列, 给定中序遍历, 能否唯一确定一个二叉搜索树? 不能, 在没限制平衡的设定下, 任何一个数字都可以作为二叉搜索树的根节点<br>2.如果我们要求二叉搜索树平衡, 是否可以确定唯一一个二叉搜索树? 也不能. 举个反例是一个节点下面各两个子树, 但是每个子树下面2个唯一分支节点, 左孩子或者右孩子各种换位置都可以满足需求<br>3.那怎么能能确定根节点, 然后保证构造出来的一定是平衡的呢? 如果数组长度是奇数, 那么中间的节点是唯一可行的根节点, 如果偶数, 那么中间位置左边或者右边都能做根节点<br>4.中间位置是 int mid = l + (r - l) / 2  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TreeNode* <span class="title">construct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">    root-&gt;left = <span class="built_in">construct</span>(nums, l, mid - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = <span class="built_in">construct</span>(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> root; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">construct</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h2><blockquote>
<p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。<br>有效 二叉搜索树定义如下：<br>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>
<p>示例 1：输入：root = [2,1,3] 输出：true</p>
<p>示例 2：输入：root = [5,1,4,null,null,3,6] 输出：false 解释：根节点的值是 5 ，但是右子节点的值是 4 。</p>
</blockquote>
<p>分析:<br>1.BST 的中序遍历是完全有序的, 我们利用这个性质, 中序迭代遍历二叉树, 然后发现前一个元素和后一个元素是违反有序关系的, 那么一定非BST;<br>2.迭代中序遍历, 并额外维护一个 preNode 指针, 遍历过程中每次比较 preNode 和 cur 的关系是不满足 &lt; 情况判定非BST  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* preNode = <span class="literal">nullptr</span>; </span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        s.<span class="built_in">push</span>(root);</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">      &#125;</span><br><span class="line">      root = s.<span class="built_in">top</span>();</span><br><span class="line">      s.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (preNode != <span class="literal">nullptr</span> &amp;&amp; preNode-&gt;val &gt;= root-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      preNode = root;</span><br><span class="line">      root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230.二叉搜索树中第K小的元素"></a>230.二叉搜索树中第K小的元素</h2><blockquote>
<p>给定一个二叉搜索树的根节点 root， 和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p>
<p>示例 1：输入：root = [3,1,4,null,2], k = 1 输出：1</p>
<p>示例 2：输入：root = [5,3,6,2,4,null,null,1], k = 3 输出：3</p>
</blockquote>
<p>分析:<br>1.BST中序遍历正好是有序的, 因此采用中序遍历, 找到遍历数 == k 的时候, 返回, 先用递归版本 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> rank = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left, k);</span><br><span class="line">    <span class="comment">// 搜到中序位置</span></span><br><span class="line">    ++rank;</span><br><span class="line">    <span class="keyword">if</span> (k == rank) &#123;</span><br><span class="line">      ans = root-&gt;val;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right, k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">traverse</span>(root, k);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同时顺便写一下迭代版本的中序遍历搜索</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        s.<span class="built_in">push</span>(root);</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">      &#125;</span><br><span class="line">      root = s.<span class="built_in">top</span>();</span><br><span class="line">      s.<span class="built_in">pop</span>();</span><br><span class="line">      --k;</span><br><span class="line">      <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val; </span><br><span class="line">      &#125;</span><br><span class="line">      root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.假如我们频繁地查找第 k 小的值, 有没有优化方法? 我们每次采用重新中序遍历的一个前提是不知道每个根节点的子树的节点总数, 假设我们已经知道了每个根节点的左子树的以某个节点的子树节点总数为 nodeNum, 可以先用左子树的节点数和我们要找的 k 进行比较, 判定是否在左子树里面, 或者在右子树里面, 还是直接就是当前根节点就是第 k 小的树<br>3.令 node 为当前根节点开始搜索, 也就是说一开始指针指向 root,<br>如果 node 的左子树的节点数 leftNodeNum &lt; k-1, 那么第 k 小的元素在 node 的右子树中, 指针搜向右边的子树 node=node-&gt;right, 搜索的空间可以直接减去 (leftNodeNums + 1), 然后继续搜索<br>如果 node 的左子树的节点数 leftNodeNum == k-1, 那么第 k 小的元素就是 node 直接返回 node<br>如果 node 的左子树的节点数 leftNodeNum &gt; k-1, 那么第 k 小的元素在node的左子树里面, 指针走向左子树里面搜索 node=node-&gt;left, 继续搜索<br>3.为实现上述的逻辑, 先将每个根节点数保存在哈希表中  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  unordered_map&lt;TreeNode*, <span class="type">int</span>&gt; nodeNum;</span><br><span class="line">  <span class="comment">// 记录以 node 为根节点的树的节点总数</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">countNodesNum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span> + <span class="built_in">countNodesNum</span>(root-&gt;left) + <span class="built_in">countNodesNum</span>(root-&gt;right);</span><br><span class="line">    nodeNum[root] = num;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">countNodesNum</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="type">int</span> leftNodeNum = nodeNum[root-&gt;left];</span><br><span class="line">      <span class="keyword">if</span> (leftNodeNum &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">        k -= leftNodeNum + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftNodeNum == k - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftNodeNum &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a>199.二叉树的右视图</h2><blockquote>
<p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p>示例 1: 输入: [1,2,3,null,5,null,4] 输出: [1,3,4]</p>
<p>示例 2: 输入: [1,null,3] 输出: [1,3]</p>
<p>示例 3: 输入: [] 输出: []</p>
</blockquote>
<p>分析:<br>1.层序遍历  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="type">int</span> qlen = q.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">while</span> (qlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          q.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          q.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (qlen == <span class="number">1</span>) &#123;</span><br><span class="line">          ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        --qlen;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114.二叉树展开为链表"></a>114.二叉树展开为链表</h2><blockquote>
<p>给你二叉树的根结点 root ，请你将它展开为一个单链表：<br>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
<p>示例 1：输入：root = [1,2,5,3,4,null,6] 输出：[1,null,2,null,3,null,4,null,5,null,6]</p>
<p>示例 2：输入：root = [] 输出：[]</p>
<p>示例 3：输入：root = [0] 输出：[0]</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    1          1         1</span><br><span class="line">   / \        / \         \</span><br><span class="line">  2   5      2   5         2</span><br><span class="line"> / \   \      \   \         \</span><br><span class="line">3   4   6      3   6         3</span><br><span class="line">                \             \</span><br><span class="line">                 4             4</span><br><span class="line">                                \</span><br><span class="line">                                 5</span><br><span class="line">                                  \</span><br><span class="line">                                   6</span><br></pre></td></tr></table></figure>
<p>分析:<br>1.先理解一下二叉树转换为链表是什么意思 ? 链表本质上就是只有一个子树的二叉树, 二叉树就是链表的第一个节点多开出来一条链表的链表<br>2.可以用递归/非递归先序遍历, 遍历过程中把元素存储到数组里面, 然后再遍历这个数组构建一个二叉树  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;TreeNode*&gt; list;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 先序转数组</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">preorderTraverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list.<span class="built_in">push_back</span>(root);</span><br><span class="line">    <span class="built_in">preorderTraverse</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preorderTraverse</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">preorderTraverse</span>(root);</span><br><span class="line">    <span class="type">int</span> len = list.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 迭代构建树: 左孩子置空指针, 右孩子链接起来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      TreeNode* pre = list[i<span class="number">-1</span>];</span><br><span class="line">      TreeNode* cur = list[i];</span><br><span class="line">      pre-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">      pre-&gt;right = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.思考能否用分解的思路递归实现, 那么就要看看怎么去实现 flatten 这种操作, 也就是找 flatten 子树和当前根节点的关系<br>3.如下所示 一个flatten操作可以分解为 3 步, 先把左右子树分别做 flatten, 然后将右子树接在左子树的最下面, 然后把左子树换到右子树<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    1          1         1</span><br><span class="line">   / \        / \         \</span><br><span class="line">  2   5      2   5         2</span><br><span class="line"> / \   \      \   \         \</span><br><span class="line">3   4   6      3   6         3</span><br><span class="line">                \             \</span><br><span class="line">                 4             4</span><br><span class="line">                                \</span><br><span class="line">                                 5</span><br><span class="line">                                  \</span><br><span class="line">                                   6</span><br></pre></td></tr></table></figure></p>
<p>将三步都写出来, 得到完整答案  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">flatten</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">flatten</span>(root-&gt;right);</span><br><span class="line">    TreeNode* left = root-&gt;left;</span><br><span class="line">    TreeNode* right = root-&gt;right;</span><br><span class="line">    root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    root-&gt;right = left;</span><br><span class="line">    TreeNode* p = root;</span><br><span class="line">    <span class="keyword">while</span> (p -&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h2><blockquote>
<p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<p>示例 1: 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]  输出: [3,9,20,null,null,15,7]</p>
<p>示例 2: 输入: preorder = [-1], inorder = [-1] 输出: [-1]</p>
</blockquote>
<p>分析:<br>1.先拿一个例子看,<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">    / \</span><br><span class="line">  2     3</span><br><span class="line"> / \   / \ </span><br><span class="line">5   4 8   9 </span><br><span class="line">   / \</span><br><span class="line">  6   7</span><br></pre></td></tr></table></figure><br>preorder<br>1,[2,5,4,6,7],[3,8,9]<br>inorder<br>[5,2,6,4,7],1,[8,3,9]<br>根节点把 inorder 可以划分成两半, 然后继续递归建立树, 每次建立树在先序数组里面维护起点和终点, 在中序里面也要维护起点和终点; 所以思路是先找根节点 =&gt; 左右子树递归建树, 建树的过程需要算各种长度, 我们先写个代码框架:  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> preLow, <span class="type">int</span> preHigh, <span class="type">int</span> inLow, <span class="type">int</span> inHigh)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (preLow &gt; preHigh) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到先序的第一个就是根节点</span></span><br><span class="line">  <span class="type">int</span> rootVal = preorder[preLow];</span><br><span class="line">  <span class="type">int</span> rootInorderIdx;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = inLow; i &lt;= inHigh; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder[i] == rootVal) &#123;</span><br><span class="line">      rootInorderIdx = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  TreeNode* root = <span class="built_in">newTreeNode</span>(rootVal);</span><br><span class="line">  root-&gt;left = <span class="built_in">build</span>(preorder, inorder, ?, ?, ?, ?);</span><br><span class="line">  root-&gt;right = <span class="built_in">build</span>(preorder, inorder, ?, ?, ?, ?);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">build</span>(preorder, inorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>()<span class="number">-1</span>, inorder.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在需要明确上面递归构建子树的时候 index 填什么, 如果能填对相应的 4 个index, 那么就完成了; 我们发现在中序序列里面是比较好填的, 无非就是左侧给到左子树, 右侧给到右子树  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* root = <span class="built_in">newTreeNode</span>(rootval);</span><br><span class="line">root-&gt;left = <span class="built_in">build</span>(preorder, inorder, ?, ?, inlow, rootInorderIdx<span class="number">-1</span>);</span><br><span class="line">root-&gt;right = <span class="built_in">build</span>(preorder, inorder, ?, ?, rootInorderIdx<span class="number">+1</span>, inHigh);</span><br></pre></td></tr></table></figure>
<p>那么先序的左边起止点怎么填?<br>先序左边的起点是 preLow+1, 先序的终点呢? 其实是要找到先序左侧对应的 size 有多大, 然后 preLow + leftSize<br>先序右边的终点是 preHigh, 先序的起点呢? 顺着上面的结论, 其实就是左侧那个区间的后一个节点, 可以得到preLow + leftSize + 1<br>leftSize = rootInorderIdx - inLow<br>把这些起止点都梳理清楚后, 然后就能递归的建树了  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftSize = rootInorderIdx - inLow;</span><br><span class="line">root-&gt;left = <span class="built_in">build</span>(preorder, inorder, preLow<span class="number">+1</span>, preLow+leftSize, inlow, rootInorderIdx<span class="number">-1</span>);</span><br><span class="line">root-&gt;right = <span class="built_in">build</span>(preorder, inorder, preLow+leftSize<span class="number">+1</span>, preHigh, rootInorderIdx<span class="number">+1</span>, inHigh);</span><br></pre></td></tr></table></figure>
<p>完整代码如下  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; inorderValue2indx;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> prel, <span class="type">int</span> preh, <span class="type">int</span> inl, <span class="type">int</span> inh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prel &gt; preh) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到根节点</span></span><br><span class="line">    <span class="type">int</span> rootVal = preorder[prel];</span><br><span class="line">    <span class="type">int</span> rootInorderIdx = inorderValue2indx[rootVal];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line">    <span class="type">int</span> leftSize = rootInorderIdx - inl;</span><br><span class="line">    root-&gt;left = <span class="built_in">build</span>(preorder, inorder, prel + <span class="number">1</span>, prel + leftSize, inl, rootInorderIdx - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = <span class="built_in">build</span>(preorder, inorder, prel + leftSize + <span class="number">1</span>, preh, rootInorderIdx + <span class="number">1</span>, inh);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      inorderValue2indx[inorder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">build</span>(preorder, inorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有个优化点, 因为数组中不存在重复元素, 那么可以提前把中序遍历的根节点对应的index 提前保存在 hash 表中, 找 index 的时间复杂度降低为 O(1)  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 记录下来中序遍历中每个值对应的index</span></span><br><span class="line">  unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; inorderValue2indx;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> prel, <span class="type">int</span> preh, <span class="type">int</span> inl, <span class="type">int</span> inh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prel &gt; preh) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到根节点</span></span><br><span class="line">    <span class="type">int</span> rootVal = preorder[prel];</span><br><span class="line">    <span class="type">int</span> rootInorderIdx = inorderValue2indx[rootVal];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line">    <span class="type">int</span> leftSize = rootInorderIdx - inl;</span><br><span class="line">    root-&gt;left = <span class="built_in">build</span>(preorder, inorder, prel + <span class="number">1</span>, prel + leftSize, inl, rootInorderIdx - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = <span class="built_in">build</span>(preorder, inorder, prel + leftSize + <span class="number">1</span>, preh, rootInorderIdx + <span class="number">1</span>, inh);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      inorderValue2indx[inorder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">build</span>(preorder, inorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437.路径总和 III"></a>437.路径总和 III</h2><blockquote>
<p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。 路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）</p>
<p>示例 1：输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8 输出：3 解释：和等于 8 的路径有 3 条，如图所示。</p>
<p>示例 2：输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 输出：3<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">         10 </span><br><span class="line">       /    \</span><br><span class="line">     5       -3 </span><br><span class="line">    /  \       \</span><br><span class="line">   3    2       11 </span><br><span class="line">  /  \   \ </span><br><span class="line">3    -2   1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>分析:<br>1.这个题中提到的路径不需要从根节点开始, 而是累计以根节点为根节点包含下的所有 (经过或者不经过根节点) 的路径. 因此用分解问题的思维, 以根节点为根节点的所有路径总和, 等于左子树包含的路径总和 + 右子树包含的路径总和 + 以根节点为必经节点下的路径总和; 写成代码就是 pathSum(root-&gt;left) + pathSum(root-&gt;right) + rootViaSum(root), 其中 rootViaSum(root) 以根节点为必经节点下的路径总和<br>2.所以我们思考如何计算 rootViaSum(root) , 也就是以某个具体的根节点为根节点, 然后必须经过这个根节点的路径总和; 这里又要采用另一个分解思维: 当前的这个求和为 targetSum 的话, 可以有 3 种方式, 一种是一开始根节点就能满足路径总和, 另外两种是根节点和下面左子树凑出来路径总和, 以及根节点和右子树凑出来路径总和  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// rootViaSum 计算必须经过这个根节点的路径总和</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">rootViaSum</span><span class="params">(TreeNode* root, <span class="type">long</span> <span class="type">long</span> targetSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算必须经过这个根节点的路径总和 = 可能的根节点值等于 target的情况=1/否则0 + 根节点和下面左子树凑出来路径总和 + 根节点和下面右子树凑出来的路径总和</span></span><br><span class="line">    <span class="keyword">return</span> ((root-&gt;val == targetSum) ? <span class="number">1</span> : <span class="number">0</span>) + <span class="built_in">rootViaSum</span>(root-&gt;left, targetSum - root-&gt;val) + <span class="built_in">rootViaSum</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以根节点为根节点的所有路径总和 = 左子树包含的路径总和 + 右子树包含的路径总和 + 以根节点为必经节点下的路径总和</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rootViaSum</span>(root, targetSum) + <span class="built_in">pathSum</span>(root-&gt;left, targetSum) + <span class="built_in">pathSum</span>(root-&gt;right, targetSum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236.二叉树的最近公共祖先"></a>236.二叉树的最近公共祖先</h2><blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”  </p>
<p>示例 1：输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 .<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       3 </span><br><span class="line">     /   \</span><br><span class="line">   5       1 </span><br><span class="line"> /  \     /  \</span><br><span class="line">6    2   0    3 </span><br><span class="line">   /   \ </span><br><span class="line">  7     4 </span><br></pre></td></tr></table></figure><br>示例 2：输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5  解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>示例 3：输入：root = [1,2], p = 1, q = 2 输出：1  </p>
</blockquote>
<p>分析:<br>1.给定一个根节点, 然后给定树里面任意两个节点, 让我们找这两个任意节点的最低公共祖先<br>2.先可以判定一些非常简单的情况, 假设 p 和 q 之间本身有一个祖先关系, 也就是说 root == p || root = q 那么就说明这时候的 root 就是最近公共祖先<br>3.然后我们处理一些相对复杂的情况, 根节点在上面, 然后 p 和 q 在根节点的下面分布着, 下一步怎么搜索呢 ? 根节点的搜索指针可以向下移动, 可以从根节点左子树搜索 p 和 q, 也可以从根节点的右子树搜索 p 和 q; 这里有 3 种可能的情况,<br>(i). p 和 q 都在左子树, 那么我们就在 左子树里面递归找最低公共祖先<br>(ii). p 和 q 都在右子树, 那么我们就在 右子树里面递归找最低公共祖先<br>(iii). p 和 q 左右子树各一个, 最低公共祖先就是 root  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">nodeInSubTree</span><span class="params">(TreeNode* root, TreeNode* c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root == c) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">nodeInSubTree</span>(root-&gt;left, c) || <span class="built_in">nodeInSubTree</span>(root-&gt;left, c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">nodeInSubTree</span>(root-&gt;left, p) &amp;&amp; <span class="built_in">nodeInSubTree</span>(root-&gt;right, q)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">nodeInSubTree</span>(root-&gt;right, p) &amp;&amp; <span class="built_in">nodeInSubTree</span>(root-&gt;right, q)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4.我们再想一下, 既然总共就 以上 3 种情况, 这里我们也不用非要判断 p 和 q 具体要在哪个子树里面: 情况还是如上三种, 我们逐次判断 2 种情况的存在性就可以  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* lRes = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* rRes = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (lRes != <span class="literal">nullptr</span> &amp;&amp; rRes != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lRes == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> rRes;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> lRes;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124.二叉树中的最大路径和"></a>124.二叉树中的最大路径和</h2><blockquote>
<p>二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。路径和 是路径中各节点值的总和。给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<p>示例 1：输入：root = [1,2,3] 输出：6 解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</p>
<p>示例 2：输入：root = [-10,9,20,null,null,15,7] 输出：42 解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    -10</span><br><span class="line">     / \</span><br><span class="line">   9    20 </span><br><span class="line">  / \   / \     </span><br><span class="line">-2     15  7 </span><br></pre></td></tr></table></figure>
<p>分析:<br>1.因为最大路径和可以不包含根节点, 所以我们要遍历出来以每个根节点为根节点的二叉树的最大路径和, 然后迭代出来最大的, 所以我们分析下以某个根节点为根节点的二叉树的最大路径和怎么来的?<br>2.以当前根节点为根节点的二叉树的最大路径和 = 根节点的值 + 左子树的最大路径和 + 右子树的最大路径和; 左子树的最大路径和是什么 ? 这里每个节点是有正有负的, 如果左子树最大路径和是个负数, 那么我们把左子树的负增益要砍掉, 反而是最大的; 所以准确地说, 我们考虑的左子树的最大路径和, 考虑的是经过左孩子为根节点的向下路径求和增益 (右子树同理); 以当前根节点为根节点的二叉树的最大路径和 = 根节点的值 + 经过左孩子为根节点的向下路径求和增益 + 经过右孩子为根节点的向下路径求和增益, 其中, 增益表示的是至少是个 &gt;= 0 的值<br>经过左孩子为根节点的向下路径求和增益 = max(viaRootPathSumGain(root-&gt;left), 0)<br>经过左孩子为根节点的向下路径求和增益 = max(viaRootPathSumGain(root-&gt;right), 0)<br>3.所以, 我们要写的函数是 viaRootPathSumGain(), 代表了经过 root 为根节点的向下路径的求和增益, 这个路径上的增益是什么? 根节点的值加左右增益路径中最大的一边的值: 经过 root 为根节点的向下路径的下求和增益 = root-&gt;val + max(经过左孩子为根节点的向下路径求和增益, 经过右孩子为根节点的向下路径求和增益)  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> ans = INT_MIN;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// viaRootPathSumGain 返回经过 root 为根节点的向下路径的求和增益</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">viaRootPathSumGain</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 经过左/右孩子节点的向下陆景求和增益, 增益表示限制下界是0, 路径和为负数一律不考虑</span></span><br><span class="line">    <span class="type">int</span> lPathSumGain = <span class="built_in">max</span>(<span class="built_in">viaRootPathSumGain</span>(root-&gt;left), <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> rPathSumGain = <span class="built_in">max</span>(<span class="built_in">viaRootPathSumGain</span>(root-&gt;right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序位置迭代: 求经过 root 的二叉树的最大路径和</span></span><br><span class="line">    <span class="comment">// 经过 root 的二叉树的最大路径和 = root 的值 + 经过左孩子为根节点的向下路径求和增益 + 经过右孩子为根节点的向下路径求和增益</span></span><br><span class="line">    <span class="type">int</span> curPathSum = root-&gt;val + lPathSumGain + rPathSumGain;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, curPathSum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经过 root 为根节点的向下路径的求和增益 = root-&gt;val + max(经过左孩子为根节点的向下路径求和增益, 经过右孩子为根节点的向下路径求和增益)</span></span><br><span class="line">    <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(lPathSumGain, rPathSumGain);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">viaRootPathSumGain</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h2><blockquote>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例 1：<br>输入：grid = [<br>  [“1”,”1”,”1”,”1”,”0”],<br>  [“1”,”1”,”0”,”1”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1</p>
<p>示例 2：<br>输入：grid = [<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”1”,”0”,”0”],<br>  [“0”,”0”,”0”,”1”,”1”]<br>]<br>输出：3</p>
</blockquote>
<p>分析:<br>1.遍历岛屿, 然后遇到1的情况下累加岛屿个数, 然后 dfs 四个方向把链接的地方都标注成水  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">      grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">        <span class="type">int</span> nx = i + dirs[k][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ny = j + dirs[k][<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">dfs</span>(grid, nx, ny);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">          ++ans;</span><br><span class="line">          <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994.腐烂的橘子"></a>994.腐烂的橘子</h2><blockquote>
<p>在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：<br>值 0 代表空单元格；值 1 代表新鲜橘子；值 2 代表腐烂的橘子。<br>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。<br>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。</p>
<p>示例 1：输入：grid =<br>[<br>  [2,1,1],<br>  [1,1,0],<br>  [0,1,1]<br>] 输出：4</p>
<p>示例 2：输入：grid =<br>[<br>  [2,1,1],<br>  [0,1,1],<br>  [1,0,1]<br>]<br>输出：-1<br>解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。</p>
<p>示例 3：输入：grid =<br>[<br>  [0,2]<br>] 输出：0<br>解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</p>
</blockquote>
<p>分析:<br>1.模拟腐烂的过程, 对腐烂的橘子做广度优先搜索, 每一层数量分钟数增加1 , 然后模拟新鲜的橘子变成了腐烂的橘子<br>2.在模拟腐烂进行 BFS 的过程中, 持续判断新鲜的橘子 &gt; 0的, 如果新鲜橘子数量 == 0 了, 那么就停下来模拟, 返回结果<br>3.一开始遍历一下计数有多少个新鲜的橘子, 并将腐烂的橘子入队  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rows = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> cols = grid[<span class="number">0</span>].<span class="built_in">size</span>(); </span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">    queue&lt;pii&gt; q;</span><br><span class="line">    <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> freshCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 维护新鲜橘子的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">          ++freshCnt;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">          q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> minute = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 模拟腐烂的过程, bfs 实现</span></span><br><span class="line">    <span class="keyword">while</span> (freshCnt &gt; <span class="number">0</span> &amp;&amp; !q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      ++minute;</span><br><span class="line">      <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pii cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">          <span class="type">int</span> nx = cur.first + dirs[k][<span class="number">0</span>];</span><br><span class="line">          <span class="type">int</span> ny = cur.second + dirs[k][<span class="number">1</span>];</span><br><span class="line">          <span class="comment">// 如果是个新鲜的橘子, 腐烂掉</span></span><br><span class="line">          <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; rows &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; cols &amp;&amp; grid[nx][ny] == <span class="number">1</span>) &#123;</span><br><span class="line">            grid[nx][ny] = <span class="number">2</span>;</span><br><span class="line">            --freshCnt;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(nx, ny));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --len;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (freshCnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> minute;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207.课程表"></a>207.课程表</h2><blockquote>
<p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。<br>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p>
<p>示例 1：输入：numCourses = 2, prerequisites = [[1,0]] 输出：true 解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的.  </p>
<p>示例 2：输入：numCourses = 2, prerequisites = [[1,0],[0,1]] 输出：false 解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</p>
</blockquote>
<p>分析:<br>1.课程之间的关系可以抽象为图结构的依赖关系, 返回可行的结果就是给出一种拓扑排序的结果; 我们尝试对课程图进行拓扑排序, 如果检测到环, 直接停止下来返回 false<br>2.给出 bfs 和 dfs 的两种实现  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bfs 实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; indegree;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">resize</span>(numCourses, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    indegree.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : prerequisites) &#123;</span><br><span class="line">      edges[x[<span class="number">1</span>]].<span class="built_in">push_back</span>(x[<span class="number">0</span>]);</span><br><span class="line">      ++indegree[x[<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="type">int</span> c = q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">      ++cnt;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> n : edges[c]) &#123;</span><br><span class="line">        --indegree[n];</span><br><span class="line">        <span class="keyword">if</span> (indegree[n] == <span class="number">0</span>) &#123;</span><br><span class="line">          q.<span class="built_in">push</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == numCourses;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后写下 dfs 实现  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs 实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">  <span class="type">bool</span> hasCycle;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasCycle) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[c] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : edges[c]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (visited[n] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[n] == <span class="number">1</span>) &#123;</span><br><span class="line">        hasCycle = <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[c] = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">resize</span>(numCourses, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    visited.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : prerequisites) &#123;</span><br><span class="line">      edges[x[<span class="number">1</span>]].<span class="built_in">push_back</span>(x[<span class="number">0</span>]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasCycle) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !hasCycle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208.实现 Trie (前缀树)"></a>208.实现 Trie (前缀树)</h2><blockquote>
<p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。<br>请你实现 Trie 类：<br>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</p>
<p>示例：<br>输入<br>[“Trie”, “insert”, “search”, “search”, “startsWith”, “insert”, “search”]<br>[[], [“apple”], [“apple”], [“app”], [“app”], [“app”], [“app”]]<br>输出<br>[null, null, true, false, true, null, true]<br>解释<br>Trie trie = new Trie();<br>trie.insert(“apple”);<br>trie.search(“apple”);   // 返回 True<br>trie.search(“app”);     // 返回 False<br>trie.startsWith(“app”); // 返回 True<br>trie.insert(“app”);<br>trie.search(“app”);     // 返回 True</p>
</blockquote>
<p>分析:<br>1.Trie 实现, 开一个指向 Trie 的数组 vector<Trie*> children, 写一个前缀匹配的函数以及插入单词的函数  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;Trie*&gt; children; <span class="comment">// 子节点指针, 指向的是 Trie 类型的孩子节点, 用一个数组</span></span><br><span class="line">  <span class="type">bool</span> isEnd;             <span class="comment">// 标记已经是末尾</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Trie</span>() &#123;</span><br><span class="line">    children = <span class="built_in">vector</span>&lt;Trie*&gt;(<span class="number">26</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    isEnd = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 搜索前缀的函数: 实现核心搜索前缀的功能</span></span><br><span class="line">  <span class="comment">// 如果前缀完全匹配, 返回非空的指针;</span></span><br><span class="line">  <span class="comment">// 如果前缀匹配过程中没有匹配到, 直接返回空指针;</span></span><br><span class="line">  <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">    Trie* node = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: word) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入字符串的函数</span></span><br><span class="line">  <span class="comment">// 遍历字符串</span></span><br><span class="line">  <span class="comment">// 如果当前 children[ch] 已经开了指针, node 沿着指针搜索 node = node-&gt;children[c - &#x27;a&#x27;];</span></span><br><span class="line">  <span class="comment">// 如果当前 children[ch] 没有开指针, 那么 new 一个 Trie();</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">    Trie* node = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: word) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      node = node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 匹配前缀函数: 能搜到前缀</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">searchPrefix</span>(prefix) != <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 匹配单词函数: 能搜到前缀, 且 idEnd 标记为 true</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">    Trie* node = <span class="built_in">searchPrefix</span>(word);</span><br><span class="line">    <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEnd == <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h2><blockquote>
<p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<p>示例 1：输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>
<p>示例 2：输入：nums = [0,1] 输出：[[0,1],[1,0]]</p>
<p>示例 3：输入：nums = [1] 输出：[[1]]</p>
</blockquote>
<p>分析:<br>1.因为数组中的元素已经不重复, 我们 dfs + 回溯依次放入相应的元素, 直到判断元素个数已经达到目标元素个数<br>2.放入的时候判断重复的元素不能放入  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; cur, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="comment">// 检测到数组中已经存在该元素不执行放入</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">find</span>(cur.<span class="built_in">begin</span>(), cur.<span class="built_in">end</span>(), nums[i]) != cur.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cur.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">      <span class="built_in">dfs</span>(nums, cur, ans);</span><br><span class="line">      cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    <span class="built_in">dfs</span>(nums, cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h2><blockquote>
<p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<p>示例 1：输入：nums = [1,2,3]  输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p>
<p>示例 2：输入：nums = [0]  输出：[[],[0]]</p>
</blockquote>
<p>分析:<br>1.采用 dfs+回溯的方式, 回溯完之后, 可以不选元素加入且继续路径向前+1 进行 dfs  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; cur, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.<span class="built_in">push_back</span>(nums[pos]);</span><br><span class="line">    <span class="built_in">dfs</span>(pos<span class="number">+1</span>, ans, cur, nums);</span><br><span class="line">    cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="comment">// 在不加入元素的情况下继续 dfs</span></span><br><span class="line">    <span class="built_in">dfs</span>(pos<span class="number">+1</span>, ans, cur, nums);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, ans, cur, nums);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h2><blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>示例 1：输入：digits = “23” 输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p>
<p>示例 2：输入：digits = “” 输出：[]</p>
<p>示例 3：输入：digits = “2” 输出：[“a”,”b”,”c”]</p>
</blockquote>
<p>分析:<br>1.先把所有的从数字到字母的字符串放在一个 map 里面, 然后对数字进行回溯搜索<br>2.回溯的对应关系为  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unrorderd_map&lt;<span class="type">int</span>, <span class="type">char</span>&gt; &#123;</span><br><span class="line">  &#123;<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.采用回溯的思想逐个加入  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;string&gt; ans;</span><br><span class="line">  unordered_map&lt;<span class="type">char</span>, string&gt; num2letter&#123;</span><br><span class="line">    &#123;<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> idx, string&amp; cur, string&amp; target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == target.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string candidates = num2letter[target[idx]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; candidates.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      cur.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">      <span class="built_in">dfs</span>(idx<span class="number">+1</span>, cur, target);</span><br><span class="line">      cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    string cur = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, cur, digits);</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h2><blockquote>
<p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合，并以列表形式返回。你可以按 任意顺序 返回这些组合。<br>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。<br>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
<p>示例 1：输入：candidates = [2,3,6,7], target = 7 输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 = 7 。<br>仅有这两种组合。</p>
<p>示例 2：输入: candidates = [2,3,5], target = 8 输出: [[2,2,2,2],[2,3,3],[3,5]]</p>
<p>示例 3：输入: candidates = [2], target = 1 输出: []</p>
</blockquote>
<p>分析:<br>1.想一下我们的搜索空间是什么, 为了保证不重复不遗漏, 先对元素进行排序, 每次搜索的时候, 要从当前的位置开始搜索, 之前搜过的元素不去搜索, 因此除了维护求和之外, 还得维护一个当前的搜索位置  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> sum, <span class="type">int</span> startIdx, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; cur, vector&lt;<span class="type">int</span>&gt;&amp; candidates)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIdx; i &lt; candidates.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      cur.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">      <span class="built_in">dfs</span>(sum + candidates[i], i, target, cur, candidates);</span><br><span class="line">      cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (candidates.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    <span class="comment">// 必须先排序</span></span><br><span class="line">    <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// dfs 的时候带上搜索的位置, 才能确定候选集合</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, target, cur, candidates);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h2><blockquote>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<p>示例 1：输入：n = 3 输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p>
<p>示例 2：输入：n = 1 输出：[“()”]</p>
</blockquote>
<p>分析:<br>1.我们总共有 n 对括号需要增加, 只需要判定清楚什么情况下括号需要增加, 什么情况下括号不能增加, 搜索的时候采取回溯<br>2.左括号可以任意加入, 只要有就可以加; 右括号在什么情况下是合法的? 左括号数右括号数多的情况下, 可以通过加入右括号, 配置成合法的括号  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;string&gt; ans;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> lCnt, <span class="type">int</span> rCnt, string&amp; cur)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 都填完</span></span><br><span class="line">    <span class="keyword">if</span> (lCnt == <span class="number">0</span> &amp;&amp; rCnt == <span class="number">0</span>) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左括号可以任意加入, 只要有就可以加</span></span><br><span class="line">    <span class="keyword">if</span> (lCnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      cur.<span class="built_in">push_back</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">      <span class="built_in">dfs</span>(lCnt - <span class="number">1</span>, rCnt, cur);</span><br><span class="line">      cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右括号在什么情况下是合法的? 左括号数右括号数多的情况下, 可以通过加入右括号, 配置成合法的括号</span></span><br><span class="line">    <span class="keyword">if</span> (rCnt &gt; lCnt) &#123;</span><br><span class="line">      cur.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">      <span class="built_in">dfs</span>(lCnt, rCnt - <span class="number">1</span>, cur);</span><br><span class="line">      cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    string cur = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(n, n, cur);</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79.单词搜索"></a>79.单词搜索</h2><blockquote>
<p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。<br>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>示例 1：输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED” 输出：true<br>示例 2：输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “SEE” 输出：true<br>示例 3：输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCB” 输出：false  </p>
</blockquote>
<p>分析:<br>1.dfs 回溯搜索, 搜索过的地方标记成 visited<br>2.用分解问题的思维, 当前位置和下个位置的搜索问题是一个问题, 当前位置搜索成功 = 周围四个方向中任意一个搜索成功  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; visited;</span><br><span class="line">  <span class="type">int</span> rows;</span><br><span class="line">  <span class="type">int</span> cols;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> idx, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string&amp; word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == word.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[i][j]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (board[i][j] != word[idx]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">dfs</span>(i + <span class="number">1</span>, j, idx + <span class="number">1</span>, board, word) </span><br><span class="line">           || <span class="built_in">dfs</span>(i - <span class="number">1</span>, j, idx + <span class="number">1</span>, board, word) </span><br><span class="line">           || <span class="built_in">dfs</span>(i, j + <span class="number">1</span>, idx + <span class="number">1</span>, board, word)</span><br><span class="line">           || <span class="built_in">dfs</span>(i, j - <span class="number">1</span>, idx + <span class="number">1</span>, board, word);</span><br><span class="line">    visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">empty</span>() || board[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    rows = board.<span class="built_in">size</span>();</span><br><span class="line">    cols = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    visited = vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;(rows, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(cols, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(i, j, <span class="number">0</span>, board, word)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h2><blockquote>
<p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。回文串 是正着读和反着读都一样的字符串。</p>
<p>示例 1： 输入：s = “aab” 输出：[[“a”,”a”,”b”],[“aa”,”b”]]</p>
<p>示例 2： 输入：s = “a” 输出：[[“a”]]</p>
</blockquote>
<p>分析:<br>1.这道题可以这么想, 比如给的是 aaaa, 可以 a,a,a,a, 可以 aa,a,a, 可以 aa,aa, 可以 aaa,a, 可以 aaaa, 所以每次都要判断以某一个起点为起点的某一段 [startPos, i] 是否是回文的, 如果是那么再后面的区间内尝试继续往后搜索, 然后再回溯到起点搜索, 回溯的点是字符串的某个起点位置<br>2.单独写一个判断区间是回文的函数 isPali(string s, int l, int r)  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isPali</span><span class="params">(string&amp; s, <span class="type">int</span> l, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h &amp;&amp; s[l] == s[h]) &#123;</span><br><span class="line">      ++l;</span><br><span class="line">      --h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l &gt;= h;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> startPos, string&amp; s, vector&lt;string&gt;&amp; cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startPos == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startPos; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="comment">// 如果 [pos, i] 之间是个回文串, 直接截取这个回文串存进去, 然后往后搜索</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isPali</span>(s, startPos, i)) &#123;</span><br><span class="line">        cur.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(startPos, i - startPos + <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 向后搜索到 i + 1 这个位置</span></span><br><span class="line">        <span class="built_in">dfs</span>(i<span class="number">+1</span>, s, cur);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">    vector&lt;string&gt; cur;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, s, cur);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51.N 皇后"></a>51.N 皇后</h2><blockquote>
<p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<br>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。<br>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例 1： 输入：n = 4<br>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]<br>解释：如上图所示，4 皇后问题存在两个不同的解法。</p>
<p>示例 2：输入：n = 1 输出：[[“Q”]]</p>
</blockquote>
<p>分析:<br>1.初始化一个默认的棋盘, 因为根据规则, 每行至多放 1 个皇后, 所以在 dfs 放置的时候, 对 [行] 这个维度进行 dfs(row), 放完了直接进入下一行; dfs(row) 的内部, 对所有的列的位置 (row, col) 进行模拟放置并回溯<br>2.放置的时候, 需要检查放置的位置 [i,j] 是满足合法性的, 因此需要在放置之前先检查放置是合法的, 写一个 checkLegality()<br>3.checkLegality() 需要依次检查面的行之前不能放过, 左上方之前不能放过, 右上方之前不能放过<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">checkLegality</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> n, vector&lt;string&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上面的行之前不能放过</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (board[i][c] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左上方之前不能放过</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = r<span class="number">-1</span>, j = c<span class="number">-1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; --i, --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右上方之前不能放过</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = r<span class="number">-1</span>, j = c<span class="number">+1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; --i, ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> n, vector&lt;string&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(board);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; ++col) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">checkLegality</span>(row, col, n, board)) &#123;</span><br><span class="line">        board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(row<span class="number">+1</span>, n, board);</span><br><span class="line">        board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, n, board);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h2><blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>请必须使用时间复杂度为 O(log n) 的算法。nums 为 无重复元素 的 升序 排列数组.</p>
<p>示例 1: 输入: nums = [1,3,5,6], target = 5 输出: 2 </p>
<p>示例 2: 输入: nums = [1,3,5,6], target = 2 输出: 1</p>
<p>示例 3: 输入: nums = [1,3,5,6], target = 7 输出: 4</p>
</blockquote>
<p>分析:<br>1.搜索左边界的二分搜索  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> h = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; nums[l]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[h]) &#123;</span><br><span class="line">      <span class="keyword">return</span> h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">      <span class="type">int</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">        h = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74.搜索二维矩阵"></a>74.搜索二维矩阵</h2><blockquote>
<p>给你一个满足下述两条属性的 m x n 整数矩阵：每行中的整数从左到右按非严格递增顺序排列。 每行的第一个整数大于前一行的最后一个整数。<br>给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。</p>
<p>示例 1：输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 输出：true</p>
<p>示例 2：输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 输出：false</p>
</blockquote>
<p>分析:<br>1.二分搜索的二维版本, 我们可以用行列关系建立二维和一维之间的映射关系, 然后就能退化到一维的二分搜索了, 假设有 row 行, col 列,<br>2.二维转一维 l = 0, high = row * col - 1<br>3.一维转二维 (i, j) 坐标之间关系为 (i / col , j % col) 这么个关系  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> row = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> h = row * col - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 二维转一维映射 l = 0, h = row * col -1</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">      <span class="type">int</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">      <span class="comment">// 一维转二维映射 m[mid / col][mid % col]</span></span><br><span class="line">      <span class="type">int</span> midNum = matrix[mid / col][mid % col];</span><br><span class="line">      <span class="keyword">if</span> (midNum == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midNum &gt; target) &#123;</span><br><span class="line">        h = mid - <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midNum &lt; target) &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34.在排序数组中查找元素的第一个和最后一个位置"></a>34.在排序数组中查找元素的第一个和最后一个位置</h2><blockquote>
<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。<br>如果数组中不存在目标值 target，返回 [-1, -1]。你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
<p>示例 1：输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4]</p>
<p>示例 2：输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1]</p>
<p>示例 3：输入：nums = [], target = 0 输出：[-1,-1]</p>
</blockquote>
<p>分析:<br>1.写一个找左边边界的二分搜索, 以及另一个找右边边界的二分搜索, 两个函数分开写  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">lBinarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> h = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">      <span class="type">int</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">      <span class="type">int</span> midNum = nums[mid];</span><br><span class="line">      <span class="keyword">if</span> (midNum == target) &#123;</span><br><span class="line">        h = mid - <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midNum &lt; target) &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midNum &gt; target) &#123;</span><br><span class="line">        h = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= nums.<span class="built_in">size</span>() || nums[l] != target) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">rBinarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> h = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">      <span class="type">int</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">      <span class="type">int</span> midNum = nums[mid];</span><br><span class="line">      <span class="keyword">if</span> (midNum == target) &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midNum &lt; target) &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midNum &gt; target) &#123;</span><br><span class="line">        h = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h &lt; <span class="number">0</span> || nums[h] != target) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="built_in">lBinarySearch</span>(nums, target), <span class="built_in">rBinarySearch</span>(nums, target)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h2><blockquote>
<p>整数数组 nums 按升序排列，数组中的值 互不相同。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。<br>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<p>示例 1：输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4</p>
<p>示例 2：输入：nums = [4,5,6,7,0,1,2], target = 3 输出：-1</p>
<p>示例 3：输入：nums = [1], target = 0 输出：-1</p>
</blockquote>
<p>分析:<br>1.旋转数组的特点是: 以旋转点作为界限, 两边的区间仍然保持单调的性质, 比如 [4,5,6,7,0,1,2] 和 [6,7,0,1,2,3,4]; 但是以搜索点作为界限: 左右两边的区间只存在一边必然单调, 一边可能不单调的性质; 在搜索的时候, 我们先判断以 nums[mid] 的一遍是否存在单调性, 比如我们去判断 nums[mid] 的右边是否存在单调性: 判断右边是否存在单调性的依据是最右边的元素是否大于当前元素, 如果是最最右侧的元素是更大的, 说明旋转点不在右边, 右边是单调的; 如果右边存在单调性, 我们再判断在 target 是否在右边的区间里面, 也就是增加判断 target 是介于 nums[mid] 和 nums[r]之间的值, 如果是那么就很方便地进行二分搜索; 如果不存在在右边边界, 那么只要递归地搜索左边的区间, 右边不需要再投入考虑<br>2.旋转数组的二分搜索相对与普通的二分搜索相当于多加了两层判断, 一层判断是当前搜索区间是否单调, 以及再判断当前元素是否再里面<br>3.旋转数组的二分搜索如果进入一个不单调的区间里面搜索, 该子问题的结构和原问题的结构是完全相同的, 继续递归的去搜索一个子数组, 这个数组也是一个旋转数组, 直到两边不再有任何旋转数组  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">      <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">      <span class="type">int</span> midNum = nums[mid];</span><br><span class="line">      <span class="keyword">if</span> (midNum == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断一侧是否是单调的: 例如判断右边如果是单调的</span></span><br><span class="line">      <span class="keyword">if</span> (nums[mid] &lt; nums[r]) &#123;</span><br><span class="line">        <span class="comment">// 判断 target 是否在右边区间</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;</span><br><span class="line">          l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 不在就去左边区间搜索</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 判断另一侧左边的单调性也已知了, 因为旋转数组必然一边单调一边不单调</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 判断 target 是否在左边区间</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target &amp;&amp; target &gt;= nums[l]) &#123;</span><br><span class="line">          r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 不在就去右边区间搜索</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153.寻找旋转排序数组中的最小值"></a>153.寻找旋转排序数组中的最小值</h2><blockquote>
<p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。<br>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。<br>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<p>示例 1：输入：nums = [3,4,5,1,2] 输出：1 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</p>
<p>示例 2：输入：nums = [4,5,6,7,0,1,2] 输出：0 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。</p>
<p>示例 3：输入：nums = [11,13,15,17] 输出：11 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</p>
</blockquote>
<p>分析:<br>1.旋转数组满足中点二分之后, 一边单调, 一边不单调的性质<br>2.我们二分搜一次, 可以找到一边的单调区间, 更新当前的最小值为单调区间的最左侧; 然后再去另一个不单调的区间里面去尝试找更小的元素, 直到两边都是单调的情况, 不断迭代找到整个数组的最小值  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> h = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">      <span class="type">int</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">      <span class="type">int</span> midNum = nums[mid];</span><br><span class="line">      <span class="comment">// 如果左边单调, 最左侧可尝试更新最小元素</span></span><br><span class="line">      <span class="keyword">if</span> (midNum &gt;= nums[l]) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, nums[l]);</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 如果右边单调, midNum可尝试更新最小元素</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, midNum);</span><br><span class="line">        h = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h2><blockquote>
<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 O(log (m+n)) 。</p>
<p>示例 1: 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2</p>
<p>示例 2：输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p>
</blockquote>
<p>分析:<br>1.找两个数组中的中位数: 两个数组中的中位数是怎么定义的 ?<br>(i). 如果两个数组长度 一个奇数一个偶数, 因为奇+偶=奇, 那么就是正好中间这个数<br>(ii). 如果两个数组长度 一个偶数一个偶数, 因为偶+偶=偶, 那么正好就是合并排序后中间这两个数的平均数<br>(iii). 如果两个数组长度 一个奇数一个奇数, 因为奇+奇=偶, 那么正好就是合并排序后中间这两个数的平均数  </p>
<p>2.怎么忽略数组长度为奇数和数组长度为偶数的分类讨论? 总长度是 m + n. 找两个有序数组中的中位数, 相当于找 [两个数组合并且排序后第(m + n + 1) / 2 小的数] 和 [两个数组合并且排序后第 (m + n + 2)/2 小的数] 这2个结果的平均数, 无论总长度 (m + n) 是奇数还是偶数; 注意一个数组中第 k 小的数的下标是 k - 1<br>我们举 3个 例子理解一下<br>[如果总长度奇数] [1, 2, 3] 和 [4, 5, 6, 7]     :(total[4 - 1]+total[4 - 1])/2 = 4<br>[如果总长度偶数] [1, 2, 3] 和 [4, 5, 6]        :(total[3 - 1]+total[4 - 1])/2 = 3.5<br>[如果总长度偶数] [1, 2, 3, 4] 和 [5, 6, 7, 8]  :(total[4 - 1]+total[5 - 1])/2 = 3.5  </p>
<p>3.需要想办法找 [两个数组合并且排序] 中第x小的数<br>具体地，我们每次在两个数组中比较第 k/2 小的数，合并总数中找中位数, 可以通过比较子数组中找 k/2 分位数的数谁大谁小去缩小搜索空间<br>如果数组1的第 k/2 小的数 小于数组2的第 k/2 小的数，则数组1的前 k/2 个数可以舍弃，同时 k 要减去 k/2<br>如果数组2的第 k/2 小的数 小于数组1的第 k/2 小的数，则数组2的前 k/2 个数可以舍弃，同时 k 要减去 k/2<br>通过不断舍弃前 k/2 个数，最终我们可以得到第 k 小数.  </p>
<p>4.我们就可以在O(log(m+n))的时间内查找到中位数  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// getKth 目标找到 nums1 和 nums2 合并排序后的第 k 小的数</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getKth</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums1, vector&lt;<span class="type">int</span>&gt; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len1 = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> len2 = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 保证 nums1 数组长度是较短的一个</span></span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">getKth</span>(nums2, nums1, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 len1 为空, 直接返回 nums2 中第 k 小的数, 下标是 k - 1</span></span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="keyword">return</span> nums2[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是找最小的数, 可以直接比这两个数组中的最小的数, 取二者的最小的</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">min</span>(nums1[<span class="number">0</span>], nums2[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 num1 中 第k/2小的 元素的 index 比 len1 还大, 在 nums1 中至多找到 第 len1 小的数</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">min</span>(len1, k / <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> j = <span class="built_in">min</span>(len2, k / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 比较 num1 的第 k/2 小的数 和 num2 的 k/2 的数的大小</span></span><br><span class="line">    <span class="comment">// 如果 nums1的 k/2 分位数比, nums2 的 k/2 分位数大, nums2 舍弃前一半元素</span></span><br><span class="line">    <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] &gt; nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; tmp = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums<span class="number">2.</span><span class="built_in">begin</span>() + j, nums<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">getKth</span>(nums1, tmp, k - j);</span><br><span class="line">    <span class="comment">// 如果 nums2的 k/2 分位数比, nums1 的 k/2 分位数大, nums1 舍弃前一半元素</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; tmp = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums<span class="number">1.</span><span class="built_in">begin</span>() + i, nums<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">getKth</span>(tmp, nums2, k - i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len1 = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> len2 = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 两个有序数组中的中位数等于</span></span><br><span class="line">    <span class="comment">// median = ((合并数组后 [len1 + len2 + 1] / 2 小的数) +  (合并数组后 [len1 + len2 + 2] / 2 小的数)) / 2</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">getKth</span>(nums1, nums2, (len1 + len2 + <span class="number">1</span>) / <span class="number">2</span>) + <span class="built_in">getKth</span>(nums1, nums2, (len1 + len2 + <span class="number">2</span>) / <span class="number">2</span>)) / <span class="number">2.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2><blockquote>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p>
<p>示例 1：输入：s = “()” 输出：true</p>
<p>示例 2：输入：s = “()[]{}” 输出：true</p>
<p>示例 3：输入：s = “(]” 输出：false</p>
</blockquote>
<p>分析:<br>1.总共有 3 种类型的括号, 合法的括号都是成对的出现的, 举几个合法的例子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(([[]]))</span><br><span class="line">[()]</span><br><span class="line">&#123;&#125;[[(())]]</span><br></pre></td></tr></table></figure></p>
<p>2.再举几个不合法的例子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;[&#125;]</span><br><span class="line">)[&#123;</span><br><span class="line">&#123;&#123;(]]])</span><br></pre></td></tr></table></figure></p>
<p>3.我们发现只要有一个右边的符号找不到和它马上匹配的左边的符号, 这个匹配都是失败的; 所以我们用栈记录最新的左边的符号, 不管是哪类左边符号都往里加入, 如果遇到了右边的符号, 马上找栈顶, 不匹配就是不合法的  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : s) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(c);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">char</span> top = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; top != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; top != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; top != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (stk.<span class="built_in">empty</span>()) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155.最小栈"></a>155.最小栈</h2><blockquote>
<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。<br>实现 MinStack 类:<br>MinStack() 初始化堆栈对象。<br>void push(int val) 将元素val推入堆栈。<br>void pop() 删除堆栈顶部的元素。<br>int top() 获取堆栈顶部的元素。<br>int getMin() 获取堆栈中的最小元素。</p>
<p>示例 1: 输入： [“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”] [[],[-2],[0],[-3],[],[],[],[]]<br>输出：[null,null,null,null,-3,null,0,-2]<br>解释：<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   —&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      —&gt; 返回 0.<br>minStack.getMin();   —&gt; 返回 -2.</p>
</blockquote>
<p>分析:<br>1.设计最小栈的目的, 就是要 O(1) 检索到栈内最小值, 既然要 O(1) 检索到最小值, 因此每次想要 getMin() 操作的时候, 那就不能通过出栈之类的方式去找了, 我们需要在每次执行 push 或 pop 操作之后, 就已经保存好当前的最小值, 然后才能 O(1) 找最小值<br>2.所以这个最小值的动态维护, 一定是和每次 push 和 pop 操作相关的, 操作完之后, 自动就算出来最小值了<br>3.我们想下栈元素的进入是怎么影响最小值的, 一开始进来一个值, 我们维护一个最小值, 当第二个元素入栈的时候, 我们可以比较出一个当前的最小值, 但是这个最小值怎么存储才能保存是第二个刚进入这个状态呢? 假设我们能通过某种方式保存第 x 个元素刚到栈顶时的状态, 那么这个问题就解决了; 换句话说, 我们需要保存每次新元素入栈的时候, 最小值的状态; 如果发生了出栈的话, 我们还保留上一个对应的状态<br>4.这里引入一个和我们的原始的栈相同的栈, 这个栈和原始的栈保持镜像一样的进出关系, 辅助栈的元素值为保存当前状态的最小元素; 辅助栈在首次加入元素的时候, 为了使得辅助栈首次入栈比较过程有效, 辅助栈可以一开始先放入一个 INT_MAX  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 构建辅助栈, 进出操作和原始栈保持一致, 每次存入当前的最小值</span></span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; minStack;</span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">    <span class="comment">// 为了使得辅助栈首次入栈比较过程有效, 辅助栈可以一开始先放入一个INT_MAX</span></span><br><span class="line">    minStack.<span class="built_in">push</span>(INT_MAX);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    s.<span class="built_in">push</span>(val);</span><br><span class="line">    minStack.<span class="built_in">push</span>(<span class="built_in">min</span>(minStack.<span class="built_in">top</span>(), val));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">    minStack.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> minStack.<span class="built_in">top</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394.字符串解码"></a>394.字符串解码</h2><blockquote>
<p>给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<p>示例 1：输入：s = “3[a]2[bc]” 输出：”aaabcbc”</p>
<p>示例 2：输入：s = “3[a2[c]]“ 输出：”accaccacc”</p>
<p>示例 3：输入：s = “2[abc]3[cd]ef” 输出：”abcabccdcdcdef”</p>
<p>示例 4：输入：s = “abc3[cd]xyz” 输出：”abccdcdcdxyz”</p>
</blockquote>
<p>分析:<br>1.这个解码过程中有嵌套, 所以要用栈记忆嵌套的情况; 可以用一个栈存下来上一个字符串是什么; 同时另一个栈记录上一次重复这个字符串的个数<br>2.遍历字符串, 我们梳理一下遇到什么怎么处理, 假设我们当前处理的字符串 叫做 part<br>(i). 遇到数字直接解码并入栈<br>(ii). 遇到字符, 直接向后 concat<br>(iii). 遇到左括号, 之前的字符入栈, 重新初始化 part = “”<br>(iv). 遇到右括号, 同时把上一个数字和上一个字符都拿出来做解析, 按照数字倍数乘以字符串做展开处理; 解析的结果成为 part  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; numStk;</span><br><span class="line">    stack&lt;string&gt; strStk;</span><br><span class="line">    string part = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="comment">// 遇到数字直接解码并入栈数字栈</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">          sum = sum * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">          ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        numStk.<span class="built_in">push</span>(sum);</span><br><span class="line">      <span class="comment">// 遇到左括号对之前的字符串入栈, 并重新初始化 part</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">        strStk.<span class="built_in">push</span>(part);</span><br><span class="line">        part = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        ++i;</span><br><span class="line">      <span class="comment">// 遇到右括号拉出来入栈的字符串和重复数做复制</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">        string parsedStr = strStk.<span class="built_in">top</span>();</span><br><span class="line">        strStk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> num = numStk.<span class="built_in">top</span>();</span><br><span class="line">        numStk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num; ++j) &#123;</span><br><span class="line">          parsedStr += part; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新现有的字符串的结果, 外层可能还继续嵌套</span></span><br><span class="line">        part = parsedStr;</span><br><span class="line">        ++i;</span><br><span class="line">      <span class="comment">// 遇到字符直接累加</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        part += s[i];</span><br><span class="line">        ++i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> part;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h2><blockquote>
<p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>示例 1: 输入: temperatures = [73,74,75,71,69,72,76,73] 输出: [1,1,4,2,1,1,0,0]</p>
<p>示例 2: 输入: temperatures = [30,40,50,60] 输出: [1,1,1,0]</p>
<p>示例 3: 输入: temperatures = [30,60,90] 输出: [1,1,0]</p>
</blockquote>
<p>分析:<br>1.对于每天温度数组来说, 用单调栈找数组中每个元素的右边第 1 个比它大的位置, 返回 target_idx - i  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = temperatures.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(len)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len<span class="number">-1</span>; i &gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt;= temperatures[s.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      ans[i] = (!s.<span class="built_in">empty</span>()) ? s.<span class="built_in">top</span>() - i : <span class="number">0</span>;</span><br><span class="line">      s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84.柱状图中最大的矩形"></a>84.柱状图中最大的矩形</h2><blockquote>
<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p>示例 1: 输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10</p>
</blockquote>
<p>分析:<br>1.找最大矩形是怎么找到的 ？对于 位置 i 来说, 高度为 height[i], 我们用从中间到两边扩展的思想去以 height[i] 为高, 看看最大能拓宽的宽有多宽, 然后用 拓宽到极限的宽 <em> height[i] = 最大的面积<br>2.假设从 i 开始, 向左侧延伸连续 &gt;= heights[i] 到最后一个位置 left, 以及找到 i 位置向右延伸到的最后一个 &gt;= height[i] 的位置 right, 那么最大面积的就是 (right - left + 1) </em> height[i]; 根据这个思路, 有暴力解法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = heights.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> curHeight = heights[i]; </span><br><span class="line">      <span class="type">int</span> left = i;</span><br><span class="line">      <span class="type">int</span> right = i;</span><br><span class="line">      <span class="comment">// 以 height[i] 的高度向左边扩展</span></span><br><span class="line">      <span class="keyword">while</span> (left - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; heights[left - <span class="number">1</span>] &gt;= curHeight) &#123;</span><br><span class="line">        --left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 以 height[i] 的高度向右边扩展</span></span><br><span class="line">      <span class="keyword">while</span> (right + <span class="number">1</span> &lt;= len - <span class="number">1</span> &amp;&amp; heights[right + <span class="number">1</span>] &gt;= curHeight) &#123;</span><br><span class="line">        ++right;</span><br><span class="line">      &#125; </span><br><span class="line">      ans = <span class="built_in">max</span>(ans, curHeight * (right - left + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>2.找延伸最大的过程, 也相当于我们想找到左侧第 1 个 &lt; heights[i] 的位置 left, 以及找到 i 位置右边第 1 个 &lt; height[i] 的位置 right, 那么最大面积的就更新为 (right - left - 1) * height[i]  </p>
<p>3.因此我们可以用单调栈是实现这样的找寻过程, 但是还要处理一下左边右边都可能出现的找不到的情况, 比如 [3,2,1,2,3], 我们找 index = 2 这个位置上的最大面积, 这种情况下应该怎么计算最大面积?  </p>
<p>4.边界条件, 对于第 i 个元素, 左边没有任何比它小的元素的情况下, 我们用 -1 表示这个位置; 对于右侧而言, 用 len 表示找不到这个位置, 这样的话就兼容适配 (right - left - 1) * height[i] 这个最大面积公式  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = heights.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(len)</span></span>;    <span class="comment">// 保存位置 i 左边第 1 个 &lt; height[i] 的位置, 不存在填写 -1</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(len)</span></span>;   <span class="comment">// 保存位置 i 右边第 1 个 &lt; height[i] 的位置, 不存在填写 len</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; heights[stk.<span class="built_in">top</span>()] &gt;= heights[i]) &#123;</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">      &#125; </span><br><span class="line">      left[i] = stk.<span class="built_in">empty</span>() ? <span class="number">-1</span> : stk.<span class="built_in">top</span>();</span><br><span class="line">      stk.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    stk = <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; heights[stk.<span class="built_in">top</span>()] &gt;= heights[i]) &#123;</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">      &#125; </span><br><span class="line">      right[i] = stk.<span class="built_in">empty</span>() ? len : stk.<span class="built_in">top</span>();</span><br><span class="line">      stk.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, heights[i] * (right[i] - left[i] - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h2 id="215-数组中的第K个最大的元素"><a href="#215-数组中的第K个最大的元素" class="headerlink" title="215.数组中的第K个最大的元素"></a>215.数组中的第K个最大的元素</h2><blockquote>
<p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。<br>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<p>示例 1: 输入: [3,2,1,5,6,4], k = 2 输出: 5</p>
<p>示例 2: 输入: [3,2,3,1,2,4,5,5,6], k = 4 输出: 4</p>
</blockquote>
<p>分析:<br>1.原始数组长度为 len, 找第 k 大的元素, 也就是找排序后 index = len-k 位置的元素<br>2.我们对数组采用 partition 算法, 可以实现检索 len - k 位置元素的二分思想, 因为 partition 算法每次可以使得左边一半小于右边一半元素, 然后实现只在一半元素里面搜索<br>3.对我们随机找的第 1 个枢轴, 例如最左侧端点位置, 还原位置为 pos; 然后判断 pos 和 len-k 的关系<br>(i). pos == len - k, 那么就是 pos 元素就是我们要的数<br>(i). pos &lt; len - k, 那么就去以 pos 作为分界点的右侧区间找, l = pos + 1<br>(i). pos &gt; len - k, 那么就去以 pos 作为分界点的左侧区间找, r = pos - 1<br>4.另外我们可以引入 threeWayPartition 的思想, 额外处理一下相同的元素不进入 partition, 时间复杂度搞到线性<br>(i). pos &lt; len - k, l 可以持续向右比较, 如果当前元素和左侧相邻元素相同, 那么 ++l<br>(ii). pos &gt; len - k, r 可以持续向左比较, 如果当前元素和右侧相邻元素相同, 那么 —r  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = nums[l];</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] &gt;= pivot) &#123;</span><br><span class="line">        --r;</span><br><span class="line">      &#125;</span><br><span class="line">      nums[l] = nums[r];</span><br><span class="line">      <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] &lt;= pivot) &#123;</span><br><span class="line">        ++l;</span><br><span class="line">      &#125;</span><br><span class="line">      nums[r] = nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[l] = pivot;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r = len - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    k = len - k;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">      pos = <span class="built_in">partition</span>(l, r, nums);</span><br><span class="line">      <span class="keyword">if</span> (pos == k) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[pos];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; k) &#123;</span><br><span class="line">        l = pos + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; k &amp;&amp; nums[l] == nums[l<span class="number">-1</span>]) &#123;</span><br><span class="line">          ++l;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &gt; k) &#123;</span><br><span class="line">        r = pos - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; k &amp;&amp; nums[r] == nums[r<span class="number">+1</span>]) &#123;</span><br><span class="line">          --r;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h2><blockquote>
<p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p>
<p>示例 1: 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2]</p>
<p>示例 2: 输入: nums = [1], k = 1 输出: [1]</p>
</blockquote>
<p>分析:<br>1.可以用一个 hash 表记录下来每个元素出现的次数<br>2.用一个小顶堆 priority_queue<pair<int, int>&gt; , 然后填充这个小顶堆<br>3.遍历 hash 表, 先保留下来前 k 个元素, 假设 map 元素个数小于 k, 那么前 k 个高频的就是已有的元素; 如果新遍历到的元素的出现次数大于堆顶这个出现次数, 淘汰掉当前小顶, 新的元素进入小顶堆; 实质上是永远淘汰最小的出现次数这种迭代思想, 剩下的就是频率最大的 K 个元素了<br>4.小顶堆的基础元素用 pair<int,int> 进行迭代, first 和 second 分别保存的是 [值] 和 [出现的元素]  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; value2req;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: nums) &#123;</span><br><span class="line">      ++value2req[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [] (<span class="type">const</span> pii a, <span class="type">const</span> pii b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 用小顶堆保存 k 个元素, 按照元素出现次数排序</span></span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, <span class="keyword">decltype</span>(cmp)&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: value2req) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x.first, x.second));</span><br><span class="line">      <span class="comment">// 每次淘汰掉最小的出现次数, 并且保留 k 个元素</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pq.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.second &gt; pq.<span class="built_in">top</span>().second) &#123;</span><br><span class="line">          pq.<span class="built_in">pop</span>();</span><br><span class="line">          pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x.first, x.second));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">      pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295.数据流的中位数"></a>295.数据流的中位数</h2><blockquote>
<p>中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。<br>例如 arr = [2,3,4] 的中位数是 3 。<br>例如 arr = [2,3] 的中位数是 (2 + 3) / 2 = 2.5 。<br>实现 MedianFinder 类:<br>MedianFinder() 初始化 MedianFinder 对象。<br>void addNum(int num) 将数据流中的整数 num 添加到数据结构中。<br>double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。</p>
<p>示例 1： 输入 [“MedianFinder”, “addNum”, “addNum”, “findMedian”, “addNum”, “findMedian”]<br>[[], [1], [2], [], [3], []]<br>输出 [null, null, null, 1.5, null, 2.0]<br>解释<br>MedianFinder medianFinder = new MedianFinder();<br>medianFinder.addNum(1);    // arr = [1]<br>medianFinder.addNum(2);    // arr = [1, 2]<br>medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)<br>medianFinder.addNum(3);    // arr[1, 2, 3]<br>medianFinder.findMedian(); // return 2.0</p>
</blockquote>
<p>分析:<br>1.因为是数据流, 所以要保证添加和删除的动态性, 所以用到 堆 这种结构<br>2.我们用两个堆, 动态地维护大的一半元素和小的一半元素；大于等于中位数的, 称之为 largeHalf, 放入一个小顶堆; 小于中位数的,  smallHalf, 放入大顶堆; 维持大集合元素数量大于等于小集合, 如果大集合元素数量更大, 那么直接返回大集合的堆顶; 否则是两个堆顶求和除以 2<br>3.需要持续保证 largeHalf 里面数量比 smallHalf 多或者相等  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; largeHalf;</span><br><span class="line">  priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; smallHalf;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每次先加入到 largeHalf</span></span><br><span class="line">    largeHalf.<span class="built_in">push</span>(num);</span><br><span class="line">    <span class="comment">// 迁移 largeHalf中的最小的过去 smallHalf</span></span><br><span class="line">    smallHalf.<span class="built_in">push</span>(largeHalf.<span class="built_in">top</span>());</span><br><span class="line">    largeHalf.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="comment">// 动态维护 largeHalf 数量多于或者等于 smallHalf</span></span><br><span class="line">    <span class="keyword">if</span> (largeHalf.<span class="built_in">size</span>() &lt; smallHalf.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      largeHalf.<span class="built_in">push</span>(smallHalf.<span class="built_in">top</span>());</span><br><span class="line">      smallHalf.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (largeHalf.<span class="built_in">size</span>() &gt; smallHalf.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> largeHalf.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (largeHalf.<span class="built_in">top</span>() + smallHalf.<span class="built_in">top</span>()) / <span class="number">2.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h2><blockquote>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p>示例 1：输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p>
<p>示例 2：输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<p>分析:<br>1.因为只选 1 次买入时间和 1 次 卖出时间, 遍历每个买入点, 遍历找到对应的卖出点; 只遍历一次, 同时维护历史最低点和当前最大利润<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="type">int</span> preMin = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : prices) &#123;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, x - preMin);</span><br><span class="line">      preMin = <span class="built_in">min</span>(preMin, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55.跳跃游戏"></a>55.跳跃游戏</h2><blockquote>
<p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</p>
<p>示例 1：输入：nums = [2,3,1,1,4] 输出：true 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</p>
<p>示例 2：输入：nums = [3,2,1,0,4] 输出：false 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</p>
</blockquote>
<p>分析:<br>1.对每个可到达的位置 i, 都能延伸到 i + nums[i] 位置<br>2.实时维护一个最远可到达的位置, 遍历数组, 对于位置 i 如果在现有最远可到达的范围内, 那么我们就能把最远的位置扩展到更远的 x + nums[i] 位置; 最终能否到达最后一个下标, 就是看最终最远可到达的位置有没有 &gt;= len - 1  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> farthestPos = <span class="number">0</span>; <span class="comment">// 维护当前可达的最右位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      <span class="comment">// 如果当前元素是在可到达范围内, 尝试扩展最右位置</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt;= farthestPos) &#123;</span><br><span class="line">        farthestPos = <span class="built_in">max</span>(farthestPos, i + nums[i]) ;</span><br><span class="line">        <span class="keyword">if</span> (farthestPos &gt;= len - <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45.跳跃游戏 II"></a>45.跳跃游戏 II</h2><blockquote>
<p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。<br>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:<br>0 &lt;= j &lt;= nums[i]<br>i + j &lt; n<br>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。</p>
<p>示例 1: 输入: nums = [2,3,1,1,4] 输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p>
<p>示例 2: 输入: nums = [2,3,0,1,4] 输出: 2</p>
</blockquote>
<p>分析:<br>1.要求最小的跳跃步数, 从贪心的思路上看, 我们每次在可跳范围内选择可以使得跳的更远的位置, 拿 case 分析一下<br>数组 [2,3,1,2,4,2,3]<br>idx [0,1,2,3,4,5,6]  </p>
<p>我们在 0 , 可以跳的范围: [3,1]    3 可以跳到更远, 在里面选择可以跳的最远的位置 3, 更新下一次可跳的范围<br>我们在 2 , 可以跳的范围: [1,2,4]  4 可以跳到更远, 在里面选择可以跳的最远的位置 4, 更新下一次可跳的范围<br>我们在 4 , 可以跳的范围: [5,6]    6 可以跳到更远, 在里面选择可以跳的最远的位置 6, 更新下一次可跳的范围  </p>
<p>我们需要维护一个当前可跳跃范围的 curEnd 右边界, 在边界内我们都没真实在跳, 只是遍历元素并更新 farthestPos, 直到走到了这个边界, 我们在边界上选取最大的下一个边界 = farthestPos  </p>
<p>遍历的结果为<br>     farPos=0, targetPos=0, steps=0<br>i=0, farPos=2, targetPos=2, steps=1<br>i=1, farPos=4, targetPos=2, steps=1<br>i=2, farPos=4, targetPos=4, steps=2<br>i=3, farPos=5, targetPos=4, steps=2<br>i=4, farPos=8, targetPos=8, steps=3<br>i=5, farPos=8, targetPos=8, steps=3  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> farthestPos = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> curEnd = <span class="number">0</span>; <span class="comment">// 维护当前可跳跃范围的右边界</span></span><br><span class="line">    <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">      <span class="comment">// 遍历位置 i, 迭代能跳到最远的位置</span></span><br><span class="line">      farthestPos = <span class="built_in">max</span>(farthestPos, i + nums[i]);</span><br><span class="line">      <span class="comment">// 如果 i 走到当前可跳跃范围的边界</span></span><br><span class="line">      <span class="comment">// (i). 更新下一次边界为已探测到能跳的最远的位置</span></span><br><span class="line">      <span class="comment">// (ii). 累计最小跳跃次数, step += 1</span></span><br><span class="line">      <span class="keyword">if</span> (i == curEnd) &#123;</span><br><span class="line">        <span class="comment">// 每次跳跃边界按照最最远的来跳</span></span><br><span class="line">        curEnd = farthestPos;</span><br><span class="line">        ++steps;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763.划分字母区间"></a>763.划分字母区间</h2><blockquote>
<p>给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。返回一个表示每个字符串片段的长度的列表。</p>
<p>示例 1： 输入：s = “ababcbacadefegdehijhklij” 输出：[9,7,8] 解释：划分结果为 “ababcbaca”、”defegde”、”hijhklij” 。每个字母最多出现在一个片段中。<br>像 “ababcbacadefegde”, “hijhklij” 这样的划分是错误的，因为划分的片段数较少。 </p>
<p>示例 2： 输入：s = “eccbbbbdec” 输出：[10]</p>
</blockquote>
<p>分析:<br>1.要让同一个字母只出现在一个片段中, 先遍历保存每个字母最后一次出来的位置<br>2.遍历所有的字符, 每次采用贪心的思路来划分一个一个的区间, 用双指针动态维护一个当前找到的 [start, end] 区间<br>3.扫一遍字符串, 对于每个扫描到字符 c, 从哈希表里面拿到最后一个位置 end_c , 当前片段的结束一定 &gt;= end_c, 所以更新 end = max(end_c, en)<br>4.当访问到 end 时候, 当前片段归结为一个片段 [start, end], 长度为 end - start + 1 并返回, 下一个搜索的起点是 start = end + 1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lastPos</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 记录下来每个字符的出现的最终位置, 也是每个划分区间的右边界的下限</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      lastPos[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">      <span class="comment">// 贪心地更新当前区间的最大长度</span></span><br><span class="line">      end = <span class="built_in">max</span>(end, lastPos[s[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">      <span class="comment">// 如果到了区间末尾点, 截取长度并更新下一个区间起点</span></span><br><span class="line">      <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(end - start + <span class="number">1</span>);</span><br><span class="line">        start = end + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h2><blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>示例 1：输入：n = 2 输出：2<br>解释：有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
<p>示例 2：输入：n = 3 输出：3<br>解释：有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
</blockquote>
<p>分析:<br>1.状态转移: f(x)=f(x−1)+f(x−2) f(1) == 1, f(2) == 2, 递归代码发现超时的; 所以需要以某种迭代的方式实现一下这个操作<br>2.引入滚动数组的思想, 我们发现当前最新的状态是每个状态都是前两个状态的相加<br>0,0,1,1,2,3,5,8,11, 每次都把第1个移除掉, 然后后2个相加得到第3个  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> q = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      p = q;</span><br><span class="line">      q = r;</span><br><span class="line">      r = p + q; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118.杨辉三角"></a>118.杨辉三角</h2><blockquote>
<p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。<br>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p>示例 1: 输入: numRows = 5 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</p>
<p>示例 2: 输入: numRows = 1 输出: [[1]]</p>
</blockquote>
<p>分析:<br>1.直接按照公式写  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(numRows, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">      ans[i].<span class="built_in">resize</span>(i + <span class="number">1</span>);</span><br><span class="line">      ans[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      ans[i][i] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">        ans[i][j] = ans[i - <span class="number">1</span>][j - <span class="number">1</span>] + ans[i - <span class="number">1</span>][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h2><blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>示例 1：输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p>示例 2：输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p>
</blockquote>
<p>分析:<br>1.对于单个房屋 i 来说, 偷到的最高金额是什么 ? 对于第 i 间房子来说, 可以选择偷第 i 间房子, 或者不偷第 i 间房子; 当前的房屋 i 的最大金额和 前面的某一个房屋 j 之间是否存在重叠子结构 ? 存在, 因为当前的状态可以从前面的状态中转移过来, 所以考虑用动态规划来找最高金额<br>2.定义 dp[i] 为从 0..i 间房子偷到的最大金额, 对于第 i 天 的最大金额, 可以从 2 种情况转移过来, 如果不偷, 就是 dp[i] = dp[i - 1]; 如果偷, 就是 dp[i] = dp[i - 2] + nums[i]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = <span class="built_in">max</span>(</span><br><span class="line">  dp[i<span class="number">-2</span>] + nums[i], <span class="comment">// 第 i 天偷</span></span><br><span class="line">  dp[i<span class="number">-1</span>]            <span class="comment">// 第 i 天不偷</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>3.base 条件是什么? dp[0] 是第1天的情况下最大金额默认是按照偷算, dp[1] 是第2天的情况下最大金额只有 2 种情况, 第 1 天偷或者第 2 天偷; 后续的天数都可以用上面的状态转移得来  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(len)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      <span class="comment">// 状态转移: 当天不偷, 或者当天偷</span></span><br><span class="line">      dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h2><blockquote>
<p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p>示例 1：输入：n = 12 输出：3 解释：12 = 4 + 4 + 4</p>
<p>示例 2：输入：n = 13 输出：2 解释：13 = 4 + 9</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>, n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历和空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="comment">// 遍历 算数平方根空间</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j*j &lt;= i; ++j) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">min</span>(dp[i], dp[i - j*j] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h2><blockquote>
<p>给你一个整数数组 coins，表示不同面额的硬币；以及一个整数 amount，表示总金额。计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。</p>
<p>示例 1：输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1</p>
<p>示例 2：输入：coins = [2], amount = 3 输出：-1</p>
<p>示例 3：输入：coins = [1], amount = 0 输出：0</p>
</blockquote>
<p>分析:<br>1.凑整总金额问题下的最少硬币个数存在重叠子结构, 因此考虑动态规划; 硬币的数量是无限的, 因此可以理解为是完全背包问题, 我们用 dp[i] 表示凑成金额 i 下的最小硬币个数<br>2.金额为 i 的情况下的最小硬币个数是怎么来的 ?  dp[i] 的状态转移为 dp[i - coins[j]] + 1 转移过来<br>3.base case: dp[0] 表示 凑成金额 i 最小总硬币个数 = 0, 因此 dp[0] = 0  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount<span class="number">+1</span>, amount<span class="number">+1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历硬币</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      <span class="comment">// 遍历金额</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; ++j) &#123;</span><br><span class="line">        dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == amount<span class="number">+1</span> ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以外层遍历金额, 内层遍历硬币</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount<span class="number">+1</span>, amount<span class="number">+1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历金额</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">      <span class="comment">// 遍历硬币</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="comment">// 如果当前硬币满足金额要求</span></span><br><span class="line">        <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">          dp[i] = <span class="built_in">min</span>(dp[i], dp[i-coins[j]] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == amount + <span class="number">1</span> ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h2><blockquote>
<p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。<br>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p>示例 1：输入: s = “leetcode”, wordDict = [“leet”, “code”] 输出: true 解释: 返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。</p>
<p>示例 2： 输入: s = “applepenapple”, wordDict = [“apple”, “pen”] 输出: true 解释: 返回 true 因为 “applepenapple” 可以由 “apple” “pen” “apple” 拼接成。注意，你可以重复使用字典中的单词。</p>
<p>示例 3： 输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”] 输出: false</p>
</blockquote>
<p>分析:<br>1.用 dfs 回溯搜索, 每次匹配往后搜索, 直到达到目标长度为止; 中间任何无法匹配的情况, 都回溯搜索<br>2.单词拆分有没有重叠子结构 ? 有, 单词拆分任务的重叠子结构在于如果一个单词我们扫描到一个位置 i, 如果 i 之前的是满足单词拆分的, 那么只要往后推一个单词如果能匹配, 就能每次往后推单词个长度; 比如 leetcode 这个, 如果到 t 前面的是满足单词拆分的, 我们从 c 开始继续匹配<br>3.上面的是思路, 具体要怎么定义状态和状态转移和怎么匹配 ? dp[i] 表示单词前 i 个字符串 s[0..i-1] 是否满足单词拆分, 状态转移是什么 ? 对于每个位置 i 来说, 我们枚举从 [0, i) 之间的切分点 j, 如果 dp[j] 是满足条件的, 且 s[j+1, i-1] 字符串也在字典中, 那么状态就能发生转移, 写成式子就是:<br>dp[i] = dp[j] &amp;&amp; check(j+1..i), 其中 check(j+1..i) 表示检查 s[j+1, i-1] 是否在字典中, 检查字典中可以通过预先建立 set;<br>4.base 条件 dp[0] 表示空字符串能否被拆分, dp[0] = true<br>5.以样例 “leetcode” 为例, 得到的 状态转移结果为 // 1 0 0 0 1 0 0 0 1  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;string&gt; wordSet;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : wordDict) &#123;</span><br><span class="line">      wordSet.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(len<span class="number">+1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">      <span class="comment">// 枚举切分点, 如果前一段可以被拆分, 且后一段是在词典里面, 那么状态可以转移</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">        <span class="comment">// 也就是 dp[i] 可以切分</span></span><br><span class="line">        <span class="keyword">if</span> (dp[j] &amp;&amp; wordSet.<span class="built_in">find</span>(s.<span class="built_in">substr</span>(j, i - j)) != wordSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">          dp[i] = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h2><blockquote>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>示例 1：输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p>
<p>示例 2：输入：nums = [0,1,0,3,2,3] 输出：4</p>
<p>示例 3：输入：nums = [7,7,7,7,7,7,7] 输出：1</p>
</blockquote>
<p>分析:<br>1.因为我们是找递增的的关系, 子序列的递增的关系存在重叠子结构, 所以考虑动态规划; nums[i] 表示为以 i 为结尾的子序列的长度 dp[i]<br>2.对于 i 前面的任意一个 j, 如果能边际递增 nums[i] &gt; nums[j] 那么 dp[i] = dp[j] + 1; 否则, 不能边际递增 dp[i] = dp[i]  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(len, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">          dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">          ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152.乘积最大子数组"></a>152.乘积最大子数组</h2><blockquote>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。<br>测试用例的答案是一个 32-位 整数。 子数组 是数组的连续子序列。</p>
<p>示例 1: 输入: nums = [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。</p>
<p>示例 2: 输入: nums = [-2,0,-1] 输出: 0 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p>
</blockquote>
<p>分析:<br>1.这个题有没有重叠子结构? 当前位置以 i 为结尾的最大乘积, 和 前面的 j 为结尾的最大乘积有没有重叠关系?<br>2.乍一看很难分析清楚, 我们找点例子看看<br>nums[0..j] = 3  nums[i] = 5   最大是 nums[i] 和 前面最大乘起来<br>nums[0..j] = -3 nums[i] = 5   最大 nums[i]<br>nums[0..j] = 3  nums[i] = -5  最大是 nums[0..j]<br>nums[0..j] = -3 nums[i] = -5  最大是 nums[i] 和 前面最小乘起来<br>看起来有点复杂, 造成这个复杂性的原因是找多个元素的乘法操作结果的最大需要兼顾到各种正负号; 拆开来说就是要兼顾: 前面乘积的正负号, 和当前元素正负号; 所以如果我们想状态转移, 不是单一公式的转移<br>3.这个正确的转移方式是, 维护以 i 为结尾的乘积最大 maxF[i], 再同时维护以 i 为结尾的乘积最小 minF[i]; 因此需要 2 个数组进行状态转移<br>maxF[i] = max(maxF[i-1] <em> nums[i], nums[i], minF[i-1] </em> nums[i]) 多种方式综合取最大, 才是真正的最大<br>minF[i] = min(minF[i-1] <em> nums[i], nums[i], maxF[i-1] </em> nums[i]) 多种方式综合取最小, 才是真正的最小<br>最后整个数组的最大就是去取 maxF[i] 中最大的<br>4.一开始的时候, maxF[i] 和 minF[i] 都可以用 nums[i] 初始化  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxF</span><span class="params">(nums)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minF</span><span class="params">(nums)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      maxF[i] = <span class="built_in">max</span>(<span class="built_in">max</span>(maxF[i - <span class="number">1</span>] * nums[i], nums[i]), minF[i - <span class="number">1</span>] * nums[i]);</span><br><span class="line">      minF[i] = <span class="built_in">min</span>(<span class="built_in">min</span>(maxF[i - <span class="number">1</span>] * nums[i], nums[i]), maxF[i - <span class="number">1</span>] * nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">max_element</span>(maxF.<span class="built_in">begin</span>(), maxF.<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416.分割等和子集"></a>416.分割等和子集</h2><blockquote>
<p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>示例 1：输入：nums = [1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p>
<p>示例 2：输入：nums = [1,2,3,5] 输出：false 解释：数组不能分割成两个元素和相等的子集。</p>
</blockquote>
<p>分析:<br>1.子集划分的存在性, 本质上是组合的存在性; 组合的存在性, 其实是满足某个约束条件下的背包问题; 我们回顾背包问题, 背包问题是给定的物品和重量下找最大的价值的一种组合, 这个问题是找一种划分，其实也就是找一种组合正好满足组合之和等于 sum/2: 也就是给定一个重量为 sum/2 的背包, 以及N个物品, 每个物品的重量为 nums[i], 问是否存在一种装背包的装法, 使得恰好把背包装满了  </p>
<p>2.还原出来背包问题的本质, 那么我们就可也用 0-1 背包来解问题了, 我们对状态的存在性进行状态描述, 因此用一个 bool 类型的变量<br>(i). dp[i][j] = true 表示用前 i 个元素进行组合, 存在一个组合使得前 i 个元素之和恰好为 j, 注意用前 i 个元素组合隐含一种可能性是什么都不用的情况<br>(ii) dp[i][j] = false 表示用前 i 个元素进行选择组合, 不存在一个组合使得前 i 个元素之和恰好为 j  </p>
<p>我们想要最终的结果就是 dp[i][sum/2] 的结果  </p>
<p>3.base case 这里需要想一下, dp[i][0] = ? dp[0][i] = ?<br>(i). 对于前一种情况, 相当于用前 i 个元素进行组合, 存在一个组合使得前 i 个元素之和恰好为 0, 因为可以不选择任何元素, 所以都是这种可能性都存在的, 因此 dp[i][0] = true<br>(ii). 对于后一种情况, 相当于用前 0 个元素进行组合, 存在一个组合使得前 0 个元素之和恰好为 i, 这可能性都不存在, 因此 dp[0][i] = false  </p>
<p>4.除了上述的条件, 我们对一些特殊情况进行特殊处理, 先判断掉不可能的结果, 再去做背包状态转移<br>(i). 元素个数为1, 不存在划分<br>(ii). 所有元素总和为奇数, 不存在划分  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 长度 &lt;= 1 不可分割</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 元素总和为奇数 不可分割</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: nums) &#123;</span><br><span class="line">      sum += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum /= <span class="number">2</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(len<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(sum<span class="number">+1</span>, <span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// base条件: 用前 i 个元素进行组合, 存在一个组合使得前 i 个元素之和恰好为 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= sum<span class="number">+1</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i<span class="number">-1</span>] &gt; j) &#123;</span><br><span class="line">          dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len][sum];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将二维的背包转化成一维的背包, 在背包问题中是 dp[j] 表示容量为 j 的时候的最大价值, 在本题里面表示求和为 j 的时候的是否存在组合, 核心的状态转移为  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = dp[j] || dp[j-nums[i<span class="number">-1</span>]]</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 长度 &lt;= 1 不可分割</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 元素总和为奇数 不可分割</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: nums) &#123;</span><br><span class="line">      sum += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum /= <span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(sum<span class="number">+1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 遍历元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      <span class="comment">// 倒序遍历和</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = sum; j &gt;= i; --j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= j) &#123;</span><br><span class="line">          dp[j] = dp[j] || dp[j - nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[sum];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32.最长有效括号"></a>32.最长有效括号</h2><blockquote>
<p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<p>示例 1：输入：s = “(()” 输出：2 解释：最长有效括号子串是 “()”</p>
<p>示例 2：输入：s = “)()())” 输出：4 解释：最长有效括号子串是 “()()”</p>
<p>示例 3: 输入：s = “” 输出：0</p>
</blockquote>
<p>分析:<br>1.看到括号想到用栈去模拟, 我们始终维护栈底部的元素是最后一个没法匹配的右括号的下标; 我们遍历字符串, 如果遇到左括号, 入栈; 遇到右括号, 执行出栈模拟了匹配一次的过程, 然后搞结算, (在这种栈非空的条件下) 用当前的下标减去栈顶的下标, 得到合法匹配长度; 如果遇到右括号并弹出之后, 栈里面已经空了, 那么就是没法匹配了, 我们再都要放入最后一个无法匹配的右括号, 维持栈底始终存在最后一个没法匹配的右括号<br>2.在这种做法中, 我们始终维护栈底部的元素是最后一个没法匹配的右括号的下标, 这样才能满足当前右括号-栈顶是 以当前右括号为结尾的最大有效长度<br>3.一开始栈是空的, 第一个字符如果是左括号, 就没法使得栈底是最后一个没有匹配的右括号 (下标) 这种情况, 为了特殊处理这种情况, 一开始栈里面先进入一个 -1; 表示有一个没法匹配的右括号, 下标是-1; 补充完这样操作后和上面的思路在执行过程中可以保证完全统一  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="comment">// 为了保证字符串第 1 个元素是左括号的时候, 保证栈底还是一个无法匹配的右括号, 强行先送入一个-1</span></span><br><span class="line">    <span class="comment">// 意思是模拟 栈底位置上已经有一个无法匹配的右括号了</span></span><br><span class="line">    stk.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 在栈非空的情况下, 做一次最大长度的结算</span></span><br><span class="line">        <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">          ans = <span class="built_in">max</span>(ans, i - stk.<span class="built_in">top</span>());</span><br><span class="line">        <span class="comment">// 一旦出现栈空的情况, 都要放入最后一个无法匹配的右括号, 保证栈底部始终有一个无法匹配的右括号</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="多维动态规划"><a href="#多维动态规划" class="headerlink" title="多维动态规划"></a>多维动态规划</h2><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h2><blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？</p>
<p>示例 1：输入：m = 3, n = 7 输出：28  </p>
<p>示例 2：输入：m = 3, n = 2 输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向下</li>
</ol>
<p>示例 3：输入：m = 7, n = 3 输出：28</p>
<p>示例 4：输入：m = 3, n = 3 输出：6</p>
</blockquote>
<p>分析:<br>1.每次只能向下或者向右走一步, 对于矩阵最左边和最上边直接种类就是1, 对于中间的元素<br>2.因为有重叠子结构, 用 dp[i][j] 表示从起点到 [i, j] 可到的最大总数; base条件 dp[i][0] = 1 和 dp[0][j] = 1, 因为只能从[上面到下面] 和 [左边到右边]<br>3.对于其他的位置 dp[i][j] = dp[i-1][j] + dp[i][j-1]  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64.最小路径和"></a>64.最小路径和</h2><blockquote>
<p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。</p>
<p>示例 1：输入：grid = [[1,3,1],[1,5,1],[4,2,1]] 输出：7 解释：因为路径 1→3→1→1→1 的总和最小。</p>
<p>示例 2：输入：grid = [[1,2,3],[4,5,6]] 输出：12</p>
</blockquote>
<p>分析:<br>1.到某个位置 [i,j] 存在最小路径重叠子问题, 定义 dp[i][j] 为到达 grid[i][j] 的最小路径和<br>2.dp[i][j] 可能从 2 类状态中转移过来, dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]<br>3.base 条件处理最左边和最上边<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> row = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(grid);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; row; ++i) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; col; ++i) &#123;</span><br><span class="line">      dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; row; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; col; ++j) &#123;</span><br><span class="line">        dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[row<span class="number">-1</span>][col<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h2><blockquote>
<p>给你一个字符串 s，找到 s 中最长的回文子串。 如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
<p>示例 1： 输入：s = “babad” 输出：”bab” 解释：”aba” 同样是符合题意的答案。</p>
<p>示例 2： 输入：s = “cbbd” 输出：”bb”</p>
</blockquote>
<p>分析:<br>1.以字符串中的某个 i 为中点, 向两边扩展回文字符串找到最长长度, 然后枚举这样的中点找到最长的子串长度<br>2.扩展有两种形式, 一种是以 i 作为长度数奇串中心, 一种是以 i, 和 i + 1 作为长度偶数中心<br>3.写 expand() 这个函数, 可以写成兼容奇数和偶数长度两种形式, 用起止点做中心向两边扩散  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">pii <span class="title">expand</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> h, string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// aba</span></span><br><span class="line">    <span class="comment">// abba</span></span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; h &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[h]) &#123;</span><br><span class="line">      --l;</span><br><span class="line">      ++h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;l<span class="number">+1</span>, h<span class="number">-1</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">string <span class="title">getStr</span><span class="params">(pii a, string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">substr</span>(a.first, a.second - a.first + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      pii odd = <span class="built_in">expand</span>(i, i, s);</span><br><span class="line">      pii even = <span class="built_in">expand</span>(i, i<span class="number">+1</span>, s);</span><br><span class="line">      string s1 = <span class="built_in">getStr</span>(odd, s);</span><br><span class="line">      string s2 = <span class="built_in">getStr</span>(even, s);</span><br><span class="line">      ans = (ans.<span class="built_in">size</span>() &gt; s<span class="number">1.</span><span class="built_in">size</span>()) ? ans : s1;</span><br><span class="line">      ans = (ans.<span class="built_in">size</span>() &gt; s<span class="number">2.</span><span class="built_in">size</span>()) ? ans : s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a>1143.最长公共子序列</h2><blockquote>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<p>示例 1：输入：text1 = “abcde”, text2 = “ace” 输出：3   解释：最长公共子序列是 “ace” ，它的长度为 3 。</p>
<p>示例 2：输入：text1 = “abc”, text2 = “abc” 输出：3 解释：最长公共子序列是 “abc” ，它的长度为 3 。</p>
<p>示例 3：输入：text1 = “abc”, text2 = “def” 输出：0 解释：两个字符串没有公共子序列，返回 0 。</p>
</blockquote>
<p>分析:<br>1.dp[i][j] 表示 到 text[i] 和 text[j] 之间的最长公共子序列, 状态转移为<br>if (text[i] == text[j]) {<br>  dp[i][j] = dp[i-1][j-1] + 1;<br>}<br>2.否则的话, dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len1 = text<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> len2 = text<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len1<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len2<span class="number">+1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">          dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72.编辑距离"></a>72.编辑距离</h2><blockquote>
<p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数。你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<p>示例 1：输入：word1 = “horse”, word2 = “ros” 输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p>
<p>示例 2：输入：word1 = “intention”, word2 = “execution” 输出：5<br>解释：<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p>
</blockquote>
<p>分析:<br>1.编辑距离的计算方式之间有重叠的结构, 我们考虑动态规划<br>2.令 dp[i][j] 表示 word1[0..i-1] 和 word2[0..j-1] 的编辑距离<br>3.想一想边际的情况<br>比较当前的字符 word[i-1] 和 word[j-1] 如果二者相同, 单词的编辑距离和这两个单词中的这两个相同的字符没关系, 多一个相同字符或者少一个相同的字符不影响编辑距离, 那么状态转移 dp[i][j] = dp[i-1][j-1]  </p>
<p>比较当前的字符 word[i-1] 和 word[j-1] 如果二者不相同, 那么想一下可以怎么通过三种方式进行变换, 以及状态转移是什么? 最终的状态转移就是求这三个的最小值; 分析状态转移在这里就是分析这个比较可以由什么操作算过来  </p>
<p>(i).对于删除操作来说, dp[i][j], 可以 word1 删除或者 word2 删除一个字符实现, 比如我们比较如下的<br>s1:applec<br>s2:apple<br>当前 word1[i-1] 是第 c, 当前 word2[j-1] 是 e, 我们可以删除 s1 里面的 c , 然后指针向左比较的是 dp[i-1][j]<br>dp[i][j] = dp[i-1][j] + 1  </p>
<p>(ii).对于增加操作来说, dp[i][j], 可以 word1 增加或者 word2 增加一个字符实现<br>s1:appl<br>s2:apple<br>当前 word1[i-1] 是 e, 当前 word2[j-1] 是 l, 我们可以增加 s2 的 e, 然后 word2 指针向左比较的是 dp[i][j-1]<br>dp[i][j] = dp[i][j-1] + 1  </p>
<p>(iii).对于替换来说, 直接将当前字符 word1[i-1] 替换为 word[j-1], 那么可以对 i 和 j 都往前移动一个再比较, 比如如下的例子<br>s1:appc<br>s2:appl  </p>
<p>把我们比较的是 s1 的 c 和 s2 的 l, 可以把 s1 的 c 替换成 l, 那么 dp[i][j] = dp[i-1][j-1] + 1  </p>
<p>4.边界条件 dp[0][j] = j; dp[i][0] = i; 表示一个字符串和另一个空字符串的编辑距离是字符串的长度  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len1 = word<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> len2 = word<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> len2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len2 == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> len1;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len1<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len2<span class="number">+1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 边界条件 单词延伸到第 i 个字符和空字符之间编辑距离 i </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len1; ++i) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len2; ++i) &#123;</span><br><span class="line">      dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">          <span class="comment">// 当前字符相等, 不影响编辑距离</span></span><br><span class="line">          dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 当前字符不等, 有3种情况取3者最小值</span></span><br><span class="line">          dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j]<span class="number">+1</span>, dp[i][j<span class="number">-1</span>]<span class="number">+1</span>), dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.只出现一次的数字</h2><blockquote>
<p>给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p>
<p>示例 1 ：输入：nums = [2,2,1] 输出：1 </p>
<p>示例 2 ：输入：nums = [4,1,2,1,2] 输出：4</p>
<p>示例 3 ：输入：nums = [1] 输出：1</p>
</blockquote>
<p>分析:<br>1.把数字通通想成二进制数来思考问题, 不要思考任何十进制的数字<br>2.一个数字和另一个数字异或一次, 得到的是和原数字不同的位的标记, 然后再重复一次, 就会全部还原回来; 直觉上可以这么理解, 和我相反的相反, 那不就是我吗?<br>3.比如 1,2,2, 二进制结果为 01 ^ 10 = 11 然后 11 ^ 10 = 01 异或1个同样的数字两次, 相当于还原回来<br>4.因为数组里面设定很特殊, 除了一个数字单独以外, 其他的都是成对出现, 因此对所有数组过一遍异或, 剩下的就是只出现一次的数字  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n : nums) &#123;</span><br><span class="line">      ans ^= n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h2><blockquote>
<p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>示例 1：输入：nums = [3,2,3] 输出：3  </p>
<p>示例 2：输入：nums = [2,2,1,1,1,2,2] 输出：2  </p>
</blockquote>
<p>分析:<br>1.多数元素一定是出现次数最多的那个元素, 扫一遍记录每个元素出现的次数, 扫的时候维护出现次数最大的那个元素  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; num2cnt;</span><br><span class="line">    <span class="type">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> maxCnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums) &#123;</span><br><span class="line">      num2cnt[x] += <span class="number">1</span>; </span><br><span class="line">      <span class="keyword">if</span> (num2cnt[x] &gt; maxCnt) &#123;</span><br><span class="line">        ans = x;</span><br><span class="line">        maxCnt = num2cnt[x];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75.颜色分类"></a>75.颜色分类</h2><blockquote>
<p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>
<p>示例 1：输入：nums = [2,0,2,1,1,0] 输出：[0,0,1,1,2,2]</p>
<p>示例 2：输入：nums = [2,0,1] 输出：[0,1,2]</p>
</blockquote>
<p>分析:<br>1.该问题为经典的 [荷兰国旗问题], 不使用排序去做<br>2.最基础的想法是计数排序, 扫一遍统计出0/1/2的个数, 然后再扫一遍按照元素数量去覆盖数组  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len0 = <span class="number">0</span>;      </span><br><span class="line">    <span class="type">int</span> len1 = <span class="number">0</span>;      </span><br><span class="line">    <span class="type">int</span> len2 = <span class="number">0</span>;      </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        ++len0;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">        ++len1;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (x == <span class="number">2</span>) &#123;</span><br><span class="line">        ++len2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; len0) &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; len0 + len1) &#123;</span><br><span class="line">        nums[i] = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nums[i] = <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.利用三向切分 partition 的思想去进行交换, 在三向切分 Partition里面是维护两个指针分别指向 &lt; target 的位置和 &gt; target 的位置, 在荷兰国旗问题里面类似是指向 &lt; 1 和 &gt; 1 的位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> p0 = <span class="number">0</span>;       <span class="comment">// 指向0的做开区间, 最终指向1的左端点</span></span><br><span class="line">    <span class="type">int</span> p2 = len<span class="number">-1</span>;   <span class="comment">// 指向2的左开区间, 最终指向1的右端点</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= p2) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i++], nums[p0++]);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[p2--]);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更优雅的版本: 一次扫描, 且用覆盖来代替交换<br>维护 p0 写入和 p1 写入点两个指针, 扫描数组, 对于 nums[i] 来说, 不管是几先暂定是2, 这个 2 后续会因为 p0 和 p1 可能发生的写入而覆盖掉, 然后根据值 num 再决定 p0 和 p1 的相应写入和移动过程<br>(i) num == 0 或者 num == 1 的情况下, p1 指针写入并移动<br>(ii). num == 0 的情况下 p0 指针写入并移动  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p0 = <span class="number">0</span>; <span class="comment">// p0 指向 0 的写入点</span></span><br><span class="line">    <span class="type">int</span> p1 = <span class="number">0</span>; <span class="comment">// p1 指向 1 的写入点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="type">int</span> num = nums[i];</span><br><span class="line">      <span class="comment">// 不管是几先暂定写入2</span></span><br><span class="line">      nums[i] = <span class="number">2</span>;</span><br><span class="line">      <span class="comment">// 如果 num &lt; 2的情况下, p1指针写入并移动</span></span><br><span class="line">      <span class="keyword">if</span> (num &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        nums[p1++] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果 num == 0 的情况下, p0指针写入并移动</span></span><br><span class="line">      <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">        nums[p0++] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31.下一个排列"></a>31.下一个排列</h2><blockquote>
<p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。<br>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。<br>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。<br>必须 原地 修改，只允许使用额外常数空间。</p>
<p>示例 1：输入：nums = [1,2,3] 输出：[1,3,2]</p>
<p>示例 2：输入：nums = [3,2,1] 输出：[1,2,3]</p>
<p>示例 3：输入：nums = [1,1,5] 输出：[1,5,1]</p>
</blockquote>
<p>分析:<br>1.先想想怎么生成一个排列的? 对于 [1,3,2] 来说, 遵循一下几个步骤<br>(i).从后往前遍历, 找到第 1 个前面元素小于后面的元素, 假设这个元素 index = i ; 如果这个元素不存在, 那么数组天然逆序的, 直接返回1个排列; 比如找到 1 这个元素<br>(ii). 从后往前遍历, 找到第 1 个比 i 位置更大的元素位置 j, 这个就是发逆转的点, 比如找到 2<br>(iii). 交换 i 和 j 元素得到 [2,3,1]<br>(iv). 逆转 i 位置字后的全部元素<br>2.再举个例子 2341, 它的下一个是 2413<br>找到元素3, 找到元素4, 换完就是 2431; 然后再逆转原来3位置的后面的元素, 得到 2413<br>3.为啥这么做是合法的, 我们其实一开始是找的是最小的改动点, 然后后面那个找的比最小的改动点最大的是产生最小的改动点下一个的最近的位置; 交换之后, 改动已经完成了, 但是后面的变成最大的了; 再逆转一次改动点之后的数字, 使得改动的幅度变成最小  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从后往前 找到第1个前一个元素小于一个元素的位置</span></span><br><span class="line">    <span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &lt; nums[i<span class="number">+1</span>]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      --i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果整个数组是倒序的</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 直接逆转数组 比如 321 下一个排列是 123</span></span><br><span class="line">      <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从后往前找到第一个大于i的数字, 这个就是逆转点</span></span><br><span class="line">    <span class="comment">// 比如 132</span></span><br><span class="line">    <span class="type">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j] &gt; nums[i]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      --j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逆转完 231</span></span><br><span class="line">    <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    <span class="comment">// 逆转一下后面的全部 213</span></span><br><span class="line">    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287.寻找重复数"></a>287.寻找重复数</h2><blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。<br>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p>
<p>示例 1：输入：nums = [1,3,4,2,2] 输出：2 </p>
<p>示例 2：输入：nums = [3,1,3,4,2] 输出：3</p>
</blockquote>
<p>分析:<br>1.可以用类似计数排序的思路, 用 cnt[i] 统计小于等于 i 的数字有多少个, 假设我们要找的重复的数字是 target, 那么 [1, target] 这部分数字里面所有的数都满足 cnt[i] &lt;= i, 后半段数字 [target, n] 里面所有的数字都满足 cnt[i] &gt; i; 直觉上理解, 在不重复的区间里面, 累计计数的结果不可能超过数字累计的结果; 但因为重复元素的存在, 可以让累计计数的结果反超当前的数字值 i; 举个例子:<br>nums    1    2    3    4<br>cnt      1    3    4    5<br>2.cnt[i] 随着 i 增大 cnt[i] 是单调的, 所以我们用二分查找  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> h = len;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h)  &#123;</span><br><span class="line">      <span class="type">int</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">      <span class="comment">// 求出来 mid 之前的计数结果</span></span><br><span class="line">      <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= mid) &#123;</span><br><span class="line">          ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// mid &gt;= cnt 说明重复数在左半边区间</span></span><br><span class="line">      <span class="keyword">if</span> (cnt &lt;= mid) &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 重复数如果在右半边区间</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt &gt; mid) &#123;</span><br><span class="line">        h = mid - <span class="number">1</span>;</span><br><span class="line">        ans = mid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源, from goldandrabbit.github.io </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">💰</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2018-2024
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="Toggle full screen shortcut key s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>Help us with donation</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">alipay</label></span><span><label><input type="radio" name="pay" value="weixin">weixin</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 602px;
    }
    .nav.fullscreen {
        margin-left: -602px;
    }
    .nav-left {
        width: 180px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 552px;
        }
        .nav.fullscreen {
            margin-left: -552px;
        }
        .nav-left {
            width: 160px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 552px;
            margin-left: -552px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #000000;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #87CEFA;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #ffffff;
    }
    
    
    .nav-right nav a.hover > span{
        color: #DC143C !important;
    }
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
    #post .pjax article :not(pre) > code {
        color: #24292e;
        font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
        background-color: rgba(27,31,35,.05);
        border-radius: 3px;
        font-size: 85%;
        margin: 0;
        padding: .2em .4em;
    }
    
</style>







</html>

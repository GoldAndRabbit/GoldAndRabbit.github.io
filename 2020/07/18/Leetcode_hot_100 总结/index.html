<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <title>Leetcode_hot_100 总结 | G&amp;R Blog</title>
  <meta name="keywords" content="">
  <meta name="description" content="Leetcode_hot_100 总结 | G&amp;R Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="Linux Access the Open Internet1.Hiddify-Linux下载 Hiddify-Linux-x64.AppImage from https:&#x2F;&#x2F;d2.freessr2.xyz&#x2F;Hiddify-Linux-x64.AppImage chmod 777 Hiddify-Linux-x64.AppImage .&#x2F;Hiddify-Linux-x64.AppImage  2.">
<meta property="og:type" content="website">
<meta property="og:title" content="Linux Access the Open Internet">
<meta property="og:url" content="http://example.com/debug_post/Linux%20Access%20the%20Open%20Internet.html">
<meta property="og:site_name" content="G&amp;R Blog">
<meta property="og:description" content="Linux Access the Open Internet1.Hiddify-Linux下载 Hiddify-Linux-x64.AppImage from https:&#x2F;&#x2F;d2.freessr2.xyz&#x2F;Hiddify-Linux-x64.AppImage chmod 777 Hiddify-Linux-x64.AppImage .&#x2F;Hiddify-Linux-x64.AppImage  2.">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-02-01T12:43:00.000Z">
<meta property="article:modified_time" content="2025-04-28T09:12:02.640Z">
<meta property="article:author" content="G&amp;R">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/fox.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-dark.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="G&R Blog" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/fox.jpg"/>
</a>
<div class="author">
    <span>G&amp;R</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/goldandrabbit"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:goldandrabbit@foxmail.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(170)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="Ads_RecSys">
            
            Ads_RecSys
            <small>(34)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="AI">
            
            AI
            <small>(14)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Algorithm">
            
            Algorithm
            <small>(70)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Coding">
            
            Coding
            <small>(33)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Reading">
            
            Reading
            <small>(12)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Rethinking">
            
            Rethinking
            <small>(7)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="170">
<input type="hidden" id="yelog_site_word_count" value="330k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="search shortcut key i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="switch to outline view shortcut key w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="return"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="case sensitive"></i>
            <i class="iconfont icon-tag" data-title="label"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">outline</div>
            <i class="iconfont icon-list" data-title="switch to article list"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All Coding "
           href="/2099/01/30/G&R%20Blog%20Release%20Regulation/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="G&amp;R Blog Release Regulation">G&amp;R Blog Release Regulation</span>
            <span class="post-date" title="2099-01-30 20:00:00">2099/01/30</span>
        </a>
        
        
        <a  class="All AI "
           href="/2099/01/01/A%20Collection%20of%20High-Quality%20Blog/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="A Collection of High-Quality Blog">A Collection of High-Quality Blog</span>
            <span class="post-date" title="2099-01-01 20:28:00">2099/01/01</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2025/02/01/Linux%20Access%20the%20Open%20Internet/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux Access the Open Internet">Linux Access the Open Internet</span>
            <span class="post-date" title="2025-02-01 20:43:00">2025/02/01</span>
        </a>
        
        
        <a  class="All Rethinking "
           href="/2024/12/29/2024%20Annual%20Summary/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2024 Annual Summary">2024 Annual Summary</span>
            <span class="post-date" title="2024-12-29 09:00:00">2024/12/29</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2024/10/30/Ubuntu%2024.04%20Upgrade%20Log/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Ubuntu 24.04 Upgrade Log">Ubuntu 24.04 Upgrade Log</span>
            <span class="post-date" title="2024-10-30 20:00:00">2024/10/30</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/09/05/LLaMA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="LLaMA">LLaMA</span>
            <span class="post-date" title="2024-09-05 20:00:00">2024/09/05</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/06/30/Large%20Language%20Model/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Large Language Model">Large Language Model</span>
            <span class="post-date" title="2024-06-30 20:00:00">2024/06/30</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/05/30/Decoder-only%20transformer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Decoder-only transformer">Decoder-only transformer</span>
            <span class="post-date" title="2024-05-30 20:00:00">2024/05/30</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2024/03/22/Ubuntu%2022.04%20Upgrade%20Log/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Ubuntu 22.04 Upgrade Log">Ubuntu 22.04 Upgrade Log</span>
            <span class="post-date" title="2024-03-22 10:11:00">2024/03/22</span>
        </a>
        
        
        <a  class="All Rethinking "
           href="/2024/02/20/2023%20Annual%20Summary/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2023 Annual Summary">2023 Annual Summary</span>
            <span class="post-date" title="2024-02-20 20:00:00">2024/02/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2024/01/20/CREAD%20A%20Classification-Restoration%20Framework%20with%20Error%20Adaptive%20Discretization%20for%20Watch%20Time%20Prediction%20in%20Video%20Recommender%20Systems/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CREAD A Classification-Restoration Framework with Error Adaptive Discretization for Watch Time Prediction in Video Recommender Systems">CREAD A Classification-Restoration Framework with Error Adaptive Discretization for Watch Time Prediction in Video Recommender Systems</span>
            <span class="post-date" title="2024-01-20 20:20:00">2024/01/20</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2024/01/11/%E4%BB%8E%E6%89%BE%E4%BA%8B%E7%90%86%E8%AE%BA%E5%88%B0%20TRIZ/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="从找事理论到 TRIZ">从找事理论到 TRIZ</span>
            <span class="post-date" title="2024-01-11 20:11:00">2024/01/11</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/12/30/Joint%20Optimization%20of%20Ranking%20and%20Calibration%20with%20Contextualized%20Hybrid%20Model/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Joint Optimization of Ranking and Calibration with Contextualized Hybrid Model">Joint Optimization of Ranking and Calibration with Contextualized Hybrid Model</span>
            <span class="post-date" title="2023-12-30 20:43:00">2023/12/30</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/11/20/Multi-Scenario%20Ranking%20with%20Adaptive%20Feature%20Learning/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Multi-Scenario Ranking with Adaptive Feature Learning">Multi-Scenario Ranking with Adaptive Feature Learning</span>
            <span class="post-date" title="2023-11-20 20:08:00">2023/11/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/11/20/Towards%20Deeper,%20Lighter%20and%20Interpretable%20Cross%20Network%20for%20CTR%20Prediction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Towards Deeper, Lighter and Interpretable Cross Network for CTR Prediction">Towards Deeper, Lighter and Interpretable Cross Network for CTR Prediction</span>
            <span class="post-date" title="2023-11-20 20:08:00">2023/11/20</span>
        </a>
        
        
        <a  class="All AI "
           href="/2023/10/20/Self-Attention%20with%20Relative%20Position%20Representations/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Self-Attention with Relative Position Representations">Self-Attention with Relative Position Representations</span>
            <span class="post-date" title="2023-10-20 20:08:00">2023/10/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/10/15/RankFlow%20Joint%20Optimization%20of%20Multi-Stage%20Cascade%20Ranking%20Systems%20as%20Flows/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RankFlow Joint Optimization of Multi-Stage Cascade Ranking Systems as Flows">RankFlow Joint Optimization of Multi-Stage Cascade Ranking Systems as Flows</span>
            <span class="post-date" title="2023-10-15 13:08:00">2023/10/15</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/10/11/SHARK%20A%20Lightweight%20Model%20Compression%20Approach%20for%20Large-scale%20Recommender%20Systems/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SHARK A Lightweight Model Compression Approach for Large-scale Recommender Systems">SHARK A Lightweight Model Compression Approach for Large-scale Recommender Systems</span>
            <span class="post-date" title="2023-10-11 20:43:00">2023/10/11</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2023/09/21/Say%20Good%20Night%20To%20Insomnia/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Say Good Night To Insomnia">Say Good Night To Insomnia</span>
            <span class="post-date" title="2023-09-21 20:43:00">2023/09/21</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/09/20/Scenario-Adaptive%20Feature%20Interaction%20for%20Click-Through%20Rate%20Prediction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Scenario-Adaptive Feature Interaction for Click-Through Rate Prediction">Scenario-Adaptive Feature Interaction for Click-Through Rate Prediction</span>
            <span class="post-date" title="2023-09-20 20:43:00">2023/09/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/08/20/Gini%20Coefficient%20%E5%9F%BA%E5%B0%BC%E7%B3%BB%E6%95%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Gini Coefficient 基尼系数">Gini Coefficient 基尼系数</span>
            <span class="post-date" title="2023-08-20 20:08:00">2023/08/20</span>
        </a>
        
        
        <a  class="All AI "
           href="/2023/08/20/Pairwise%20%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Pairwise 损失函数计算">Pairwise 损失函数计算</span>
            <span class="post-date" title="2023-08-20 20:08:00">2023/08/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/08/13/A%20Simple%20Framework%20for%20Contrastive%20Learning%20of%20Visual%20Representations/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="A Simple Framework for Contrastive Learning of Visual Representations">A Simple Framework for Contrastive Learning of Visual Representations</span>
            <span class="post-date" title="2023-08-13 20:43:00">2023/08/13</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/07/20/Delving%20into%20Deep%20Imbalanced%20Regression/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Delving into Deep Imbalanced Regression">Delving into Deep Imbalanced Regression</span>
            <span class="post-date" title="2023-07-20 20:43:00">2023/07/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/07/18/CASPR:%20Customer%20Activity%20Sequence-based%20Prediction%20and%20Representation/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CASPR Customer Activity Sequence-based Prediction and Representation">CASPR Customer Activity Sequence-based Prediction and Representation</span>
            <span class="post-date" title="2023-07-18 20:00:00">2023/07/18</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/07/13/DCN%20V2%20Improved%20Deep%20&%20Cross%20Network%20and%20Practical%20Lessons%20for%20Web-scale%20Learning%20to%20Rank%20Systems/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DCN V2 Improved Deep &amp; Cross Network and Practical Lessons for Web-scale Learning to Rank Systems">DCN V2 Improved Deep &amp; Cross Network and Practical Lessons for Web-scale Learning to Rank Systems</span>
            <span class="post-date" title="2023-07-13 20:00:00">2023/07/13</span>
        </a>
        
        
        <a  class="All AI "
           href="/2023/07/05/Learning%20to%20Rank%20From%20Pairwise%20Approach%20to%20Listwise%20Approach/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Learning to Rank From Pairwise Approach to Listwise Approach">Learning to Rank From Pairwise Approach to Listwise Approach</span>
            <span class="post-date" title="2023-07-05 20:08:00">2023/07/05</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/07/03/Billion-user%20Customer%20Lifetime%20Value%20Prediction%20An%20Industrial-scale%20Solution%20from%20Kuaishou/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Billion-user Customer Lifetime Value Prediction An Industrial-scale Solution from Kuaishou">Billion-user Customer Lifetime Value Prediction An Industrial-scale Solution from Kuaishou</span>
            <span class="post-date" title="2023-07-03 20:00:00">2023/07/03</span>
        </a>
        
        
        <a  class="All AI "
           href="/2023/06/29/Ord2Seq%20Regarding%20Ordinal%20Regression%20as%20Label%20Sequence%20Prediction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Ord2Seq Regarding Ordinal Regression as Label Sequence Prediction">Ord2Seq Regarding Ordinal Regression as Label Sequence Prediction</span>
            <span class="post-date" title="2023-06-29 20:08:00">2023/06/29</span>
        </a>
        
        
        <a  class="All AI "
           href="/2023/06/21/Selective-Supervised%20Contrastive%20Learning%20with%20Noisy%20Labels/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Selective-Supervised Contrastive Learning with Noisy Labels">Selective-Supervised Contrastive Learning with Noisy Labels</span>
            <span class="post-date" title="2023-06-21 20:08:00">2023/06/21</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/06/20/Contrastive%20Multi-view%20Framework%20for%20Customer%20Lifetime%20Value%20Prediction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Contrastive Multi-view Framework for Customer Lifetime Value Prediction">Contrastive Multi-view Framework for Customer Lifetime Value Prediction</span>
            <span class="post-date" title="2023-06-20 20:43:00">2023/06/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/06/18/Ads_Target%20CPX%20v.s.%20Max%20Return/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Ads_Target CPX v.s. Max Return">Ads_Target CPX v.s. Max Return</span>
            <span class="post-date" title="2023-06-18 00:11:10">2023/06/18</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/06/18/Ads_%E9%A2%84%E6%9C%9F%E8%8A%B1%E8%B4%B9%E4%B8%8E%E5%90%8E%E9%AA%8C%E9%A2%84%E6%9C%9F%E8%8A%B1%E8%B4%B9/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Ads_预期花费与后验预期花费">Ads_预期花费与后验预期花费</span>
            <span class="post-date" title="2023-06-18 00:10:10">2023/06/18</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/06/15/MAE%20v.s.%20MSE%20%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E6%AF%94%E8%BE%83/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MAE v.s. MSE 损失函数比较">MAE v.s. MSE 损失函数比较</span>
            <span class="post-date" title="2023-06-15 20:43:00">2023/06/15</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/06/13/A%20Deep%20Probabilistic%20Model%20For%20Customer%20Lifetime%20Value%20Prediction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="A Deep Probabilistic Model For Customer Lifetime Value Prediction">A Deep Probabilistic Model For Customer Lifetime Value Prediction</span>
            <span class="post-date" title="2023-06-13 20:43:00">2023/06/13</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2023/05/30/Jen-Hsun%20Huang%20Stanford%20student%20and%20Entrpreneur,%20co-founder%20and%20CEO%20of%20NVIDIA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Jen-Hsun Huang Stanford student and Entrpreneur, co-founder and CEO of NVIDIA">Jen-Hsun Huang Stanford student and Entrpreneur, co-founder and CEO of NVIDIA</span>
            <span class="post-date" title="2023-05-30 20:43:00">2023/05/30</span>
        </a>
        
        
        <a  class="All Rethinking "
           href="/2023/05/20/2022%20Annual%20Summary/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2022 Annual Summary">2022 Annual Summary</span>
            <span class="post-date" title="2023-05-20 20:00:00">2023/05/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/05/12/Contrastive%20Learning%20for%20Conversion%20Rate%20Prediction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Contrastive Learning for Conversion Rate Prediction">Contrastive Learning for Conversion Rate Prediction</span>
            <span class="post-date" title="2023-05-12 20:43:00">2023/05/12</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2023/01/20/Follow%20the%20Prophet%20Accurate%20Online%20Conversion%20Rate%20Prediction%20in%20the%20Face%20of%20Delayed%20Feedback/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Follow the Prophet Accurate Online Conversion Rate Prediction in the Face of Delayed Feedback">Follow the Prophet Accurate Online Conversion Rate Prediction in the Face of Delayed Feedback</span>
            <span class="post-date" title="2023-01-20 20:08:00">2023/01/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/09/20/Tree%20based%20Progressive%20Regression%20Model%20for%20Watch-Time%20Prediction%20in%20Short-video%20Recommendation/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Tree based Progressive Regression Model for Watch-Time Prediction in Short-video Recommendation">Tree based Progressive Regression Model for Watch-Time Prediction in Short-video Recommendation</span>
            <span class="post-date" title="2022-09-20 20:08:00">2022/09/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/08/12/Field-aware%20Calibration%20A%20Simple%20and%20Empirically%20Strong%20Method%20for%20Reliable%20Probabilistic%20Predictions/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Field-aware Calibration A Simple and Empirically Strong Method for Reliable Probabilistic Predictions">Field-aware Calibration A Simple and Empirically Strong Method for Reliable Probabilistic Predictions</span>
            <span class="post-date" title="2022-08-12 20:43:00">2022/08/12</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/05/21/TabTransformer%20Tabular%20Data%20Modeling%20Using%20Contextual%20Embeddings/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TabTransformer Tabular Data Modeling Using Contextual Embeddings">TabTransformer Tabular Data Modeling Using Contextual Embeddings</span>
            <span class="post-date" title="2022-05-21 20:43:00">2022/05/21</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/05/20/FinalMLP:%20An%20Enhanced%20Two-Stream%20MLP%20Model%20for%20CTR%20Prediction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="FinalMLP An Enhanced Two-Stream MLP Model for CTR Prediction">FinalMLP An Enhanced Two-Stream MLP Model for CTR Prediction</span>
            <span class="post-date" title="2022-05-20 20:43:00">2022/05/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/05/15/H&M%20Recommendation%20Competition%20Top1%20%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="H&amp;M Recommendation Competition Top1 方案">H&amp;M Recommendation Competition Top1 方案</span>
            <span class="post-date" title="2022-05-15 23:55:00">2022/05/15</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/03/20/Deep%20Interest%20Highlight%20Network%20for%20Click-Through%20Rate%20Prediction%20in%20Trigger-Induced%20Recommendation/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Deep Interest Highlight Network for Click-Through Rate Prediction in Trigger-Induced Recommendation">Deep Interest Highlight Network for Click-Through Rate Prediction in Trigger-Induced Recommendation</span>
            <span class="post-date" title="2022-03-20 22:00:00">2022/03/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/03/20/Progressive%20Layered%20Extraction%20(PLE)%20A%20Novel%20Multi-Task%20Learning%20(MTL)%20Model%20for%20Personalized%20Recommendations/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Progressive Layered Extraction (PLE) A Novel Multi-Task Learning (MTL) Model for Personalized Recommendations">Progressive Layered Extraction (PLE) A Novel Multi-Task Learning (MTL) Model for Personalized Recommendations</span>
            <span class="post-date" title="2022-03-20 20:08:00">2022/03/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/03/12/Mechanism%20Design%20%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1_1_Learning-based%20Mechanism/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mechanism Design 机制设计_1_Learning-based Mechanism">Mechanism Design 机制设计_1_Learning-based Mechanism</span>
            <span class="post-date" title="2022-03-12 23:00:00">2022/03/12</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2022/02/20/Mechanism%20Design%20%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mechanism Design 机制设计_0_overview">Mechanism Design 机制设计_0_overview</span>
            <span class="post-date" title="2022-02-20 20:00:00">2022/02/20</span>
        </a>
        
        
        <a  class="All Rethinking "
           href="/2022/02/07/2021%20Annual%20Summary/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2021 Annual Summary">2021 Annual Summary</span>
            <span class="post-date" title="2022-02-07 12:11:00">2022/02/07</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2021/11/11/Cybernetics%20and%20Society%20%E6%8E%A7%E5%88%B6%E8%AE%BA%E4%B8%8E%E7%A4%BE%E4%BC%9A/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cybernetics and Society 控制论与社会">Cybernetics and Society 控制论与社会</span>
            <span class="post-date" title="2021-11-11 21:00:00">2021/11/11</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2021/09/10/Bias%20and%20Debias%20in%20Recommender%20System%20%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%20bias%20%E5%92%8C%20debias/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Bias and Debias in Recommender System 推荐系统中的 bias 和 debias">Bias and Debias in Recommender System 推荐系统中的 bias 和 debias</span>
            <span class="post-date" title="2021-09-10 21:00:00">2021/09/10</span>
        </a>
        
        
        <a  class="All AI "
           href="/2021/08/11/Supervised%20Contrastive%20Learning/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Supervised Contrastive Learning">Supervised Contrastive Learning</span>
            <span class="post-date" title="2021-08-11 20:43:00">2021/08/11</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2021/06/20/Multi-Task%20Learning%20Using%20Uncertainty%20to%20Weigh%20Losses%20for%20Scene%20Geometry%20and%20Semantics/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Multi-Task Learning Using Uncertainty to Weigh Losses for Scene Geometry and Semantics">Multi-Task Learning Using Uncertainty to Weigh Losses for Scene Geometry and Semantics</span>
            <span class="post-date" title="2021-06-20 20:08:00">2021/06/20</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2021/05/20/Causal%20Inference%20%E5%9B%A0%E6%9E%9C%E6%8E%A8%E6%96%AD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Causal Inference 因果推断">Causal Inference 因果推断</span>
            <span class="post-date" title="2021-05-20 20:00:00">2021/05/20</span>
        </a>
        
        
        <a  class="All Rethinking "
           href="/2020/12/31/2020%20Annual%20Summary/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2020 Annual Summary">2020 Annual Summary</span>
            <span class="post-date" title="2020-12-31 23:11:00">2020/12/31</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2020/12/20/Shoe%20Dog%20%E9%9E%8B%E7%8B%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shoe Dog 鞋狗">Shoe Dog 鞋狗</span>
            <span class="post-date" title="2020-12-20 18:53:00">2020/12/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2020/11/08/The%20Essence%20of%20RecSys%20%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%B2%BE%E8%A6%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="The Essence of RecSys 推荐系统精要">The Essence of RecSys 推荐系统精要</span>
            <span class="post-date" title="2020-11-08 11:56:00">2020/11/08</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/10/01/Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hexo 博客搭建总结">Hexo 博客搭建总结</span>
            <span class="post-date" title="2020-10-01 20:11:00">2020/10/01</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_0_1_cpp%20%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_0_1_cpp 设计哲学">cpp_0_1_cpp 设计哲学</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_0_1_vscode%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_0_1_vscode 环境配置">cpp_0_1_vscode 环境配置</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_0_2_%E5%A4%B4%E6%96%87%E4%BB%B6%20header%20file/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_0_2_头文件 headerfile">cpp_0_2_头文件 headerfile</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_0_3_%E8%B0%B7%E6%AD%8C%20C++%20%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_0_3_谷歌 C++ 编程风格">cpp_0_3_谷歌 C++ 编程风格</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_1_1_%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_1_1_左值和右值">cpp_1_1_左值和右值</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_1_2_%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%20Lvalue%20reference/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_1_2_左值引用 Lvalue reference">cpp_1_2_左值引用 Lvalue reference</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_1_3_%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%20Rvalue%20reference/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_1_3_右值引用 Rvalue reference">cpp_1_3_右值引用 Rvalue reference</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_2_2_%E6%8C%87%E9%92%88%20Pointer_2_%E7%A9%BA%E6%8C%87%E9%92%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_2_2_指针 Pointer_2_空指针">cpp_2_2_指针 Pointer_2_空指针</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_2_1_%E6%8C%87%E9%92%88%20Pointer_1_%E5%9C%B0%E5%9D%80%E5%92%8C%E6%8C%87%E9%92%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_2_1_指针 Pointer_1_地址和指针">cpp_2_1_指针 Pointer_1_地址和指针</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_2_3_%E6%8C%87%E9%92%88%20Pointer_3_const%20%E4%B8%8E%E6%8C%87%E9%92%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_2_3_指针 Pointer_3_const 与指针">cpp_2_3_指针 Pointer_3_const 与指针</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_2_4_%E6%8C%87%E9%92%88%20Pointer_4_%E4%BC%A0%E5%9C%B0%E5%9D%80%20Pass%20by%20address/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_2_4_指针 Pointer_4_传地址 Pass by address">cpp_2_4_指针 Pointer_4_传地址 Pass by address</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_2_5_%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88_0_%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_2_5_智能指针_0_设计思想">cpp_2_5_智能指针_0_设计思想</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_2_6_%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88_1_shared_ptr/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_2_6_智能指针_1_shared_ptr">cpp_2_6_智能指针_1_shared_ptr</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_2_7_%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88_2_unique_ptr/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_2_7_智能指针_2_unique_ptr">cpp_2_7_智能指针_2_unique_ptr</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_3_0_constexpr%20%E5%85%B3%E9%94%AE%E5%AD%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_3_0_constexpr关键字">cpp_3_0_constexpr关键字</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_3_2_Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_3_2_Lambda 表达式">cpp_3_2_Lambda 表达式</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_5_1_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_5_1_面向对象_0_overview">cpp_5_1_面向对象_0_overview</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_3_1_const%20%E5%85%B3%E9%94%AE%E5%AD%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_3_1_const 关键字">cpp_3_1_const 关键字</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_5_3_%E5%A4%9A%E6%80%81_0_%E8%99%9A%E5%87%BD%E6%95%B0%20Virtual%20Functions/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_5_3_多态_0_虚函数 Virtual Functions">cpp_5_3_多态_0_虚函数 Virtual Functions</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_6_0_%E6%A8%A1%E6%9D%BF%20template/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_6_0_模板 template">cpp_6_0_模板 template</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/09/10/cpp_5_2_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_1_%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cpp_5_2_面向对象_1_类和成员函数">cpp_5_2_面向对象_1_类和成员函数</span>
            <span class="post-date" title="2020-09-10 00:00:00">2020/09/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/08/20/Python_%E5%A4%9A%E8%BF%9B%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Python_多进程">Python_多进程</span>
            <span class="post-date" title="2020-08-20 20:08:00">2020/08/20</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2020/08/15/%E6%B7%B1%E5%BA%A6%E7%82%B9%E5%87%BB%E7%8E%87%E9%A2%84%E4%BC%B0%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E7%89%B9%E5%BE%81%E4%BA%A4%E5%8F%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深度点击率预估模型中的特征交叉">深度点击率预估模型中的特征交叉</span>
            <span class="post-date" title="2020-08-15 20:11:00">2020/08/15</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2020/07/18/Leetcode_hot_100%20%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Leetcode_hot_100 总结">Leetcode_hot_100 总结</span>
            <span class="post-date" title="2020-07-18 22:56:00">2020/07/18</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2020/04/13/Status%20as%20a%20Service%20%E5%9C%B0%E4%BD%8D%E5%8D%B3%E6%9C%8D%E5%8A%A1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Status as a Service 地位即服务">Status as a Service 地位即服务</span>
            <span class="post-date" title="2020-04-13 20:13:00">2020/04/13</span>
        </a>
        
        
        <a  class="All AI "
           href="/2020/04/04/Faiss%20%E5%90%91%E9%87%8F%E6%A3%80%E7%B4%A2%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Faiss 向量检索库">Faiss 向量检索库</span>
            <span class="post-date" title="2020-04-04 20:11:00">2020/04/04</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2020/03/22/%E7%8B%BC%E4%BA%BA%E6%9D%80%E5%A6%82%E4%BD%95%E8%87%B4%E8%83%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="狼人杀如何致胜">狼人杀如何致胜</span>
            <span class="post-date" title="2020-03-22 02:12:57">2020/03/22</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2020/02/18/David%20Stern,%20who%20turned%20NBA%20into%20powerhouse/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="David Stern, who turned NBA into powerhouse">David Stern, who turned NBA into powerhouse</span>
            <span class="post-date" title="2020-02-18 22:56:00">2020/02/18</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/02/18/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux 常用命令总结">Linux 常用命令总结</span>
            <span class="post-date" title="2020-02-18 22:56:00">2020/02/18</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2020/02/13/Tensorflow%20API%20%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Tensorflow API 总结">Tensorflow API 总结</span>
            <span class="post-date" title="2020-02-13 22:56:00">2020/02/13</span>
        </a>
        
        
        <a  class="All AI "
           href="/2020/02/03/Transformer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Transformer">Transformer</span>
            <span class="post-date" title="2020-02-03 11:56:00">2020/02/03</span>
        </a>
        
        
        <a  class="All AI "
           href="/2020/01/11/Tricks%20in%20Data%20Mining%20Competitions%20%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%E6%8A%80%E5%B7%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Tricks in Data Mining Competitions 数据挖掘比赛技巧">Tricks in Data Mining Competitions 数据挖掘比赛技巧</span>
            <span class="post-date" title="2020-01-11 20:11:00">2020/01/11</span>
        </a>
        
        
        <a  class="All AI "
           href="/2020/01/11/Word2Vec/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Word2Vec">Word2Vec</span>
            <span class="post-date" title="2020-01-11 20:11:00">2020/01/11</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2020/01/11/Yoshua%20Bengio%20%E5%AF%B9%20ML%20%E7%A0%94%E7%A9%B6%E8%80%85%E7%9A%84%E5%BB%BA%E8%AE%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Yoshua Bengio 对 ML 研究者的建议">Yoshua Bengio 对 ML 研究者的建议</span>
            <span class="post-date" title="2020-01-11 20:11:00">2020/01/11</span>
        </a>
        
        
        <a  class="All Rethinking "
           href="/2019/12/31/2019%20Annual%20Summary/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2019 Annual Summary">2019 Annual Summary</span>
            <span class="post-date" title="2019-12-31 15:11:00">2019/12/31</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2019/12/11/Data%20Analysis%20Tutorial:(Part%20I)/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Data Analysis Tutorial:(Part I)">Data Analysis Tutorial:(Part I)</span>
            <span class="post-date" title="2019-12-11 20:11:00">2019/12/11</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2019/11/03/Marketing%20Management%20%E8%90%A5%E9%94%80%E7%AE%A1%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Marketing Management 营销管理">Marketing Management 营销管理</span>
            <span class="post-date" title="2019-11-03 13:03:00">2019/11/03</span>
        </a>
        
        
        <a  class="All Reading "
           href="/2019/10/01/Interview%20record%20of%20ML%20intern%20in%202019/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Interview record of ML intern in 2019">Interview record of ML intern in 2019</span>
            <span class="post-date" title="2019-10-01 12:12:57">2019/10/01</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2019/05/01/Errors%20Archives%20%E6%8A%A5%E9%94%99%E5%BD%92%E6%A1%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Errors Archives 报错归档">Errors Archives 报错归档</span>
            <span class="post-date" title="2019-05-01 13:03:00">2019/05/01</span>
        </a>
        
        
        <a  class="All Ads_RecSys "
           href="/2019/03/20/Modeling%20Task%20Relationships%20in%20Multi-task%20Learning%20with%20Multi-gate%20Mixture-of-Experts/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Modeling Task Relationships in Multi-task Learning with Multi-gate Mixture-of-Experts">Modeling Task Relationships in Multi-task Learning with Multi-gate Mixture-of-Experts</span>
            <span class="post-date" title="2019-03-20 20:43:00">2019/03/20</span>
        </a>
        
        
        <a  class="All Rethinking "
           href="/2018/12/31/2018%20Annual%20Summary/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2018 Annual Summary">2018 Annual Summary</span>
            <span class="post-date" title="2018-12-31 20:17:00">2018/12/31</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/DivideConquer_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DivideConquer_0_overview">DivideConquer_0_overview</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/Hash_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hash_0_overview">Hash_0_overview</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/Heap_1_application/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Heap_1_application">Heap_1_application</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/IntervalProblem_%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IntervalProblem_区间问题">IntervalProblem_区间问题</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2018/06/10/LinkedList_%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="LinkedList_链表操作">LinkedList_链表操作</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/Trie_%E5%89%8D%E7%BC%80%E6%A0%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Trie_前缀树">Trie_前缀树</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/TwoPointers_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TwoPointers_0_overview">TwoPointers_0_overview</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/TwoPointers_1_%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TwoPointers_1_快慢指针">TwoPointers_1_快慢指针</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/TwoPointers_2_%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TwoPointers_2_左右指针">TwoPointers_2_左右指针</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/TwoPointers_3_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TwoPointers_3_滑动窗口">TwoPointers_3_滑动窗口</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/TwoPointers_4_Rabin_Karp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TwoPointers_4_Rabin_Karp">TwoPointers_4_Rabin_Karp</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/TwoPointers_6_n%E6%95%B0%E4%B9%8B%E5%92%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TwoPointers_6_n数之和">TwoPointers_6_n数之和</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/TwoPointers_7_%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TwoPointers_7_荷兰国旗">TwoPointers_7_荷兰国旗</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/TwoPointers_5_%E9%93%BE%E8%A1%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TwoPointers_5_链表">TwoPointers_5_链表</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/06/10/UnionFind_%E5%B9%B6%E6%9F%A5%E9%9B%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="UnionFind_并查集">UnionFind_并查集</span>
            <span class="post-date" title="2018-06-10 00:00:00">2018/06/10</span>
        </a>
        
        
        <a  class="All Coding "
           href="/2018/04/05/Git%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git 使用指南">Git 使用指南</span>
            <span class="post-date" title="2018-04-05 22:56:00">2018/04/05</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Stack_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Stack_0_overview">Stack_0_overview</span>
            <span class="post-date" title="2018-01-19 01:10:00">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Stack_1_%E5%8D%95%E8%B0%83%E6%A0%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Stack_1_单调栈">Stack_1_单调栈</span>
            <span class="post-date" title="2018-01-19 01:09:00">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Stack_2_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Stack_2_表达式解码">Stack_2_表达式解码</span>
            <span class="post-date" title="2018-01-19 01:08:00">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Sort_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Sort_0_overview">Sort_0_overview</span>
            <span class="post-date" title="2018-01-19 00:10:00">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Sort_1_mergeSort_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Sort_1_mergeSort_归并排序">Sort_1_mergeSort_归并排序</span>
            <span class="post-date" title="2018-01-19 00:09:01">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Sort_1_insertionSort_%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Sort_1_insertionSort_插入排序">Sort_1_insertionSort_插入排序</span>
            <span class="post-date" title="2018-01-19 00:09:00">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Sort_2_quickSort_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Sort_2_quickSort_快速排序">Sort_2_quickSort_快速排序</span>
            <span class="post-date" title="2018-01-19 00:08:01">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Sort_2_Partition_%E5%88%92%E5%88%86%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Sort_2_Partition_划分算法">Sort_2_Partition_划分算法</span>
            <span class="post-date" title="2018-01-19 00:08:00">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Sort_3_heapSort_%E5%A0%86%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Sort_3_heapSort_堆排序">Sort_3_heapSort_堆排序</span>
            <span class="post-date" title="2018-01-19 00:07:00">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/19/Sort_4_application_%E6%8E%92%E5%BA%8F%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Sort_4_application_排序题">Sort_4_application_排序题</span>
            <span class="post-date" title="2018-01-19 00:06:00">2018/01/19</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Greedy_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Greedy_0_overview">Greedy_0_overview</span>
            <span class="post-date" title="2018-01-07 01:10:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Graph_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Graph_0_overview">Graph_0_overview</span>
            <span class="post-date" title="2018-01-07 00:10:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Graph_1_dfs_%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Graph_1_dfs_深度优先遍历">Graph_1_dfs_深度优先遍历</span>
            <span class="post-date" title="2018-01-07 00:09:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Graph_2_bfs_%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Graph_2_bfs_广度优先遍历">Graph_2_bfs_广度优先遍历</span>
            <span class="post-date" title="2018-01-07 00:08:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Graph_3_%E7%8E%AF%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Graph_3_环检测与拓扑排序">Graph_3_环检测与拓扑排序</span>
            <span class="post-date" title="2018-01-07 00:08:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Graph_4_%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Graph_4_岛屿问题">Graph_4_岛屿问题</span>
            <span class="post-date" title="2018-01-07 00:06:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Graph_5_Kruskal/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Graph_5_Kruskal">Graph_5_Kruskal</span>
            <span class="post-date" title="2018-01-07 00:05:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Graph_6_Prim/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Graph_6_Prim">Graph_6_Prim</span>
            <span class="post-date" title="2018-01-07 00:04:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/07/Graph_7_Dijstra/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Graph_7_Dijstra">Graph_7_Dijstra</span>
            <span class="post-date" title="2018-01-07 00:03:00">2018/01/07</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/04/DP_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DP_0_overview">DP_0_overview</span>
            <span class="post-date" title="2018-01-04 01:10:00">2018/01/04</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/04/DP_1_%E5%A4%87%E5%BF%98%E5%BD%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DP_1_备忘录">DP_1_备忘录</span>
            <span class="post-date" title="2018-01-04 01:09:00">2018/01/04</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/04/DP_2_%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DP_2_最值问题">DP_2_最值问题</span>
            <span class="post-date" title="2018-01-04 01:08:00">2018/01/04</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/04/DP_3_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%BF%98%E6%98%AF%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DP_3_自顶向下还是自底向上">DP_3_自顶向下还是自底向上</span>
            <span class="post-date" title="2018-01-04 01:07:01">2018/01/04</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/04/DP_3_%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DP_3_背包问题">DP_3_背包问题</span>
            <span class="post-date" title="2018-01-04 01:07:00">2018/01/04</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/04/DP_4_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DP_4_买卖股票">DP_4_买卖股票</span>
            <span class="post-date" title="2018-01-04 01:06:00">2018/01/04</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/04/DP_5_%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DP_5_打家劫舍">DP_5_打家劫舍</span>
            <span class="post-date" title="2018-01-04 01:05:00">2018/01/04</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/04/DP_6_%E9%AB%98%E7%BB%B4%20dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DP_6_高维 dp">DP_6_高维 dp</span>
            <span class="post-date" title="2018-01-04 01:04:00">2018/01/04</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/03/cache_LFU/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cache_LFU">cache_LFU</span>
            <span class="post-date" title="2018-01-03 01:10:00">2018/01/03</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/03/cache_LRU/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="cache_LRU">cache_LRU</span>
            <span class="post-date" title="2018-01-03 00:10:00">2018/01/03</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/Bit_%E4%BD%8D%E8%BF%90%E7%AE%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Bit_位运算">Bit_位运算</span>
            <span class="post-date" title="2018-01-02 04:00:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/Bipartite_%E4%BA%8C%E5%88%86%E5%9B%BE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Bipartite_二分图">Bipartite_二分图</span>
            <span class="post-date" title="2018-01-02 03:00:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_0_overview">BinaryTree_0_overview</span>
            <span class="post-date" title="2018-01-02 02:10:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_1_%E5%88%86%E8%A7%A3%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_1_分解问题">BinaryTree_1_分解问题</span>
            <span class="post-date" title="2018-01-02 02:09:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_2_%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_2_路径问题">BinaryTree_2_路径问题</span>
            <span class="post-date" title="2018-01-02 02:08:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_3_%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_3_迭代遍历">BinaryTree_3_迭代遍历</span>
            <span class="post-date" title="2018-01-02 02:07:01">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_3_%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_3_层序遍历">BinaryTree_3_层序遍历</span>
            <span class="post-date" title="2018-01-02 02:07:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_4_%E6%9E%84%E9%80%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_4_构造">BinaryTree_4_构造</span>
            <span class="post-date" title="2018-01-02 02:06:01">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_4_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E5%8C%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_4_二叉树和链表的互相转化">BinaryTree_4_二叉树和链表的互相转化</span>
            <span class="post-date" title="2018-01-02 02:06:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_5_%E5%BA%8F%E5%88%97%E5%8C%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_4_二叉树和链表的互相转化">BinaryTree_4_二叉树和链表的互相转化</span>
            <span class="post-date" title="2018-01-02 02:05:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_6_BST_%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_6_BST_特性">BinaryTree_6_BST_特性</span>
            <span class="post-date" title="2018-01-02 02:04:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_7_BST_%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E9%AA%8C%E8%AF%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_7_BST_查找插入删除验证">BinaryTree_7_BST_查找插入删除验证</span>
            <span class="post-date" title="2018-01-02 02:03:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinaryTree_8_BST_%E6%9E%84%E9%80%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinaryTree_8_BST_构造">BinaryTree_8_BST_构造</span>
            <span class="post-date" title="2018-01-02 02:02:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinarySearch_0_%E9%97%AD%E5%8C%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80%E6%90%9C%E7%B4%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinarySearch_0_闭区间搜索和左闭右开搜索">BinarySearch_0_闭区间搜索和左闭右开搜索</span>
            <span class="post-date" title="2018-01-02 01:10:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinarySearch_1_%E5%8D%95%E8%B0%83%E7%BB%93%E6%9E%84%E4%B8%8B%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinarySearch_1_单调结构下二分搜索">BinarySearch_1_单调结构下二分搜索</span>
            <span class="post-date" title="2018-01-02 01:09:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinarySearch_2_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinarySearch_2_旋转数组二分搜索">BinarySearch_2_旋转数组二分搜索</span>
            <span class="post-date" title="2018-01-02 01:08:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/BinarySearch_3_%E5%8D%95%E8%B0%83%E6%80%A7%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BinarySearch_3_单调性应用问题的二分搜索">BinarySearch_3_单调性应用问题的二分搜索</span>
            <span class="post-date" title="2018-01-02 01:07:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/Backtrack_0_overview/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Backtrack_0_overview">Backtrack_0_overview</span>
            <span class="post-date" title="2018-01-02 00:10:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/Backtrack_1_N%E7%9A%87%E5%90%8E%E5%92%8C%E8%A7%A3%E6%95%B0%E7%8B%AC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Backtrack_1_N皇后和解数独">Backtrack_1_N皇后和解数独</span>
            <span class="post-date" title="2018-01-02 00:09:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/02/Backtrack_2_%E7%94%9F%E6%88%90%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%AD%90%E9%9B%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Backtrack_2_生成排列组合子集">Backtrack_2_生成排列组合子集</span>
            <span class="post-date" title="2018-01-02 00:08:00">2018/01/02</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/01/Array_1_0_%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Array_1_0_前缀和数组与差分数组">Array_1_0_前缀和数组与差分数组</span>
            <span class="post-date" title="2018-01-01 00:10:10">2018/01/01</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/01/Array_1_1_%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Array_1_差分数组">Array_1_差分数组</span>
            <span class="post-date" title="2018-01-01 00:09:10">2018/01/01</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/01/Array_2_%E8%8A%B1%E5%BC%8F%E6%90%9C%E7%B4%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Array_2_花式搜索">Array_2_花式搜索</span>
            <span class="post-date" title="2018-01-01 00:08:00">2018/01/01</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/01/Array_3_%E5%9B%BE%E5%83%8F%E7%BF%BB%E8%BD%AC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Array_3_图像翻转">Array_3_图像翻转</span>
            <span class="post-date" title="2018-01-01 00:07:00">2018/01/01</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/01/Array_4_%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Array_4_环形数组">Array_4_环形数组</span>
            <span class="post-date" title="2018-01-01 00:06:00">2018/01/01</span>
        </a>
        
        
        <a  class="All Algorithm "
           href="/2018/01/01/Array_5_%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Array_5_矩阵操作">Array_5_矩阵操作</span>
            <span class="post-date" title="2018-01-01 00:05:00">2018/01/01</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="Toggle full screen shortcut key s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-Leetcode_hot_100 总结" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Leetcode_hot_100 总结</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Algorithm">Algorithm</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2025-04-28 17:20:54'>2020-07-18 22:56</time>
        
    </div>
    <div class="article-meta">
        
        <span>Count:35.4k</span>
        
        
        
        <span class="top-comment" title="Jump to comment area">
            <a href="#comments">
                Comment:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-text">哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">1.两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-text">49.字母异位词分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-text">128.最长连续序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">双指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-text">283.移动零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">11.盛最多水的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">15.三数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-text">42.接雨水</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-text">3.无重复字符的最长子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-text">438.找到字符串中所有字母异位词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E4%B8%B2"><span class="toc-text">子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#560-%E5%92%8C%E4%B8%BA-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">560.和为 K 的子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">239.滑动窗口最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-text">76.最小覆盖子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%95%B0%E7%BB%84"><span class="toc-text">普通数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-text">53.最大子数组和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-text">56.合并区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-text">189.轮转数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-text">238.除自身以外数组的乘积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0"><span class="toc-text">41.缺失的第一个正数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5"><span class="toc-text">矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6"><span class="toc-text">73.矩阵置零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-text">54.螺旋矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="toc-text">48.旋转图像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II"><span class="toc-text">240.搜索二维矩阵 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-text">160.相交链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">206.反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-text">234.回文链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-text">141.环形链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="toc-text">142.环形链表 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">21.合并两个有序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-text">2.两数相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-text">19.删除链表的倒数第 N 个结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">24.两两交换链表中的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">25.K 个一组翻转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#138-%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">138.随机链表的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">148.排序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">23.合并 K 个升序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#146-LRU-%E7%BC%93%E5%AD%98"><span class="toc-text">146.LRU 缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">94.二叉树的中序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text">104.二叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">226.翻转二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">101.对称二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="toc-text">543.二叉树的直径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">102.二叉树的层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">108.将有序数组转换为二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">98.验证二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">230.二叉搜索树中第K小的元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-text">199.二叉树的右视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-text">114.二叉树展开为链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">105.从前序与中序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-text">437.路径总和 III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">236.二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text">124.二叉树中的最大路径和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-text">图论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-text">200.岛屿数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90"><span class="toc-text">994.腐烂的橘子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#207-%E8%AF%BE%E7%A8%8B%E8%A1%A8"><span class="toc-text">207.课程表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-text">208.实现 Trie (前缀树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">46.全排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86"><span class="toc-text">78.子集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-text">17.电话号码的字母组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39.组合总和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-text">22.括号生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="toc-text">79.单词搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-text">131.分割回文串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-N-%E7%9A%87%E5%90%8E"><span class="toc-text">51.N 皇后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-text">35.搜索插入位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="toc-text">74.搜索二维矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-text">34.在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">33.搜索旋转排序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-text">153.寻找旋转排序数组中的最小值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-text">4.寻找两个正序数组的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-text">20.有效的括号</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div align="center">
<img src="/imgs/leetcode/0.png" width="80%"/>
</div>

<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><blockquote>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p>
<p>示例 1：输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p>
<p>示例 2：输入：nums = [3,2,4], target = 6 输出：[1,2]</p>
<p>示例 3：输入：nums = [3,3], target = 6 输出：[0,1]</p>
</blockquote>
<p>分析:<br>1.遍历数组, 同时 hash 记录当前已经保存过的数字的索引, 遇到互补元素则可以找到两数之和;  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;
    unordered_map&lt;int, int&gt; num2idx;
    for (int i = 0; i &lt; nums.size(); ++i) &#123;
      if (num2idx.find(target - nums[i]) != num2idx.end()) &#123;
        return vector&lt;int&gt;&#123;num2idx[target-nums[i]], i&#125;;
      &#125;
      num2idx[nums[i]] = i;
    &#125;
    return vector&lt;int&gt;&#123;&#125;;
  &#125;
&#125;;
</code></pre>
<h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a>49.字母异位词分组</h2><blockquote>
<p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。字母异位词是由重新排列源单词的所有字母得到的一个新单词。</p>
<p>示例 1: 输入: strs = [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”] 输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</p>
<p>示例 2: 输入: strs = [“”] 输出: [[“”]]</p>
<p>示例 3: 输入: strs = [“a”] 输出: [[“a”]]</p>
</blockquote>
<p>分析:<br>1.按照每一类异位词进行分组哈希, 然后遍历哈希表, 哈希函数设计成什么呢?<br>2.一种简单的做法是 26 个字符出现的次数拼起来的字符串, 对于 abd 来说就是 “11010000..00” 这样, 但是一个词出现的次数大于 10 次造成冲突, 所以在每个位置之间增加一个分隔符, 比如 1#1#0#1..#0#  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;
    vector&lt;vector&lt;string&gt;&gt; ans;
    unordered_map&lt;string, vector&lt;string&gt;&gt; group2strs;
    auto hash = [] (string s) &#123;
      vector&lt;int&gt; cnt(26, 0);
      for (char c: s) &#123;
        cnt[c - &#39;a&#39;] += 1; 
      &#125;
      string hashStr = &quot;&quot;;
      for (auto c: cnt) &#123;
        hashStr += to_string(c) + &quot;#&quot;;
      &#125;
      return hashStr;
    &#125;;
    for (auto s: strs) &#123;
      group2strs[hash(s)].push_back(s);
    &#125;
    for (auto x: group2strs) &#123;
      ans.push_back(x.second);
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128.最长连续序列"></a>128.最长连续序列</h2><blockquote>
<p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<p>示例 1：输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</p>
<p>示例 2：输入：nums = [0,3,7,2,5,8,4,6,0,1] 输出：9</p>
</blockquote>
<p>分析:<br>1.时间复杂度要求是 O(n), 排序之类的都不能用<br>2.这里关键是分析连续序列有什么特殊性? 对于连续的序列, 它的很多子序列对我们计算最长序列长度没有影响, 比如对 1,2,3,4 这个序列, 对于它的子序列, 例如 2,3,4 或者 3,4, 不会增加最大长度序列的可能性; 如果能想到研究对象缩短到研究, 当前的数字是否是某个最长序列的 [判断可能是一个最长连续序列的起点], 那么复杂度就不会增加; 也就是说, 我们对任意一个数字, 判断当前的数字是 [可能是一个最长连续序列的起点] 的时候, 才会进入内层统计长度, 因此时间复杂度是 O(n)<br>3.用一个 set 去保存元素, 然后遍历 set , 每个元素首先检查是否是第一个元素, 如果不是那么就不进入扫描最长连续长度   </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;
    if (nums.empty()) &#123;
      return 0;
    &#125;
    unordered_set&lt;int&gt; s(nums.begin(), nums.end());
    int ans = 1;
    for (auto x: s) &#123;
      // 判断可能是一个最长连续序列的起点
      if (!s.count(x - 1)) &#123;
        int len = 1;
        int cur = x;
        // 进入里面开始逐个判断以它为起点的最长长度
        while (s.count(cur + 1)) &#123;
          ++len;
          ++cur;
        &#125;
        ans = max(len, ans);
      &#125;
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h2><blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。请注意，必须在不复制数组的情况下原地对数组进行操作。</p>
<p>示例 1: 输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0]</p>
<p>示例 2: 输入: nums = [0] 输出: [0]</p>
</blockquote>
<p>分析:<br>1.把所有的 0 移动到末尾, 等同于把所有的非0元素移动到最前面, 然后将后面的全部置为零; 要求就地复制元素实现, 维护快慢双指针, fast 检索所有非0的元素之后给到 slow<br>2.fast 检索完之后, 从 slow 开始后面的元素都设置成 0  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;
    int len = nums.size();
    if (len &lt;= 1) &#123;
      return;
    &#125;
    int slow = 0;
    int fast = 0;
    // 快慢指针
    // fast 给到 slow 将非 0 元素移动到最前面
    while (fast &lt; len) &#123;
      if (nums[fast] != 0) &#123;
        nums[slow] = nums[fast];
        ++slow;
      &#125;
      ++fast;
    &#125;
    // 把 slow 之后的都设置为 0 
    while (slow &lt; len) &#123;
      nums[slow] = 0;
      ++slow;
    &#125;
    return;
  &#125;
&#125;;
</code></pre>
<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h2><blockquote>
<p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。说明：你不能倾斜容器。</p>
<p>示例 1：输入：[1,8,6,2,5,4,8,3,7] 输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p>示例 2：输入：height = [1,1] 输出：1</p>
</blockquote>
<p>分析:<br>1.我们找出来两个左右两个端点, 然后计算最大的盛出来的水量, 假设我们已经有了这么两个最优的端点, 盛出来水的量是什么?<br>直接求面积, 面积的公式是什么? 假设我们确定了左右两个指针 left, right, 长就是 right - left, 宽是什么 ? 其实和木桶原理有点像, 承载的水是两边比较低的那头, 也就是 min(left, right);<br>curArea = min(left, right) * (right - left)<br>2.所以怎么搜索最大的面积呢 ? 一开始肯定是从最左边和最右边两个端点开始, 计算一个 curArea; 然后怎么更新呢? 每次是移动左边的指针还是移动右边的指针? 因为面积是取决于左右两边的最小值, 也就是说, 我们需要每次更新的是比当前下界更高的那个下界, 才能有机会找到更大的面积, 因此我们每次移动的是当前的 left 和 right 中间较小的一个指针  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  int maxArea(vector&lt;int&gt;&amp; height) &#123;
    int len = height.size();
    int left = 0;
    int right = len - 1;
    int ans = 0;
    while (left &lt; right) &#123;
      int curArea = min(height[left], height[right]) * (right - left);
      ans = max(ans, curArea);
      if (height[left] &lt; height[right]) &#123;
        ++left;
      &#125; else &#123;
        --right;
      &#125;
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><blockquote>
<p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。</p>
<p>示例 1：输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]]<br>解释：<br>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。<br>nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。<br>nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br>注意，输出的顺序和三元组的顺序并不重要。</p>
<p>示例 2：输入：nums = [0,1,1] 输出：[]  解释：唯一可能的三元组和不为 0 。</p>
<p>示例 3：输入：nums = [0,0,0] 输出：[[0,0,0]]  解释：唯一可能的三元组和为 0 。</p>
</blockquote>
<p>分析:<br>1.因为只是判断存在性, 元素前后不存在先后顺序, 所以先排序<br>2.对所有的元素扫描, 固定住当前的第 i 个元素, 在后面的数组用双指针搜索 complement == nums[left] + nums[right] == - nums[i] 的情况<br>3.因为我们要的结果是不重复的三元组, 如果当前的元素和前面的一个元素相等, 就会多计算一次, 所以在找的时候直接过掉这一次; 在左右指针搜索的时候, 也要注意避免重复的结果 push  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;
    vector&lt;vector&lt;int&gt;&gt; ans;
    int len = nums.size();
    if (len &lt;= 2) &#123;
      return ans;
    &#125;
    sort(nums.begin(), nums.end());
    // 当前元素作为最小的元素
    for (int i = 0; i &lt; len - 2; ++i) &#123;
      // 最小的元素&gt;0, 后面都不用搜索了
      if (nums[i] &gt; 0) &#123;
        break;
      &#125;
      // 如果当前元素和前面元素相同, 不再重复判断, 否则会造成结果重复
      if (i - 1 &gt;= 0 &amp;&amp; nums[i] == nums[i-1]) &#123;
        continue;
      &#125;
      int complement = -nums[i];
      int left = i + 1;
      int right = len - 1;
      while (left &lt; right) &#123;
        if (nums[left] + nums[right] == complement) &#123;
          ans.push_back(&#123;nums[i], nums[left], nums[right]&#125;);
          while (left &lt; right &amp;&amp; nums[left] == nums[left+1]) &#123;
            ++left;
          &#125;
          while (left &lt; right &amp;&amp; nums[right] == nums[right-1]) &#123;
            --right;
          &#125;
          ++left;
          --right;
        &#125; else if (nums[left] + nums[right] &lt; complement) &#123;
          ++left;
        &#125; else if (nums[left] + nums[right] &gt; complement) &#123;
          --right;
        &#125;
      &#125;
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.接雨水</h2><blockquote>
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>示例 1：输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p>
<p>示例 2：输入：height = [4,2,0,3,2,5] 输出：9</p>
</blockquote>
<p>分析:<br>1.需要分析接到的水量是怎么计算的, 从直观感觉来算, 对于 (示例图里面) 出现的【凹槽里面水】, 要计算接到的雨水数量, 怎么累计全部凹槽的雨水量呢 ? 我们先考虑对于1个位置来说, 比如针对第i个位置上, 最大能接到的水怎么算?<br>2.对于最左边和最右边的位置, 不管多高或者多低, 题意背景下都是接不到水的, 所以我们考察的是 [1, n-1] 这些位置上的 i 的获得水量, 针对第i个位置上, 水量怎么计算呢?<br>3.类似木桶原理, 对于第i个位置上的接水量, 第一感觉上取决于左边和右边的较低的一方, 但是还有一种情况是考虑凹槽是 [T字型] 的这种情况, 所以就不可以仅考虑 i 位置相邻的 [i-1, i+1] 的情况, 而是要确定位置 i 左右两侧各自最高度的的情况, 然后再去取左右两侧所有最高度的最小高度; 同时, 对于 i 位置自己本身也是有高度的, 假设左边柱子最高的高度是比位置i还要低的, 那么计算一边的最低位置也要考虑算自己<br>4.总结: 对于位置 i, 能接雨水的量为: min(i左侧所有(含i)最高柱子, 右侧所有(含有i)最高柱子) - height[i]  </p>
<pre><code class="lang-cpp">water[i] = min(max(height[0..i]), max(height[i..n-1])) - height[i];
</code></pre>
<p>5.代码思路: 从左往右累加第 i 个位置上的雨水值; 对于第 i 个位置, 分别计算它左侧 (包括自己) 的最高值, 计算右侧的最高值, 然后取二者的最小值, 在减去自己位置 i 的高度, 得到的就是第 i 个位置上的接水量, 因此我们得到最 naive 的版本  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  int trap(vector&lt;int&gt;&amp; height) &#123;
    int n = height.size();
    int ans = 0;
    for (int i = 1; i &lt; n - 1; ++i) &#123;
      int leftSideMax = 0;
      int rightSideMax = 0;
      for (int j = i; j &gt;= 0; --j) &#123;
        leftSideMax = max(leftSideMax, height[j]);
      &#125; 
      for (int j = i; j &lt; n; ++j) &#123;
        rightSideMax = max(rightSideMax, height[j]);
      &#125;
      ans += min(leftSideMax, rightSideMax) - height[i];
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<p>6.naive 版本显示超时, 超时的原因是第i个位置上计算时, 每次计算左边右边的最大值都会重复遍历一遍, 可以用备忘录把这个记下来, 其实就是记录下来了左边或者右边最大高度的状态转移关系 (将这道题当做动态规划来做); 状态初始条件是什么? 比如对于 leftMaxMemo[0] 记录的是第0个元素左边的最大, rightMaxMemo[0] 记录的是右边最后一个元素的最大, 为了后续结果计算不影响, 我们将左边最大和右边最大分别设置成最左边的1个元素高度和右边最后一个元素的高度;</p>
<pre><code class="lang-cpp">vector&lt;int&gt; leftMaxMemo(n);
vector&lt;int&gt; rightMaxMemo(n);

// 初始条件
leftMaxMemo[0] = height[0];
rightMaxMemo[n-1] = height[n-1];

// 状态转移
for (int i = 1; i &lt; n; ++i) &#123;
  leftMaxMemo[i] = max(height[i], leftMaxMemo[i-1]);
&#125;

// 状态转移
for (int i = n - 2; i &gt;= 0; --i) &#123;
  rightMaxMemo[i] = max(height[i], rightMaxMemo[i+1]);
&#125;
</code></pre>
<p>7.有了状态转移的备忘录, solution 如下:</p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  int trap(vector&lt;int&gt;&amp; height) &#123;
    int len = height.size();
    int ans = 0;
    vector&lt;int&gt; leftMaxMemo(len);
    vector&lt;int&gt; rightMaxMemo(len);

    // 初始条件: 设置第0位置元素左边最大为第 0 个元素的高度, 设置第 n-1 位置元素右边最大为第 n-1 个元素的高度
    // 不影响状态转移计算的结果
    leftMaxMemo[0] = height[0];
    rightMaxMemo[len-1] = height[len-1];

    // 构造左侧最大的 memo: 状态转移为 max(height[i], leftMaxMemo[i-1])
    for (int i = 1; i &lt;= len-1; ++i) &#123;
      leftMaxMemo[i] = max(height[i], leftMaxMemo[i-1]);
    &#125;
    // 构造右侧侧最大的 memo 状态转移为 max(height[i], rightMaxMemo[i-1])
    for (int i = len-2; i &gt;= 0; --i) &#123;
      rightMaxMemo[i] = max(height[i], rightMaxMemo[i+1]);
    &#125;

    for (int i = 1; i &lt;= len-2; ++i) &#123;
      ans += min(leftMaxMemo[i], rightMaxMemo[i]) - height[i];
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<p>8.左右双指针两边向中间逼近思路 (可以先参考下另一个问题 11.盛最多水的容器 再回来看这个问题)<br>在动态规划的方法中, 我们考察的是 左侧 [0..i] 区间 和右侧 [i..n-1] 区间的各自区间最大值, 但我们最终是关心 min(leftSideMax, rightSideMax), 也就是只关心两边各自最大中的 [最小的一个]<br>假如我们知道在 leftMax &lt; rightMax 的情况下, 那么右边最大的是多少暂时不重要, 只需要关心 height[i] 和 已经被确认是较低的 leftMax 去运算<br>而且我们发现动态规划的时候, 左边指针单项往右扫, 右边指针单项向右扫, 扫完一个位置之后都是就不回来了, 每个位置上只扫一次, 在这种设定下, 实质上考察 左侧[0..left] 区间和 右侧[right..n-1] 区间, 且 left 指针始终向右扫, right始终向左扫  </p>
<p>9.我们只对维护左边和右边两个指针去保存, 而不是按照整个数组去保存, 看下能否实现: 用左右两个指针去扫描, 判断哪个指针扫过的最高柱子更小, 就移动哪个指针, 同时累加当前的扫过的接水量  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  int trap(vector&lt;int&gt;&amp; height) &#123;
    int n = height.size();
    int ans = 0;
    int leftMaxPtr  = 0;
    int rightMaxPtr = n - 1;
    int leftMax = 0;
    int rightMax = 0;
    while (leftMaxPtr &lt; rightMaxPtr) &#123;
      // 左右指针向中央逼近, 只找两边各自最大的里面更小的一个
      leftMax  = max(leftMax,  height[leftMaxPtr]);
      rightMax = max(rightMax, height[rightMaxPtr]);
      // 哪边更小, 累加哪边的雨水, 同时也移动哪边的指针;
      if (leftMax &lt; rightMax) &#123;
        ans += leftMax - height[leftMaxPtr];
        ++leftMaxPtr;
      &#125; else &#123;
        ans += rightMax - height[rightMaxPtr];
        --rightMaxPtr;
      &#125;
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><blockquote>
<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1: 输入: s = “abcabcbb” 输出: 3  解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>示例 2：输入: s = “bbbbb” 输出: 1 解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p>示例 3: 输入: s = “pwwkew” 输出: 3 解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
</blockquote>
<p>分析:<br>1.用滑动窗口对任何一个子串进行无重复判断, 维护窗口内我们搜的是最长的不重复子串<br>2.为了判断窗口内是无重复的, 我们引入一个 hash表 去记录窗口内每个字符出现的次数<br>3.如果当前右边指针指向字符发生了重复, 那么就移动左边的窗口  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  int lengthOfLongestSubstring(string s) &#123;
    int len = s.size();
    if (len &lt;= 1) &#123;
      return len;
    &#125;
    int l = 0;
    int r = 0;
    int ans = 1;
    // 记录无重复窗口里面的字符出现次数
    unordered_map&lt;char, int&gt; noRepeatWindowCharCnt;
    while (r &lt; len) &#123;
      char rc = s[r];
      ++r;
      noRepeatWindowCharCnt[rc] += 1;
      // 如果右边指针出现了重复元素, 窗口左侧持续收缩, 直到窗口里面完全无重复 (noRepeatWindowCharCnt[rc] == 1)
      while (noRepeatWindowCharCnt[rc] &gt; 1) &#123;
        char lc = s[l];
        ++l;
        --noRepeatWindowCharCnt[lc];
      &#125;
      ans = max(ans, r - l);
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438.找到字符串中所有字母异位词"></a>438.找到字符串中所有字母异位词</h2><blockquote>
<p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p>示例 1:输入: s = “cbaebabacd”, p = “abc” 输出: [0,6]<br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</p>
<p>示例 2: 输入: s = “abab”, p = “ab” 输出: [0,1,2]<br>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的异位词。</p>
</blockquote>
<p>分析:<br>1.先采用模板的方法: 用滑动窗口搜索每个窗口内是否每个字母出现的次数和需要的次数是一致的; 首先构建一个 hash table 将需要的次数统计一下<br>2.开始滑动, 每次滑动的时候记录一下当前窗口内每个字符出现的次数, 如何判定所有的次数和整体的次数相等? 一种简单的方法是再引入一个窗口内满足条件的总次数, 每次判定当前右边指针指向的那个字符和我们想要的这个字符出现次数是匹配的情况下, ++valid, 如果 validCnt = p.size(); 那么就推出去结果  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  vector&lt;int&gt; findAnagrams(string s, string p) &#123;
    unordered_map&lt;char, int&gt; need;
    unordered_map&lt;char, int&gt; window;
    for (char c: p)
      ++need[c];
    int left = 0;
    int right = 0;
    int valid = 0;
    vector&lt;int&gt; ans;
    while (right &lt; s.size()) &#123;
      char r = s[right];
      ++right;
      if (need.count(r)) &#123;
        ++window[r];
        if (need[r] == window[r])
          ++valid;
      &#125;
      while (right - left &gt;= p.size()) &#123;
        if (valid == need.size()) &#123;
          ans.push_back(left);
        &#125;
        char l = s[left];
        ++left;
        if (need.count(l)) &#123;
          if (need[l] == window[l]) &#123;
            --valid;
          &#125;
          --window[l];
        &#125;
      &#125;
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<p>滑动窗口的方法可以采用更简单的方式, 用 vector<int>pCnt(26, 0) 保存 p 中各个字符出现的次数, 用 vector<int>sCnt(26,0) 保存当前遍历的 s 子串中各个字符出现的次数, 并且用一个长度为 pLen 的滑动窗口来维护 sCnt 的变化, 然后 push 进去判断相等情况下的 index, 代码如下</p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  vector&lt;int&gt; findAnagrams(string s, string p) &#123;
    int sLen = s.size();
    int pLen = p.size();
    vector&lt;int&gt; ans;
    if (pLen &gt; sLen) &#123;
      return ans;
    &#125;
    vector&lt;int&gt; sCnt(26, 0);
    vector&lt;int&gt; pCnt(26, 0);
    for (int i = 0; i &lt; pLen; ++i) &#123;
      ++pCnt[p[i] - &#39;a&#39;];
      ++sCnt[s[i] - &#39;a&#39;];
    &#125;
    if (sCnt == pCnt) &#123;
      ans.push_back(0);
    &#125;
    for (int i = 1; i &lt; sLen - pLen + 1; ++i) &#123;
      sCnt[s[i-1] - &#39;a&#39;] -= 1;
      sCnt[s[i + pLen - 1] - &#39;a&#39;] += 1;
      if (sCnt == pCnt) &#123;
        ans.push_back(i);
      &#125;
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h2><h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560.和为 K 的子数组"></a>560.和为 K 的子数组</h2><blockquote>
<p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。子数组是数组中元素的连续非空序列。</p>
<p>示例 1：输入：nums = [1,1,1], k = 2 输出：2</p>
<p>示例 2：输入：nums = [1,2,3], k = 3 输出：2</p>
</blockquote>
<p>分析:<br>1.题目中要求的是计算数组中连续子数组的求和 == k的情况, 我们看到连续子数组求和马上联想到前缀和数组看看能不能加快计算, 因为要求的是连续子数组和 == k, 那么其实转化到前缀和数组上就是问两个前缀和的差 == k的情况<br>2.我们用带包含的定义 preSum[i] 是包含第 i 个元素的前缀和, 也就是</p>
<pre><code class="lang-cpp">preSum[i] = preSum[i - 1] + num[i]
</code></pre>
<p>3.对于任意的两个下标 i 和 j（i &lt; j），如果 prefixSum[j] - prefixSum[i] = k，即从第 i 个位置到第 j 个位置的元素之和等于 k, 那么说明从第 i+1 个位置到第 j 个位置的连续子数组的和为 k<br>先遍历 1 次数组, 得到前缀和数组, 开一个哈希表来存储每种前缀和出现的次数. 在遍历的过程中, 我们检查是否存在 prefixSum[j] - k的前缀和, 如果存在，说明从某个位置到当前位置的连续子数组的和为 k, 我们将对应的次数累加到结果中<br>再遍历一次数组，累加出和为 k 的连续子数组的个数，最终时间复杂度为 O(n)  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;
    int n = nums.size();
    if (n == 0) &#123;
      return 0;
    &#125;
    int ans = 0;
    // 构建包含i的前缀数组
    vector&lt;long&gt; preSum(n, 0);
    preSum[0] = nums[0];
    for (int i = 1; i &lt; n; ++i) &#123;
      preSum[i] = preSum[i-1] + nums[i];
    &#125;
    // preSum2Cnt 记录每一种前缀和出现的次数
    unordered_map&lt;long, int&gt; preSum2Cnt;
    preSum2Cnt[0] = 1;
    for (int i = 0; i &lt; n; ++i) &#123;
      // 如果 preSum[i] - k 这种前缀和是存在的, 那么答案累加这种前缀和的次数, 同时累加这种前缀和出现的次数
      if (preSum2Cnt.find(preSum[i] - k) != preSum2Cnt.end()) &#123;
        ans += preSum2Cnt[preSum[i] - k];
      &#125;
      // 累加前缀和出现的次数
      preSum2Cnt[preSum[i]] += 1;
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<p>对每个位置 i, 计算前缀和只需用 1 次, 因此前缀和计算和累加前缀和是可以同时进行, 不需要开数组, 只维护当前那个前缀和出现的次数  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;
    int n = nums.size();
    int ans = 0;
    if (n == 0) &#123;
      return 0;
    &#125;
    long preSum = 0;
    unordered_map&lt;long, int&gt; preSum2Cnt;
    preSum2Cnt[0] = 1;
    for (int i = 0; i &lt; n; ++i) &#123;
      preSum += nums[i];
      if (preSum2Cnt.find(preSum - k) != preSum2Cnt.end()) &#123;
        ans += preSum2Cnt[preSum - k];
      &#125;
      preSum2Cnt[preSum] += 1;
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h2><blockquote>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值 。</p>
<p>示例 1：输入：nums = [1,3,-1,-3,5,3,6,7], k = 3 输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
<p>示例 2：输入：nums = [1], k = 1 输出：[1]</p>
</blockquote>
<p>分析:<br>1.核心思路是如果有一个数据结构能模拟窗口滑动的移动, 那么问题就解决了, 有没有这样的一个数据结构呢? 既要随时取出来最大的元素, 同时满足一个窗口大小是固定的; 为了满足取出来最大的元素, 想到可以持续用大顶堆取顶部元素 pq.top(), 依次取出来最大的那个元素<br>2.但是怎么模拟窗口大小固定的呢? 可以持续往大顶堆加入元素, 但是保存我们要的结果的时候需要判断一下是否在固定长度的窗口内; 也就是说, 在移动过程中, 队列持续加入元素, 但是最大元素可能不在窗口里面, 需要移除出去最大的元素, 需要注意是要持续移动直到不在窗口内的所有最大元素都移除出去<br>3.判断不在窗口内方法是队列元素增加一个维度是 index , 如果判断当前窗口添加元素后最大元素应该排除出去, 这时候有 窗口的维护是 [i-k+1, i] 这么 k 个元素, 也就是说窗口元素包含的下界是 [i-k+1], 所以 q.top().second &lt; i - k + 1 都要移除出去<br>4.举个例子 [9,10,9,-7,-4,-8,2,-6] 窗口大小是 5  </p>
<p>移动方法是:<br>[9,10,9,-7,-4,-8,2,-6]  [9,10,9,-7,-4] max = 10<br>[9,10,9,-7,-4,-8,2,-6]  i = 5 队列放入-8 [9,10,9,-7,-4,-8] max=10<br>[9,10,9,-7,-4,-8,2,-6]  i = 6 队列放入2 [9,10,9,-7,-4,-8,2] 最大元素 10 不应该在窗口里面, 删掉10, 变成 [9,9,-7,-4,-8,2], 最大元素9从队列删除, 变成 [9,-7,-4,-8,2] max = 9<br>[9,10,9,-7,-4,-8,2,-6]  i = 7 放入-6 [9,-7,-4,-8,2,-6], 删除最左边的9, max=2<br>所以最后是 [10,10,9,2]  </p>
<pre><code class="lang-cpp">typedef pair&lt;int, int&gt; pii;

class Solution &#123;
 public:
  vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;
    int len = nums.size();
    auto cmp = [] (const pii&amp; a, const pii&amp; b) &#123;
      return a.first &lt; b.first;
    &#125;;
    // 建一个 pii 类型大顶堆, 维护 &lt;元素值, index&gt; pair
    priority_queue&lt;pii, vector&lt;pii&gt;, decltype(cmp)&gt; pq;
    for (int i = 0; i &lt; k; ++i) &#123;
      pq.push(&#123;nums[i], i&#125;);
    &#125;
    vector&lt;int&gt; ans&#123;pq.top().first&#125;;
    for (int i = k; i &lt; len; ++i) &#123;
      // 开始滑动窗口, 放入元素
      pq.push(&#123;nums[i], i&#125;);
      // 当最大元素已经不在窗口内, 持续将最大元素赶出队列
      // [i-k+1, i] 是当前的窗口 索引搜索的边界是 idx &lt; i - k + 1
      while (pq.top().second &lt; i - k + 1) &#123;
        pq.pop();
      &#125;
      ans.push_back(pq.top().first);
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a>76.最小覆盖子串</h2><blockquote>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。<br>注意：对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>
<p>示例 1：输入：s = “ADOBECODEBANC”, t = “ABC” 输出：”BANC” 解释：最小覆盖子串 “BANC” 包含来自字符串 t 的 ‘A’、’B’ 和 ‘C’。</p>
<p>示例 2：输入：s = “a”, t = “a” 输出：”a” 解释：整个字符串 s 是最小覆盖子串。</p>
<p>示例 3: 输入: s = “a”, t = “aa” 输出: “” 解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。</p>
</blockquote>
<p>分析:<br>1.我们用滑动窗口处理这个最小覆盖子串的搜索问题, 初始化左右指针 left/right 都是起始位置, 对于判定子串是否覆盖, 我们先建立一个 unordered_map<char, int> need, 用于记录我们 t 字符串的计数统计, 然后维护另一个 unordered_map<char, int> window 记录我们当前的窗口内字符的出现个数情况; 这里 window 窗口内包含了其他字符出现次数统计, 所以我们还需要另一个字段 valid 区标记已经有多少个字符是满足 need 的情况, 当 valid == need.size() 我们判定能完全满足<br>2.因为我们需要记录下来最小的覆盖子串的字符串, 最简单的方法是记录下来满足条件的时候的位置, 以及是当前覆盖子串长度; 然后不断更新这个长度;<br>3.我们再理一下思路: 先对 t 字符扫描进 need 统计需要的情况; 左右指针从 0 处初始化, 右边指针持续向右扫, 如果存在在当前的字符里面, 满足在 need 中需要, 那么就对 window[rc] += 1, 然后再判断是否满足覆盖的条件, valid == need.size(), 如果满足那么就尝试更新长度, 并且判断左边界缩减, 左边界缩减的条件是什么? 左指针所在的字符是需要的字符中的, —valid, 且窗口中 —window[lc]  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  string minWindow(string s, string t) &#123;
    int l = 0;
    int r = 0;
    unordered_map&lt;char, int&gt; need;
    unordered_map&lt;char, int&gt; window;
    for (auto c: t) &#123;
      ++need[c];
    &#125;
    int valid = 0;              // valid 记录有多少个独立的字符是满足计数条件的
    int len = s.size();
    int ansStart = 0;
    int ansLen = s.size() + 1;  // 初始化默认按照最长长度 + 1来
    while (r &lt; len) &#123;
      char rc = s[r];
      ++r;
      if (need.count(rc)) &#123;
        ++window[rc];
        if (window[rc] == need[rc]) &#123;
          ++valid;
        &#125;
      &#125;
      while (valid == need.size()) &#123;
        if (r - l &lt; ansLen) &#123;
          ansStart = l;
          ansLen = r - l;
        &#125;
        char lc = s[l];
        ++l;
        if (need.count(lc)) &#123;
          if (window[lc] == need[lc]) &#123;
            --valid;
          &#125;
          --window[lc];
        &#125;
      &#125;
    &#125;
    return ansLen == s.size() + 1 ? &quot;&quot; : s.substr(ansStart, ansLen);
  &#125;
&#125;;
</code></pre>
<h2 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h2><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53.最大子数组和"></a>53.最大子数组和</h2><blockquote>
<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组 是数组中的一个连续部分。</p>
<p>示例 1：输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p>
<p>示例 2：输入：nums = [1] 输出：1  </p>
<p>示例 3：输入：nums = [5,4,-1,7,8] 输出：23</p>
</blockquote>
<p>分析:<br>因为数组是有正有负的, 这里定义的状态是, 以 nums[i] 为结尾的最大子数组和为dp[i], 那么dp [i] 怎么做选择<br>1.nums[i] 自成一派 dp[i] = nums[i]<br>2.nums[i] 和之前的数组 dp[i-1] 合并起来, 即 dp[i] = dp[i-1] + nums[i]<br>状态转移汇总: dp[i] = max(nums[i], dp[i-1] + nums[i])  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;
    int len = nums.size();
    if (len &lt;= 0) &#123;
      return 0;
    &#125; 
    vector&lt;int&gt; dp(len, INT_MIN);
    dp[0] = nums[0];
    int ans = dp[0];
    for (int i = 1; i &lt; len; ++i) &#123;
      // dp[i], 表示以 i 为结尾的最大连续子数组和
      // 状态转移: 要么是和前面的加起来最大, 要么自成一派最大
      dp[i] = max(dp[i - 1] + nums[i], nums[i]);
      ans = max(dp[i], ans);
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a>56.合并区间</h2><blockquote>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<p>示例 1：输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>
<p>示例 2：输入：intervals = [[1,4],[4,5]] 输出：[[1,5]] 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p>
</blockquote>
<p>分析:<br>1.对所有的区间的左端点先排序<br>2.新增一个 merged 空数组, 然后遍历排序后的数组, 逐个加入到数组里面, 怎么依次往里面 merge 呢?<br>(i). 如果当前区间 cur 的左边的端点比 merged 数组中最后一个区间的右端点还大, 那么我们直接放入到 merged 末尾<br>(ii). 如果当前区间 cur 的左边端点比 merged 数组最后一个 区间 的右端点小, 那么更新最后一个数组的右端点更新成 max(cur<em>右端点, last</em>右端点)  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;
    int len = intervals.size();
    vector&lt;vector&lt;int&gt;&gt; merged;
    if (len &lt;= 0) &#123;
      return merged;
    &#125;
    auto cmp = [] (const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;
      return a[0] &lt; b[0];
    &#125;;
    sort(intervals.begin(), intervals.end(), cmp);
    merged.push_back(intervals[0]);
    for (int i = 1; i &lt; len; ++i) &#123;
      int l = intervals[i][0];
      int r = intervals[i][1];
      int lastR = merged.back()[1];
      // 如果当前区间的左端点 比 最后一个区间的右端点还大, 直接放到最后一个, 没有重合无需合并
      if (l &gt; lastR) &#123;
        merged.push_back(&#123;l, r&#125;);
      // 否则将 cur区间 和最后一个区间合并
      &#125; else &#123;
        merged.back()[1] = max(merged.back()[1], r);
      &#125;
    &#125;
    return merged;
  &#125;
&#125;;
</code></pre>
<h2 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189.轮转数组"></a>189.轮转数组</h2><blockquote>
<p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>
<p>示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4]<br>解释:<br>向右轮转 1 步: [7,1,2,3,4,5,6]<br>向右轮转 2 步: [6,7,1,2,3,4,5]<br>向右轮转 3 步: [5,6,7,1,2,3,4]</p>
<p>示例 2: 输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100]<br>解释:<br>向右轮转 1 步: [99,-1,-100,3]<br>向右轮转 2 步: [3,99,-1,-100]</p>
</blockquote>
<p>分析:<br>1.向右旋转有个 k 个位置的效果有个先分步反转然后整体反转的等效作用方式, 把反转过程分解成分开2个部分反转结果的反转<br>2.理解过程如下:<br>数组是           ——-&gt;—&gt;  k = 3 (1)<br>翻转完成的效果是   —&gt;——-&gt;        (2)<br>这个可以怎么从效果 (1) 到效果 (2) 呢? 我们可以分别将整个数组分成两个部分分别反转j<br>——-&gt;  反转后得到  &lt;——-<br>—&gt; 反转后得到 &lt;—<br>然后我们现在得到的是 &lt;——-&lt;—      (3)<br>我们发现我们要的 (2) 和 现在得到的(3) 是个对称图形, 如果对 (3) 整体翻转一下, 就得到了我们要的 (2) 的效果</p>
<p>3.一开始额外判断一下 k 是否是 nums.size() 的倍数, 可以直接取模, 化简运算  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;
    int len = nums.size();
    if (len &lt;= 0) &#123;
      return;
    &#125;
    k %= len;
    if (k == 0) &#123;
      return;
    &#125;
    reverse(nums.begin(), nums.end() - k);  // 反转 k 之前的
    reverse(nums.end() - k, nums.end());    // 反转 k 之后的
    reverse(nums.begin(), nums.end());
    return;
  &#125;
&#125;;
</code></pre>
<h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238.除自身以外数组的乘积"></a>238.除自身以外数组的乘积</h2><blockquote>
<p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<p>示例 1: 输入: nums = [1,2,3,4] 输出: [24,12,8,6]</p>
<p>示例 2: 输入: nums = [-1,1,0,-3,3] 输出: [0,0,9,0,0]</p>
</blockquote>
<p>分析:<br>1.我们不妨想一下出题人想考我们什么, 想要 [除自身以外数组的乘积] 可以直接全部乘起来然后除以 [自身], 但是这种直觉的想法有个问题是无法处理自身为 0 的问题, 所以提示了不要使用除法<br>2.思路上很类似于接雨水的思路, 我们首先构造一个左侧乘积数组, 对于某个元素 i 来说, lProduct[i] 是它严格左侧所有的乘积; 同理右侧侧乘积数组 rProduct[i] 是它严格右侧所有的乘积, 然后遍历取 lProduct[i] * rProduct[i]; 对于边界条件设定 lProduct[0] = 1 = rProduct[len - 1]</p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;
    int len = nums.size();
    vector&lt;int&gt; lProduct(len, 1); // 存储左侧所有元素乘积
    vector&lt;int&gt; rProduct(len, 1); // 存储右侧所有元素乘积
    vector&lt;int&gt; ans(len, 0);
    for (int i = 1; i &lt; len; ++i) &#123;
      lProduct[i] = lProduct[i-1] * nums[i-1];
    &#125;
    for (int i = len - 2; i &gt;= 0; --i) &#123;
      rProduct[i] = rProduct[i+1] * nums[i+1];
    &#125;
    for (int i = 0; i &lt; len; ++i) &#123;
      ans[i] = lProduct[i] * rProduct[i];
    &#125;
    return ans; 
  &#125;
&#125;;
</code></pre>
<h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41.缺失的第一个正数"></a>41.缺失的第一个正数</h2><blockquote>
<p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p>
<p>示例 1：输入：nums = [1,2,0] 输出：3</p>
<p>示例 2：输入：nums = [3,4,-1,1] 输出：2</p>
<p>示例 3：输入：nums = [7,8,9,11,12] 输出：1</p>
</blockquote>
<p>分析:<br>1.题目要求 O(n) 时间 和 O(1) 空间; 如果没有限制这个我们估计怎么做, 遍历放哈希表, 然后从1开始枚举看哪个不存在在哈希表, 但是会引入到 O(n) 空间<br>2.这个题目需要引入一种原地哈希的思路, 在原始的数组中修改, 这样才能不引入额外的空间<br>3.对于一个长度为 N 的数组, 未出现的最小正数的范围在 [1, N+1], 如果 [1,N] 都出现了, 那么第一个没出现的正数就是 N+1; 否则就是在 [1, N] 中没有出现的最小正整数; 所以我们想对 [1, N] 范围的数放入哈希表<br>4.怎么把 [1, N] 范围的数放入哈希表, 但是有不建立新的哈希表呢? 放在原始的数组里面: 我们对数组进行遍历, 对于遍历到的数字 x, 如果它在 [1, N] 范围内, 那么就将 x - 1 这个[位置] 打上 [某种标记], 因此遍历结束之后, 如果所有 [位置] 都有标记, 那么缺失的就是 N+1 这个数字; 否则就是没有打上标记的的位置 + 1 这个数字就是第一个缺失的正数<br>5.举个例子, 数组长度是 5, 我们对于数字 1, 我们对 0 位置上打标记, 全打完所有标记之后, 没打上标记的位置就是 + 1, 就是缺失的数字: 比如我们发现, 我们在 2 位置没有标记, 那么就说明 3 这个数字缺失了<br>6.到此为止, 我们只需要设计某种标记的规则, 就能完成上面的操作; 对于负数, 这种不在我们考虑的范围内, 只需要排除它对我们后续的干扰就行, 这里一种设计方法是打一个较大的正数 N + 2, 这样数组里面的数字就都是正数了, 遍历数字的时候, 如果绝对值 超出 N 的一律不考虑<br>7.我们可以将 [标记] 的产生, 设置成 打了[负号] 的 [负数], 也称为 [负数标记]; 比如一个数字 3, 我们让它在 nums[2] 位置上的负数 -nums[2]<br>8.举个完整的例子:<br> 3,4,-1, 1, 9,-5    第一步, n = 6 将负数替换成 n + 2 = 8<br> 3,4, 8, 1, 9, 8    第二步, 做完上一步所有数字都是正数了, 对所有不大于 6 的数字, 标记为负数, 标记的方法是 nums[num - 1] = - 原始数字的绝对值<br>-3,4,-8,-1, 9, 8    第三步, 做完上一步已经标记好正数了, 如果现在还有正数就是缺失的那个数字, 缺失数字对应的是 i + 1  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;
    int len = nums.size();
    // 把负数都标记成 len + 2, 至少是标记为 len + 1
    for (int&amp; x: nums) &#123;
      if (x &lt;= 0) &#123;
        x = len + 2;
      &#125;
    &#125;
    for (int i = 0; i &lt; len; ++i) &#123;
      int num = abs(nums[i]);   // 先取出来绝对值, 用于下面判断这个数之前不是负数
      // 对剩下的真正的正数 (之前的负数不需要再考虑), 也就是 num &lt;= len 的数, 搞上 [负数标记]
      if (num &lt;= len) &#123;
        nums[num - 1] = -abs(nums[num - 1]); // 打上负数标记, 直接对这个数字取一个负数;
      &#125;
    &#125;
    // 遍历已经打好标记的结果, 找第1个剩下的正数, 找到了, 那么就返回 i + 1
    // 第一个大于 0 的数 index + 1 就是缺失正数
    for (int i = 0; i &lt; len; ++i) &#123;
      if (nums[i] &gt; 0) &#123;
        return i + 1;
      &#125;
    &#125;
    // 如果遍历完找不到, 那么第 1 个缺失的正数就是 len + 1
    return len + 1;
  &#125;
&#125;;
</code></pre>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h2 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73.矩阵置零"></a>73.矩阵置零</h2><blockquote>
<p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。</p>
<p>示例 1：输入：matrix = [<br>[1,1,1],<br>[1,0,1],<br>[1,1,1]<br>]<br>输出：[<br>[1,0,1],<br>[0,0,0],<br>[1,0,1]<br>]</p>
<p>示例 2：输入：matrix = [<br>[0,1,2,0],<br>[3,4,5,2],<br>[1,3,1,5]<br>]<br>输出：[<br>[0,0,0,0],<br>[0,4,5,0],<br>[0,3,1,0]<br>]</p>
</blockquote>
<p>分析:<br>1.如果扫描每个位置, 扫到 0 之后再去动所在的行和列, 每个位置和其他位置置为零的过程有较多重复操作<br>2.采用空间换时间的思想, 开一个数组标记哪一行哪一列是有 0 的, 全标记完再开始根据标记结果去设置 0<br>(i). 我们先扫描一遍矩阵, 并用引入两个额外的数组去标记, 这行和这列是否存在过 0<br>(ii). 然后再扫描一遍矩阵, 如果存在这行或者这列为 0 的情况, 那么全部标记为 0  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
    int m = matrix.size();
    int n = matrix[0].size();
    vector&lt;bool&gt; rowHasZeroFlag(m, false);
    vector&lt;bool&gt; colHasZeroFlag(n, false);
    for (int i = 0; i &lt; m; ++i) &#123;
      for (int j = 0 ; j &lt; n; ++j) &#123;
        if (matrix[i][j] == 0) &#123;
          rowHasZeroFlag[i] = true;
          colHasZeroFlag[j] = true;
        &#125;
      &#125;
    &#125;
    for (int i = 0; i &lt; m; ++i) &#123;
      for (int j = 0 ; j &lt; n; ++j) &#123;
        if (rowHasZeroFlag[i] || colHasZeroFlag[j]) &#123;
          matrix[i][j] = 0;
        &#125;
      &#125;
    &#125;
    return;
  &#125;
&#125;;
</code></pre>
<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54.螺旋矩阵"></a>54.螺旋矩阵</h2><blockquote>
<p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p>
<p>示例 1：输入：<br>matrix = [<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>] 输出：[1,2,3,6,9,8,7,4,5]</p>
<p>示例 2：输入：<br>matrix = [<br>  [1,2,3,4],<br>  [5,6,7,8],<br>  [9,10,11,12]<br>] 输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
</blockquote>
<p>分析:<br>1.模拟旋转的过程, 维护上下左右四个终极边界, left, right, top, bottom, 然后在旋转过程中缩小边界, 直到边界发生某种重合; 向右和向下是必有的, 但是有时候向左和向上不是必须的, 因此需要一个判断; 判断可以回转的情况是两个边界不重合, 也就是 left &lt; right &amp;&amp; top &lt; bottom<br>2.每次单项移动的时候, 都是卡着一个边界去移动  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
    vector&lt;int&gt; ans;
    if (matrix.size() == 0 || matrix[0].size() == 0) &#123;
      return ans;
    &#125;
    int rowNum = matrix.size();
    int colNum = matrix[0].size();
    // left/right/top/bottom 模拟当前可执行螺旋的四个方向的边界
    int left = 0;
    int right = colNum - 1;
    int top = 0;
    int bottom = rowNum - 1;
    while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;
      for (int c = left; c &lt;= right; ++c) &#123;
        ans.push_back(matrix[top][c]);
      &#125;
      for (int r = top + 1; r &lt;= bottom; ++r) &#123;
        ans.push_back(matrix[r][right]);
      &#125;
      // 在需要缩小的情况下
      if (left &lt; right &amp;&amp; top &lt; bottom) &#123;
        // 先往左缩小
        for (int c = right - 1; c &gt; left; --c) &#123;
          ans.push_back(matrix[bottom][c]);
        &#125;
        // 再向上缩小
        for (int r = bottom; r &gt; top; --r) &#123;
          ans.push_back(matrix[r][left]);
        &#125;
      &#125;
      // 缩小一圈边界
      ++left;
      --right;
      ++top;
      --bottom;
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.旋转图像</h2><blockquote>
<p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。<br>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<p>示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[[7,4,1],[8,5,2],[9,6,3]]</p>
<p>示例 2： 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p>
</blockquote>
<p>分析:<br>1.图像是顺时针旋转了90度, 不太好直接看出来旋转后的对应关系, 可以尝试水平翻转, 垂直翻转，或者转置等操作的组合; 看一下翻转一步之后，距离目标状态还能怎么操作一下就能达到同样的效果<br>2.<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>]<br>先以中间一行为轴, 上下对称做个翻转<br>[<br>  [7,8,9],<br>  [4,5,6]<br>  [1,2,3],<br>]<br>然后做一个转置<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]<br>3.总结翻转的公式<br>水平线上下翻转: matrix[row][col] =&gt; matrix[n-row-1][col]<br>转置操作: matrix[row][col] =&gt; matrix[col][row]</p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
    int n = matrix.size();
    // 沿着水平线上下翻转
    for (int i = 0; i &lt; n / 2; ++i) &#123;
      for (int j = 0; j &lt; n; ++j) &#123;
        swap(matrix[i][j], matrix[n - i - 1][j]);
      &#125;
    &#125;
    // 矩阵转置操作
    for (int i = 0; i &lt; n; ++i) &#123;
      for (int j = 0; j &lt; i; ++j) &#123;
        swap(matrix[i][j], matrix[j][i]);
      &#125;
    &#125;
    return;
  &#125;
&#125;;
</code></pre>
<h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240.搜索二维矩阵 II"></a>240.搜索二维矩阵 II</h2><blockquote>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。每列的元素从上到下升序排列</p>
<p>示例 1：输入：matrix = [<br>  [1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]<br>  ], target = 5 输出：true  </p>
<p>示例 2：输入：matrix = [<br>  [1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]<br>  ], target = 20 输出：false  </p>
</blockquote>
<p>分析:<br>1.二维矩阵搜索, 其实这个搜索也是有序的, 从上到下, 从左往右有序, 最小的永远在左上角, 最大的永远在右下角, 但是右上角和左下角哪个更大我们不知道<br>2.最基础的方法可以对逐行进行二分搜索, 每一行是 logn复杂度, 总时间复杂度 nlogn  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;
    int rowNum = matrix.size();
    for (int row = 0; row &lt; rowNum; ++row) &#123;
      if (binary_search(matrix[row].begin(), matrix[row].end(), target)) &#123;
        return true;
      &#125;
    &#125;
    return false;
  &#125;
&#125;;
</code></pre>
<p>3.这个矩阵的特点我们得充分利用下, 因为右边总比左边大, 下边总比上边大, 我们可以先卡一个最大的子坐标, 另一个从 0 开始搜索, 比如从右上角 (0, n - 1) 元素开始搜索, 如果当前搜索元素比目标元素小, 那么就往下搜索, 纵坐标不动; 如果当前搜索元素比目标元素大, 那么就缩小右边界  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;
    int rowNum = matrix.size();
    int colNum = matrix[0].size();
    int x = 0; 
    int y = colNum - 1; 
    while (x &lt; rowNum &amp;&amp; y &gt;= 0) &#123;
      if (matrix[x][y] == target) &#123;
        return true;
      &#125; else if (matrix[x][y] &lt; target) &#123;
        ++x;
      &#125; else if (matrix[x][y] &gt; target) &#123;
        --y;
      &#125;
    &#125;
    return false;
  &#125;
&#125;;
</code></pre>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h2><blockquote>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。<br>图示两个链表在节点 c1 开始相交：<br>题目数据 保证 整个链式结构中不存在环。<br>注意，函数返回结果后，链表必须 保持其原始结构 。<br>自定义评测：<br>评测系统 的输入如下（你设计的程序 不适用 此输入）：<br>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0<br>listA - 第一个链表<br>listB - 第二个链表<br>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数<br>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数<br>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p>
<p>示例 1：<br>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。<br>— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</p>
<p>示例 2：<br>输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Intersected at ‘2’<br>解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。<br>在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p>
<p>示例 3：<br>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。<br>由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 null 。</p>
</blockquote>
<p>分析:<br>1.这个题如果看了答案只能感觉很巧妙, 但是不看答案又想不出来这个巧妙的答案, 先用比较基础的方法: 用一个 hashset 保存 headA 下的所有节点, 然后和另一个链表逐个对比就能找到公共节点, 但是需要额外的空间<br>2.需要充分利用”相交”这个信息, 一种解决的方式是, 将两条链表按照前后两种不同的顺序拼接在一起, 例如如下的两条链表公共节点是c1<br>a1-&gt;a2-&gt;c1-&gt;c2<br>b1-&gt;b2-&gt;b3-&gt;c1-&gt;c2<br>拼接之后得到两条长度相同的链表<br>a1-&gt;a2-&gt;c1-&gt;c2-&gt;b1-&gt;b2-&gt;b3-&gt;c1-&gt;c2<br>b1-&gt;b2-&gt;b3-&gt;c1-&gt;c2-&gt;a1-&gt;a2-&gt;c1-&gt;c2<br>这样我们同时遍历这两个链表, 找到的第一个相同的节点就是 c1 就是链表交点<br>3.在实际遍历的时候, 可以想象这两个链表已经被拼接起来, 但不实际地去开辟额外空间, 只在原来的两条链表上面走  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;
    ListNode* pa = headA;
    ListNode* pb = headB;
    while (pa != pb) &#123;
      if (pa) &#123;
        pa = pa -&gt; next;
      &#125; else &#123;
        // 将pa链接在b的开头
        pa = headB;
      &#125;
      if (pb) &#123;
        pb = pb -&gt; next;
      &#125; else &#123;
        // 将pb链接在b的开头
        pb = headA;
      &#125;
    &#125;
    return pa;
  &#125;
&#125;;
</code></pre>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><blockquote>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p>示例 1：输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1]</p>
<p>示例 2：输入：head = [1,2] 输出：[2,1]</p>
<p>示例 3：输入：head = [] 输出：[]</p>
</blockquote>
<p>分析:<br>1.迭代:<br>反转的核心操作, 是要把当前的节点指向它前一个节点, 但是我们得迭代, 所以需要先记下来它前一个是谁和后一个是谁, 然后执行迭代操作更新, 因此就是用三个指针 pre, cur, next 这3个就能完成<br>原始状态 1 -&gt; 2 -&gt; 3 -&gt; nullptr<br>目标状态 nullptr &lt;- 1 &lt;- 2 &lt;- 3, 假设我们要操作 2 这个节点的反转 1 -&gt; 2 -&gt; 3 得到 1 &lt;- 2 -&gt; 3, 关键操作是将当前的节点反向指向它的前一个节点, 也就是cur -&gt; next = pre, 同时为了能迭代我们首先要记下来下一个节点, 然后再实施关键翻转操作  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  ListNode* reverseList(ListNode* head) &#123;
    if (head == nullptr || head-&gt;next == nullptr) &#123;
      return head;
    &#125;
    ListNode* pre = nullptr;
    ListNode* cur = head;
    ListNode* next = nullptr;
    while (cur != nullptr) &#123;
      next = cur-&gt;next;   // 先记下来它下一个是谁, 不然反转完当前之后, 没法走到下一个反转流程
      cur-&gt;next = pre;    // 执行核心的反转操作
      pre = cur;          // 执行迭代
      cur = next;         // 执行迭代
    &#125;
    return pre;
  &#125;
&#125;;
</code></pre>
<p>2.递归操作<br>想一下假设只有一个节点需要反转, 后面的都已经反转好了, 就差一步大功告成, 应该怎么反转?  </p>
<p>1 -&gt; [2 -&gt; 3 -&gt; 4 -&gt; nullptr]<br>1 -&gt; [nullptr &lt;- 2 &lt;- 3 &lt;- 4] 此时 newHead 指向4  让 1-&gt;next-&gt;next 指向1<br>1 &lt;- [2 &lt;- 3 &lt;- 4] 得到左边的结果, 但还差一步 1-&gt;next = nullptr<br>nullptr &lt;- 1 &lt;- [2 &lt;- 3 &lt;- 4]</p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  ListNode* reverseList(ListNode* head) &#123;
    if (head == nullptr || head-&gt;next == nullptr) &#123;
      return head;
    &#125;
    ListNode* newHead = reverseList(head-&gt;next);
    head-&gt;next-&gt;next = head;
    head-&gt;next = nullptr;
    return newHead;
  &#125;
&#125;;
</code></pre>
<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h2><blockquote>
<p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
<p>示例 1：输入：head = [1,2,2,1] 输出：true</p>
<p>示例 2：输入：head = [1,2] 输出：false</p>
</blockquote>
<p>分析:<br>1.找到链表的中点, 然后反转后半部分, 用半部分和后半部分遍历, 先准备个反转链表和找到中点的操作, 反转链表写递归的更快, 找到中点用快慢指针一次遍历  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  ListNode* reverse(ListNode* head) &#123;
    if (head == nullptr || head-&gt;next == nullptr) &#123;
      return head;
    &#125;
    ListNode* newHead = reverse(head-&gt;next);
    head-&gt;next-&gt;next = head;
    head-&gt;next = nullptr;
    return newHead;
  &#125;
  ListNode* findMidNode(ListNode* head) &#123;
    ListNode* slow = head; 
    ListNode* fast = head; 
    while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;
      slow = slow-&gt;next;
      fast = fast-&gt;next-&gt;next;
    &#125;
    return slow;
  &#125;
  bool isPalindrome(ListNode* head) &#123;
    if (head == nullptr || head-&gt;next == nullptr) &#123;
      return true;
    &#125;
    ListNode* mid = findMidNode(head);
    ListNode* p1 = head;
    ListNode* p2 = reverse(mid);
    while (p1 != nullptr &amp; p2 != nullptr) &#123;
      if (p1-&gt;val != p2-&gt;val) &#123;
        return false;
      &#125;
      p1 = p1-&gt;next;
      p2 = p2-&gt;next;
    &#125;
    return true;
  &#125;
&#125;;
</code></pre>
<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h2><blockquote>
<p>给你一个链表的头节点 head ，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<p>示例 1：输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>示例 2：输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。</p>
</blockquote>
<p>分析:<br>1.快慢指针, 相遇就有环, 否则没环  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  bool hasCycle(ListNode *head) &#123;
    if (!head || !head-&gt;next) &#123;
      return false;
    &#125;
    ListNode* slow = head;
    ListNode* fast = head-&gt;next;
    while (fast &amp;&amp; fast-&gt;next) &#123;
      slow = slow-&gt;next;
      fast = fast-&gt;next-&gt;next;
      if (fast == slow) &#123;
        return true;
      &#125;
    &#125;
    return false;
  &#125;
&#125;;
</code></pre>
<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142.环形链表 II"></a>142.环形链表 II</h2><blockquote>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。不允许修改 链表。</p>
<p>示例 1：输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>示例 2：输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。</p>
<p>示例 3：输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。</p>
</blockquote>
<p>分析:<br>1.需要分析下相遇点有什么特点, 我们仍然采用快慢指针的方式来看, 起点快慢指针都指向非空的 head, 假设 slow 走了 k 步之后, fast 和 slow 相遇了, slow 走 k 步, 那么 fast 走 2k 步; fast 比 slow 多走出的 k 步是在环里面转圈, 所以这个相遇时候慢指针走过的 k 步的 k 的值正好就是环长度的 [整数倍]<br>2.假设 [相遇点] 距离 [环起点] 为 m , 原始头节点距离 [环起点] 为 k - m , fast 如果继续往前走 k - m 步到达环的起点, 但是我们不知道这个 m 是多少; 这里我们知道, 相遇之后原始头结点距离 [环起点] 距离 == [相遇点] 距离 [环起点] 继续走距离都是 k - m; 所以我们让快慢指针第一次相遇的时候, 让快慢指针的任意一个重新指向 head, 比如 slow 重新指向 head, 然后 slow 和 fast 指针同速前进 (每次走1步), (经过 k - m 步) 然后它俩一定相遇, 相遇的地方就是环的起点  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  ListNode *detectCycle(ListNode *head) &#123;
    ListNode* slow = head;
    ListNode* fast = head;
    // 假设 [相遇点] 距离 [环起点] 为 m , 原始头节点距离 [环起点] 为 k - m , fast 如果继续往前走 k - m 步到达环的起点, 我们不知道这个 m 是多少; 
    // 相遇之后原始头结点距离 [环起点] 距离 == [相遇点] 距离 [环起点] 继续走距离都是 k - m; 
    // 我们让快慢指针第一次相遇的时候, 让快慢指针的任意一个重新指向 head, 比如 slow 重新指向 head, 然后 slow 和 fast 指针同速前进 (每次走1步), (经过 k - m 步) 然后他俩一定相遇, 相遇的地方就是环的起点;
    while (fast &amp;&amp; fast-&gt;next) &#123;
      slow = slow-&gt;next;
      fast = fast-&gt;next-&gt;next;
      if (slow == fast) &#123;
        slow = head;
        while (slow != fast) &#123;
          slow = slow-&gt;next;
          fast = fast-&gt;next;
        &#125;
        return slow;
      &#125;
    &#125;
    return nullptr;
  &#125;
&#125;;
</code></pre>
<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h2><blockquote>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例 1：输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4]</p>
<p>示例 2：输入：l1 = [], l2 = [] 输出：[]</p>
<p>示例 3：输入：l1 = [], l2 = [0] 输出：[0]</p>
</blockquote>
<p>分析:<br>1.合并有序链表的操作关键操作是分别用两个指针维护当前列表 list1/list2 的指针 p1 和 p2, 然后再用一个指针维护合并的指针, 这个合并指针好像一个针线头一样, 把两条线穿起来<br>2.先处理 p1 和 p2 同时非空的场景, 然后再处理剩下的唯一的链表有剩余的场景<br>3.为了方便处理有链表为空的情况, 额外设置一个 dummy 节点, 返回 dummy-&gt;next  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;
    ListNode* dummy = new ListNode(-1);
    ListNode* cur = dummy;
    ListNode* p1 = list1;
    ListNode* p2 = list2;
    while (p1 &amp;&amp; p2) &#123;
      if (p1-&gt;val &lt; p2-&gt;val) &#123;
        cur-&gt;next = p1;
        p1 = p1-&gt;next;
      &#125; else &#123;
        cur-&gt;next = p2;
        p2 = p2-&gt;next;
      &#125;
      cur = cur-&gt;next;
    &#125;
    if (p1) &#123;
      cur-&gt;next = p1;
    &#125;
    if (p2) &#123;
      cur-&gt;next = p2;
    &#125;
    return dummy-&gt;next;
  &#125;
&#125;;
</code></pre>
<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h2><blockquote>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例 1：输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807.</p>
<p>示例 2：输入：l1 = [0], l2 = [0] 输出：[0]</p>
<p>示例 3：输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1]</p>
</blockquote>
<p>分析:<br>1.纯模拟实现, 注意各种进位的判断, 可以先处理两个链表同时有节点的情况, 再单独处理一个链表有节点的情况, 然后再处理最后的一个进位的情况  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;
    ListNode* dummy = new ListNode(-1);
    ListNode* cur = dummy;
    ListNode* p1 = l1;
    ListNode* p2 = l2;
    int sum   = 0;
    int data  = 0;
    int carry = 0;
    while (p1 &amp;&amp; p2) &#123;
      sum = p1-&gt;val + p2-&gt;val + carry;
      data = sum % 10;
      carry = sum / 10;
      ListNode* tmp = new ListNode(data);
      cur-&gt;next = tmp;
      p1 = p1-&gt;next;
      p2 = p2-&gt;next;
      cur = cur-&gt;next;
    &#125;
    ListNode* p = (p1) ? p1 : p2;
    while (p) &#123;
      sum = p-&gt;val + carry;
      data = sum % 10;
      carry = sum / 10;
      p-&gt;val = data;
      cur-&gt;next = p;
      cur = cur-&gt;next;
      p = p-&gt;next;
    &#125;
    if (carry &gt; 0) &#123;
      ListNode* finalNode = new ListNode(carry);
      cur-&gt;next = finalNode;
      cur = cur-&gt;next;
    &#125;
    return dummy-&gt;next;
  &#125;
&#125;;
</code></pre>
<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19.删除链表的倒数第 N 个结点"></a>19.删除链表的倒数第 N 个结点</h2><blockquote>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>示例 1：输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]</p>
<p>示例 2：输入：head = [1], n = 1 输出：[]</p>
<p>示例 3：输入：head = [1,2], n = 1 输出：[1]</p>
</blockquote>
<p>分析:<br>1.如果要删除倒数第 N 个节点, 也就是删除正数 nums-N+1 个节点, 为了删除 nums-N+1 的节点, 我们需要指针指向删除目标节点的前一个节点, 即正数 nums-N 个节点, 也就是倒数 N+1 个节点<br>2.一种方法是遍历一遍找到 N 等于几, 然后再遍历一遍执行删除操作<br>3.更方便的一种方式是先让 fast 先正好走到我们想要 slow 停下来的节点, 也就是待删除的节点的前一个节点, 然后再快慢同速度一起走, 直到 fast 为空, 这时候 slow 停下来的节点就是正数 nums-N 个节点; 其实我们脑洞开一点, 就好比等价于有另一个指针 (fast) 先执行倒着走一样, 它能先帮我们找到那个前一个节点<br>4.假设 [1,2,3,4,5], n=2, 为了防止空指针出现, 比如 5 个节点删除倒数第 5 个, 要用 dummy 去避免空指针; fast 指针可以从 head 开始, 然后 slow 指针多走一步从 dummy 开始, 这样就能直接达到走到待删除节点的下一个节点的效果; 增加 dummy 得到 [d,1,2,3,4,5], 所以, fast 从 1 出发走 2 步到 3, 然后走 3 步到空指针, slow 从 dummy 出发走 3 步到 3, 也就是 4 的前1个节点  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  ListNode* removeNthFromEnd(ListNode* head, int n) &#123;
    ListNode* dummy = new ListNode(-1, head);
                             // 举例 [d,1,2,3,4,5], n=2, fast 停在3, slow 最终停在3
    ListNode* slow = dummy;  // slow 从 dummy 出发, 能够多走一步, 保证 slow 最终停在待删除节点前面
    ListNode* fast = head;   // fast 从 head 出发
    for (int i = 0; i &lt; n; ++i) &#123;
      fast = fast-&gt;next;
    &#125;
    while (fast) &#123;
      slow = slow-&gt;next;
      fast = fast-&gt;next;
    &#125;
    slow-&gt;next = slow-&gt;next-&gt;next;
    ListNode* ans = dummy-&gt;next;
    delete dummy;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h2><blockquote>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p>示例 1：输入：head = [1,2,3,4] 输出：[2,1,4,3]</p>
<p>示例 2：输入：head = [] 输出：[]</p>
<p>示例 3：输入：head = [1] 输出：[1]</p>
</blockquote>
<p>分析:<br>1.这个题意是想让我们按照每两个一组交换节点, 需要画图在纸上才能看清楚指针的变动顺序;<br>2.先设置一个 dummy, dummy-&gt;next = head:<br>3.我们尝试反转第一组, 因为需要一个前置节点才能开始连接, 因此声明一个 pre, 一开始pre = dummy;<br>先取出来 node1 和 node2<br>pre-&gt;next = node2;<br>node1-&gt;next = node2-&gt;next;<br>node2-&gt;next = node1;<br>pre = node1;</p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  ListNode* swapPairs(ListNode* head) &#123;
    ListNode* dummy = new ListNode(-1, head);
    ListNode* pre = dummy;
    while (pre-&gt;next != nullptr &amp;&amp; pre-&gt;next-&gt;next != nullptr) &#123;
      ListNode* node1 = pre-&gt;next;
      ListNode* node2 = pre-&gt;next-&gt;next;
      pre-&gt;next = node2;
      node1-&gt;next = node2-&gt;next;
      node2-&gt;next = node1;
      pre = node1;
    &#125;
    ListNode* ans = dummy-&gt;next;
    delete dummy;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25.K 个一组翻转链表"></a>25.K 个一组翻转链表</h2><blockquote>
<p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。<br>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<p>示例 1：输入：head = [1,2,3,4,5], k = 2 输出：[2,1,4,3,5]</p>
<p>示例 2：输入：head = [1,2,3,4,5], k = 3 输出：[3,2,1,4,5]</p>
</blockquote>
<p>分析:<br>1.如果我们对链表内任意一个区间 [left, right] 可以实施反转, 我们只需要对所有的区间实施相同的反转; 如何对链表内任意一个区间实施反转 ? 采用 [区间内头插法反转]  </p>
<pre><code class="lang-cpp">// 移动 pre 到指向区间前一个节点
for (int i = 0; i &lt; left - 1; ++i) &#123;
  pre = pre-&gt;next;
&#125;
ListNode* cur = pre-&gt;next;   // cur 节点是反转区域第1个节点, 也是反转区域最后一个节点, 始终不动
ListNode* next;              // next 是要执行头插的节点, 每次移动到反转区域的第1个元素, 并一直迭代
for (int i = 0; i &lt; right - left; ++i) &#123;
  next = cur-&gt;next;         // 找到头插节点
  cur-&gt;next = next-&gt;next;   // 隔过去待头插入的节点
  next-&gt;next = pre-&gt;next;   // 执行头插: 插入头节点到区间第1个节点
  pre-&gt;next = next;         // 链接 pre -&gt; 头插元素
&#125;
</code></pre>
<p>2.应用 [区间内头插法反转] 的操作可以对任意区间进行反转, 我们只需要对多个区间采取相同的操作; 每个[区间内头插法反转] 操作完成之后, 我们将 pre 和 cur 顺序往下移动一个区间, 再下一个区间进行 [区间内头插法]<br>3.先求出来区间的总长度; 然后一个区间一个区间地做 [区间内头插法反转]  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  ListNode* reverseKGroup(ListNode* head, int k) &#123;
    if (head == nullptr || head-&gt;next == nullptr) &#123;
      return head;
    &#125;
    ListNode* dummy = new ListNode(-1, head);
    ListNode* t = head;
    int len = 0;
    // 先求出来链表的长度
    while (t) &#123;
      ++len;
      t = t-&gt;next;
    &#125;
    ListNode* pre = dummy;
    ListNode* cur = pre-&gt;next;
    ListNode* next;
    while (len &gt;= k) &#123;
      // 执行区间内头插法反转
      for (int i = 1; i &lt; k; ++i) &#123;
        next = cur-&gt;next;
        cur-&gt;next = next-&gt;next;
        next-&gt;next = pre-&gt;next;
        pre-&gt;next = next;
      &#125;
      pre = cur;        // 下一个 pre 指向 cur 也就是区间内的最后1个元素
      cur = pre-&gt;next;  // cur 进入到新区间的第1个元素
      len -= k;
    &#125;
    return dummy-&gt;next;
  &#125;
&#125;;
</code></pre>
<h2 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138.随机链表的复制"></a>138.随机链表的复制</h2><blockquote>
<p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。<br>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。例如，如果原链表中有 X 和 Y 两个节点，其中 X.random —&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random —&gt; y 。 返回复制链表的头节点。<br>用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：<br>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。<br>你的代码 只 接受原链表的头节点 head 作为传入参数。</p>
<p>示例 1： 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p>
<p>示例 2： 输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]]</p>
<p>示例 3： 输入：head = [[3,null],[3,0],[3,null]] 输出：[[3,null],[3,0],[3,null]]</p>
</blockquote>
<p>分析:<br>1.如果没有随机指针, 我们遍历复制就行, 因为有随机指针的存在, 当我们想复制某个节点的时候, 它的随机指针指向的那个节点可能还没创建, 因此不太好复制<br>2.这里有个非常巧妙的办法, 先复制在拆分, 对于链表 a-&gt;b-&gt;c, 我们可以在每个元素之后先建一个a-&gt;a’-&gt;b-&gt;b’-&gt;c-&gt;c’, 然后我们对所有a’和b’和c’找到随机指针指向的节点是它原来节点的随机指针指向的节点对应的后继节点, 然后重新遍历一遍, 按照 [原来节点] 和 [复制节点] 拆分出来; 因为随机指针可以指向空值, 给复制节点找随机指针指向的结点的时候, 需要判断一下能否指向一个节点  </p>
<pre><code class="lang-cpp">/*
// Definition for a Node.
class Node &#123;
 public:
  int val;
  Node* next;
  Node* random;
  Node(int _val) &#123;
    val = _val;
    next = NULL;
    random = NULL;
  &#125;
&#125;;
*/
class Solution &#123;
 public:
  Node* copyRandomList(Node* head) &#123;
    if (head == nullptr) &#123;
      return nullptr; 
    &#125;
    Node* p = head;
    // 先复制串联镜像节点 a-&gt;a&#39;-&gt;b-&gt;b&#39;-&gt;c-&gt;c
    while (p != nullptr) &#123;
      Node* node = new Node(p-&gt;val);
      node-&gt;next = p-&gt;next;
      p-&gt;next = node;
      p = node-&gt;next;
    &#125;
    p = head;
    Node* cp = nullptr;
    // 给复制节点们找到对应的随机指针的正确指向
    while (p != nullptr) &#123;
      cp = p-&gt;next;
      if (p-&gt;random != nullptr) &#123;
        cp-&gt;random = p-&gt;random-&gt;next;
      &#125;
      p = cp-&gt;next;
    &#125;
    p = head;
    cp = head-&gt;next;
    Node* newHead = cp;
    // p 和 cp 各自串自己的糖葫芦
    while (cp-&gt;next != nullptr) &#123;
      p-&gt;next = cp-&gt;next;
      p = p-&gt;next;
      cp-&gt;next = p-&gt;next;
      cp = cp-&gt;next;
    &#125;
    p-&gt;next = nullptr;
    return newHead;
  &#125;
&#125;;
</code></pre>
<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148.排序链表"></a>148.排序链表</h2><blockquote>
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<p>示例 1：输入：head = [4,2,1,3] 输出：[1,2,3,4]</p>
<p>示例 2：输入：head = [-1,5,3,4,0] 输出：[-1,0,3,4,5]</p>
<p>示例 3：输入：head = [] 输出：[]</p>
</blockquote>
<p>分析:<br>1.采用分治 (归并) 的方法, 每次先找到链表的中点, 强行断开, 然后执行归并排序<br>2.每次找中点的时候, 用快慢指针找中点, 注意这里的中点是偏小的那一个, 也就是 slow 前面的 pre 指针, 这样比较适合前后断开的操作<br>3.合并的时候, 执行的是两个有序链表的合并操作<br>4.归并排序的思路 + 快慢指针找中点 + 有序链表合并之后可以完成该操作  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  ListNode* findMidNode(ListNode* head) &#123;
    if (head == nullptr || head-&gt;next == nullptr) &#123;
      return head;
    &#125;
    ListNode* slow = head;
    ListNode* fast = head;
    ListNode* pre;
    while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;
      pre = slow;
      slow = slow-&gt;next;
      fast = fast-&gt;next-&gt;next;
    &#125;
    return pre;
  &#125;
  ListNode* mergeSortedList(ListNode* list1, ListNode* list2) &#123;
    ListNode* dummy = new ListNode(-1);
    ListNode* cur = dummy;
    ListNode* p1 = list1;
    ListNode* p2 = list2;
    while (p1 != nullptr &amp;&amp; p2 != nullptr) &#123;
      if (p1-&gt;val &lt; p2-&gt;val) &#123;
        cur-&gt;next = p1; 
        p1 = p1-&gt;next;
      &#125; else &#123;
        cur-&gt;next = p2;
        p2 = p2-&gt;next;
      &#125;
      cur = cur-&gt;next;
    &#125;
    cur-&gt;next = (p1 != nullptr) ? p1 : p2;
    ListNode* ret = dummy-&gt;next;
    delete dummy;
    return ret;
  &#125;
  ListNode* sortList(ListNode* head) &#123;
    if (head == nullptr || head-&gt;next == nullptr) &#123;
      return head;
    &#125;
    ListNode* p1 = head;
    ListNode* mid = findMidNode(head);
    ListNode* p2 = mid-&gt;next;
    mid-&gt;next = nullptr;
    p1 = sortList(p1);
    p2 = sortList(p2);
    ListNode* ans = mergeSortedList(p1, p2);
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23.合并 K 个升序链表"></a>23.合并 K 个升序链表</h2><blockquote>
<p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p>示例 1：输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
<p>示例 2：输入：lists = [] 输出：[]</p>
<p>示例 3：输入：lists = [[]] 输出：[]</p>
</blockquote>
<p>分析:<br>1.如果是合并 2 个升序链表, 我们可以维护两个指针去比较, 如果是 k 个链表, 则不太好比较<br>2.如果想维护 k 个链表里面的最小值, 那么需要引入一个小顶堆去找到最小节点, 来多少个链表我们都不管, 我们每次都取最小的那个节点: 每次取出来最小的那个节点, 然后链接到生成的链表的末尾, 看下后续还有无其他的节点, 有的话放入队列一起比较, 直到最后队列元素为空  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;
    auto cmp = [] (ListNode* p1, ListNode* p2) &#123;
      return p2-&gt;val &lt; p1-&gt;val; 
    &#125;;
    // 采用一个按照值排序的有限队列
    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; pq;
    for (auto head: lists) &#123;
      if (head != nullptr) &#123;
        pq.push(head);
      &#125;
    &#125;
    ListNode* dummy = new ListNode(-1);
    ListNode* cur = dummy;
    while (!pq.empty()) &#123;
      cur-&gt;next = pq.top();
      pq.pop();
      cur = cur-&gt;next;
      if (cur-&gt;next != nullptr) &#123;
        pq.push(cur-&gt;next);
      &#125;
    &#125;
    ListNode* ans = dummy-&gt;next;
    delete dummy;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146.LRU 缓存"></a>146.LRU 缓存</h2><blockquote>
<p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
<p>示例：<br>输入<br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>输出<br>[null, null, null, 1, null, -1, null, -1, 3, 4]<br>解释<br>LRUCache lRUCache = new LRUCache(2);<br>lRUCache.put(1, 1); // 缓存是 {1=1}<br>lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}<br>lRUCache.get(1);    // 返回 1<br>lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}<br>lRUCache.get(2);    // 返回 -1 (未找到)<br>lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}<br>lRUCache.get(1);    // 返回 -1 (未找到)<br>lRUCache.get(3);    // 返回 3<br>lRUCache.get(4);    // 返回 4</p>
</blockquote>
<p>分析:<br>1.我们回忆一下 LRU cache 要实现什么, 首先考虑是构造一个队列, 用于模拟的访问 cache 的时间顺序关系; 另外, 因为要 O(1) 实现查找, 所以需要一个哈希表指向节点; 因为还要 O(1) 的复杂度实现插入和删除, 就需要搞一个双端链表去模拟加入的时序关系; 构造一个双端链表的中间结构</p>
<pre><code class="lang-cpp">struct DLinkedListNode &#123;
  int key;
  int value;
  DLinkedListNode* pre;
  DLinkedListNode* next;
  DLinkedListNode(): key(0), value(0) &#123;&#125;
  DLinkedListNode(int _key, int _value): key(_key), value(_value), pre(nullptr), next(nullptr) &#123;&#125;
&#125;;

class LRUCache &#123;
 private:
  int size;
  int totalCapacity;
  DLinkedListNode* dummyHead;
  DLinkedListNode* dummyTail;
  unordered_map&lt;int, DLinkedListNode*&gt; key2node;

 public:
  LRUCache(int capacity) &#123;
    size = 0;
    totalCapacity = capacity;
    dummyHead = new DLinkedListNode();
    dummyTail = new DLinkedListNode();
    dummyHead-&gt;next = dummyTail;
    dummyTail-&gt;pre = dummyHead;
  &#125;

  // 如果待查询 key 不存在, 是个无效的查询, 直接返回 -1 
  // 如果存在, 移动 key 所在的 node 到开头
  int get(int key) &#123;
    if (!key2node.count(key)) &#123;
      return -1;
    &#125;
    DLinkedListNode* node = key2node[key];
    moveNodeToHead(node);
    return node-&gt;value;
  &#125;

  // 如果待添加的 key 不存在, 加入哈希表 
  // 如果已经存在了, 移动在链表头, 重写 value
  void put(int key, int value) &#123;
    if (!key2node.count(key)) &#123;
      DLinkedListNode* node = new DLinkedListNode(key, value);
      key2node[key] = node;
      addNodeToHead(node);
      ++size;
      if (size &gt; totalCapacity) &#123;
        // 返回待删除的节点的指针
        DLinkedListNode* node = removeNodeTailNode();
        key2node.erase(node-&gt;key);
        delete node;
        --size;
      &#125;
    &#125; else &#123;
      DLinkedListNode* node = key2node[key];
      node-&gt;value = value;
      moveNodeToHead(node);
    &#125;
  &#125;
  void moveNodeToHead(DLinkedListNode* node) &#123;
    removeNode(node);
    addNodeToHead(node);
  &#125;
  // 双端操作: 先把 node 向 前后节点建立联系, 然后前后节点和 node 向 前后节点建立联系
  void addNodeToHead(DLinkedListNode* node) &#123;
    node-&gt;pre = dummyHead;
    node-&gt;next = dummyHead-&gt;next; 
    dummyHead-&gt;next-&gt;pre = node; 
    dummyHead-&gt;next = node;
  &#125;
  void removeNode(DLinkedListNode* node)  &#123;
    node-&gt;pre-&gt;next = node-&gt;next;
    node-&gt;next-&gt;pre = node-&gt;pre;
  &#125;
  DLinkedListNode* removeNodeTailNode() &#123;
    DLinkedListNode* node = dummyTail-&gt;pre; 
    removeNode(node);
    return node;
  &#125;
&#125;;
</code></pre>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h2><blockquote>
<p>给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</p>
<p>示例 1：输入：root = [1,null,2,3] 输出：[1,3,2]</p>
<p>示例 2：输入：root = [] 输出：[]</p>
<p>示例 3：输入：root = [1] 输出：[1]</p>
</blockquote>
<p>分析:<br>1.递归方法比较简单, 这里用迭代方法<br>2.迭代方法的本质是需要记录下来 [上一个访问的根节点], 因为二叉树这个结构只有向下遍历操作没法直接往回回溯, 所以需要引入栈去记录下来最近一次上一个根节点是哪个节点  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;
    vector&lt;int&gt; ans;
    if (root == nullptr) &#123;
      return ans;
    &#125;
    stack&lt;TreeNode*&gt; preRoot;
    while (root != nullptr || !preRoot.empty()) &#123;
      while (root != nullptr) &#123;
        preRoot.push(root);
        root = root-&gt;left;
      &#125;
      root = preRoot.top();
      preRoot.pop();
      ans.push_back(root-&gt;val);
      root = root-&gt;right;
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h2><blockquote>
<p>给定一个二叉树 root ，返回其最大深度。</p>
<p>二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<p>示例 1：输入：root = [3,9,20,null,null,15,7] 输出：3</p>
<p>示例 2：输入：root = [1,null,2] 输出：2</p>
<pre><code class="lang-cpp">    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回它的最大深度 3 。</p>
</blockquote>
<p>分析:<br>1.采用分解问题的思维, 当前 root 节点最大深度, 等于它的左子树最大深度和右子树最大深度之间的最大值 + 1, 因此可以写出递归代码  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  int maxDepth(TreeNode* root) &#123;
    if (root == nullptr) &#123;
      return 0;
    &#125;
    int lMaxDepth = maxDepth(root-&gt;left);
    int rMaxDepth = maxDepth(root-&gt;right);
    return max(lMaxDepth, rMaxDepth) + 1;
  &#125;
&#125;;
</code></pre>
<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h2><blockquote>
<p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p>
<p>示例 1：输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1]</p>
<p>示例 2：输入：root = [2,1,3] 输出：[2,3,1]</p>
<p>示例 3：输入：root = [] 输出：[]</p>
</blockquote>
<p>分析:<br>1.采用分解问题的思维, 原问题翻转之后的效果等于左子树翻转完, 右子树翻转完之后再左右翻转  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  TreeNode* invertTree(TreeNode* root) &#123;
    if (root == nullptr) &#123;
      return root;
    &#125;
    TreeNode* lInverted = invertTree(root-&gt;left);
    TreeNode* rInverted = invertTree(root-&gt;right);
    root-&gt;left = rInverted;
    root-&gt;right = lInverted;
    return root;
  &#125;
&#125;;
</code></pre>
<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h2><blockquote>
<p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
<p>示例 1：输入：root = [1,2,2,3,4,4,3] 输出：true</p>
<p>示例 2：输入：root = [1,2,2,null,3,null,3] 输出：false</p>
</blockquote>
<p>分析:<br>1.采用分解的思维: 对于原问题来说, 给定一个根节点, 需要判定左子树和右子树是对称的,  怎么判定左子树和右子树是对称的<br>2.要想判定左子树和右子树对称性, 需要生成两个指针来同时遍历, 一个向左一个向右, 然后1生2, 2生4, 4生成8…  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  // p 和 q 是两个同时遍历具有对称性的指针
  bool check(TreeNode* p, TreeNode* q) &#123;
    if (p == nullptr &amp;&amp; q == nullptr) &#123;
      return true;
    &#125;
    if (p == nullptr || q == nullptr) &#123;
      return false;
    &#125;
    return p-&gt;val == q-&gt;val &amp;&amp; check(p-&gt;left, q-&gt;right) &amp;&amp; check(p-&gt;right, q-&gt;left);
  &#125;
  bool isSymmetric(TreeNode* root) &#123;
    return check(root, root);
  &#125;
&#125;;
</code></pre>
<h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543.二叉树的直径"></a>543.二叉树的直径</h2><blockquote>
<p>给你一棵二叉树的根节点，返回该树的 直径 。二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。<br>两节点之间路径的 长度 由它们之间边数表示。</p>
<pre><code class="lang-cpp">      1
     / \
    2   3
   / \   
  4   5
</code></pre>
<p>示例 1：输入：root = [1,2,3,4,5] 输出：3 解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。</p>
<p>示例 2：输入：root = [1,2] 输出：1</p>
</blockquote>
<p>分析:<br>1.具体到一个根节点, 它所在的直径等于最大深度等于什么?<br>2.如果能想到对于一个根节点, 它的直径等于 [左子树数的最大深度] 和 [右子树的最大深度] 之和<br>3.我们写一个最大深度的函数, 然后不断更新这个最大深度<br>4.一个二叉树的的最大深度是怎么来的 ? 是另一个可以用分解的思维去思考的问题, 对于一个根节点来说, 它的最大深度等于 max(左子树的最大深度, 右子树的最大深度) + 1  </p>
<pre><code class="lang-cpp">class Solution &#123;
 private:
  int ans = 0;
 public:
  // 写一个求最大深度的函数
  int maxDepth(TreeNode* root) &#123;
    if (root == nullptr) &#123;
      return 0;
    &#125;
    int lMaxDepth = maxDepth(root-&gt;left);
    int rMaxDepth = maxDepth(root-&gt;right);
    // 对于一个根节点而言, 它的直径等于 [左子树数的最大深度] 和 [右子树的最大深度] 之和;
    int diameter = lMaxDepth + rMaxDepth;
    ans = max(ans, diameter);
    // 对于一个根节点而言, 最大深度等于 max(lMaxDepth, rMaxDepth) + 1;
    return max(lMaxDepth, rMaxDepth) + 1;
  &#125;
  int diameterOfBinaryTree(TreeNode* root) &#123;
    maxDepth(root);
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h2><blockquote>
<p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p>
<p>示例 1：输入：root = [3,9,20,null,null,15,7] 输出：[[3],[9,20],[15,7]]</p>
<pre><code>  3 
 / \
9   20
    / \   
  15   7
</code></pre><p>示例 2：输入：root = [1] 输出：[[1]]</p>
<p>示例 3：输入：root = [] 输出：[]</p>
</blockquote>
<p>分析:<br>1.层序遍历用队列模拟  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;
    queue&lt;TreeNode*&gt; q;
    vector&lt;vector&lt;int&gt;&gt; ans;
    if (root == nullptr) &#123;
      return ans;
    &#125;
    q.push(root);
    while (!q.empty()) &#123;
      int len = q.size();
      vector&lt;int&gt; levelVec;
      while (len &gt; 0) &#123;
        TreeNode* node = q.front();
        int val = node-&gt;val;
        q.pop();
        levelVec.push_back(val);
        if (node-&gt;left != nullptr) &#123;
          q.push(node-&gt;left);
        &#125;
        if (node-&gt;right != nullptr) &#123;
          q.push(node-&gt;right);
        &#125;
        --len;
      &#125;
      ans.push_back(levelVec);
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h2><blockquote>
<p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。<br>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<p>示例 1：输入：nums = [-10,-3,0,5,9] 输出：[0,-3,9,-10,null,5] 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</p>
<p>示例 2：输入：nums = [1,3] 输出：[3,1] 解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</p>
</blockquote>
<p>分析:<br>1.BST 的中序遍历正好是有序序列, 给定中序遍历, 能否唯一确定一个二叉搜索树? 不能, 在没限制平衡的设定下, 任何一个数字都可以作为二叉搜索树的根节点<br>2.如果我们要求二叉搜索树平衡, 是否可以确定唯一一个二叉搜索树? 也不能. 举个反例是一个节点下面各两个子树, 但是每个子树下面2个唯一分支节点, 左孩子或者右孩子各种换位置都可以满足需求<br>3.那怎么能能确定根节点, 然后保证构造出来的一定是平衡的呢? 如果数组长度是奇数, 那么中间的节点是唯一可行的根节点, 如果偶数, 那么中间位置左边或者右边都能做根节点<br>4.中间位置是 int mid = l + (r - l) / 2  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  TreeNode* construct(vector&lt;int&gt;&amp; nums, int l, int r) &#123;
    if (l &gt; r) &#123;
      return nullptr;
    &#125;
    int mid = l + (r - l) / 2;
    TreeNode* root = new TreeNode(nums[mid]);
    root-&gt;left = construct(nums, l, mid - 1);
    root-&gt;right = construct(nums, mid + 1, r);
    return root; 
  &#125;
  TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;
    return construct(nums, 0, nums.size()-1);
  &#125;
&#125;;
</code></pre>
<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h2><blockquote>
<p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。<br>有效 二叉搜索树定义如下：<br>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>
<p>示例 1：输入：root = [2,1,3] 输出：true</p>
<p>示例 2：输入：root = [5,1,4,null,null,3,6] 输出：false 解释：根节点的值是 5 ，但是右子节点的值是 4 。</p>
</blockquote>
<p>分析:<br>1.BST 的中序遍历是完全有序的, 我们利用这个性质, 中序迭代遍历二叉树, 然后发现前一个元素和后一个元素是违反有序关系的, 那么一定非BST;<br>2.迭代中序遍历, 并额外维护一个 preNode 指针, 遍历过程中每次比较 preNode 和 cur 的关系是不满足 &lt; 情况判定非BST  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  bool isValidBST(TreeNode* root) &#123;
    stack&lt;TreeNode*&gt; s;
    TreeNode* preNode = nullptr; 
    while (root != nullptr || !s.empty()) &#123;
      while (root != nullptr) &#123;
        s.push(root);
        root = root-&gt;left;
      &#125;
      root = s.top();
      s.pop();
      if (preNode != nullptr &amp;&amp; preNode-&gt;val &gt;= root-&gt;val) &#123;
        return false;
      &#125;
      preNode = root;
      root = root-&gt;right;
    &#125;
    return true;
  &#125;
&#125;;
</code></pre>
<h2 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230.二叉搜索树中第K小的元素"></a>230.二叉搜索树中第K小的元素</h2><blockquote>
<p>给定一个二叉搜索树的根节点 root， 和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p>
<p>示例 1：输入：root = [3,1,4,null,2], k = 1 输出：1</p>
<p>示例 2：输入：root = [5,3,6,2,4,null,null,1], k = 3 输出：3</p>
</blockquote>
<p>分析:<br>1.BST中序遍历正好是有序的, 因此采用中序遍历, 找到遍历数 == k 的时候, 返回, 先用递归版本 </p>
<pre><code class="lang-cpp">class Solution &#123;
 private:
  int ans = 0;
  int rank = 0;
 public:
  void traverse(TreeNode* root, int k) &#123;
    if (root == nullptr) &#123;
      return;
    &#125;
    // 前序位置
    traverse(root-&gt;left, k);
    // 搜到中序位置
    ++rank;
    if (k == rank) &#123;
      ans = root-&gt;val;
      return;
    &#125;
    // 后序位置
    traverse(root-&gt;right, k);
  &#125;
  int kthSmallest(TreeNode* root, int k) &#123;
    traverse(root, k);
    return ans;
  &#125;
&#125;;
</code></pre>
<p>同时顺便写一下迭代版本的中序遍历搜索</p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  int kthSmallest(TreeNode* root, int k) &#123;
    stack&lt;TreeNode*&gt; s;
    while (root != nullptr || !s.empty()) &#123;
      while (root != nullptr) &#123;
        s.push(root);
        root = root-&gt;left;
      &#125;
      root = s.top();
      s.pop();
      --k;
      if (k == 0) &#123;
        return root-&gt;val; 
      &#125;
      root = root-&gt;right;
    &#125;
    return 0;
  &#125;
&#125;;
</code></pre>
<p>2.假如我们频繁地查找第 k 小的值, 有没有优化方法? 我们每次采用重新中序遍历的一个前提是不知道每个根节点的子树的节点总数, 假设我们已经知道了每个根节点的左子树的以某个节点的子树节点总数为 nodeNum, 可以先用左子树的节点数和我们要找的 k 进行比较, 判定是否在左子树里面, 或者在右子树里面, 还是直接就是当前根节点就是第 k 小的树<br>3.令 node 为当前根节点开始搜索, 也就是说一开始指针指向 root,<br>如果 node 的左子树的节点数 leftNodeNum &lt; k-1, 那么第 k 小的元素在 node 的右子树中, 指针搜向右边的子树 node=node-&gt;right, 搜索的空间可以直接减去 (leftNodeNums + 1), 然后继续搜索<br>如果 node 的左子树的节点数 leftNodeNum == k-1, 那么第 k 小的元素就是 node 直接返回 node<br>如果 node 的左子树的节点数 leftNodeNum &gt; k-1, 那么第 k 小的元素在node的左子树里面, 指针走向左子树里面搜索 node=node-&gt;left, 继续搜索<br>3.为实现上述的逻辑, 先将每个根节点数保存在哈希表中  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  unordered_map&lt;TreeNode*, int&gt; nodeNum;
  // 记录以 node 为根节点的树的节点总数
  int countNodesNum(TreeNode* root) &#123;
    if (root == nullptr) &#123;
      return 0;
    &#125;
    int num = 1 + countNodesNum(root-&gt;left) + countNodesNum(root-&gt;right);
    nodeNum[root] = num;
    return num;
  &#125;
  int kthSmallest(TreeNode* root, int k) &#123;
    if (root == nullptr) &#123;
      return 0;
    &#125;
    countNodesNum(root);
    while (root != nullptr) &#123;
      int leftNodeNum = nodeNum[root-&gt;left];
      if (leftNodeNum &lt; k - 1) &#123;
        root = root-&gt;right;
        k -= leftNodeNum + 1;
      &#125; else if (leftNodeNum == k - 1) &#123;
        return root-&gt;val;
      &#125; else if (leftNodeNum &gt; k - 1) &#123;
        root = root-&gt;left;
      &#125;
    &#125;
    return root-&gt;val;
  &#125;
&#125;;
</code></pre>
<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a>199.二叉树的右视图</h2><blockquote>
<p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p>示例 1: 输入: [1,2,3,null,5,null,4] 输出: [1,3,4]</p>
<p>示例 2: 输入: [1,null,3] 输出: [1,3]</p>
<p>示例 3: 输入: [] 输出: []</p>
</blockquote>
<p>分析:<br>1.层序遍历  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  vector&lt;int&gt; rightSideView(TreeNode* root) &#123;
    vector&lt;int&gt; ans;
    queue&lt;TreeNode*&gt; q;
    if (root == nullptr) &#123;
      return ans;
    &#125;
    q.push(root);
    while (!q.empty()) &#123;
      int qlen = q.size();
      while (qlen &gt; 0) &#123;
        root = q.front();
        q.pop();
        if (root-&gt;left != nullptr) &#123;
          q.push(root-&gt;left);
        &#125;
        if (root-&gt;right != nullptr) &#123;
          q.push(root-&gt;right);
        &#125;
        if (qlen == 1) &#123;
          ans.push_back(root-&gt;val);
        &#125;
        --qlen;
      &#125;
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114.二叉树展开为链表"></a>114.二叉树展开为链表</h2><blockquote>
<p>给你二叉树的根结点 root ，请你将它展开为一个单链表：<br>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
<p>示例 1：输入：root = [1,2,5,3,4,null,6] 输出：[1,null,2,null,3,null,4,null,5,null,6]</p>
<p>示例 2：输入：root = [] 输出：[]</p>
<p>示例 3：输入：root = [0] 输出：[0]</p>
</blockquote>
<pre><code>     1          1         1
    / \        / \         \
   2   5      2   5         2
  / \   \      \   \         \
 3   4   6      3   6         3
                 \             \
                  4             4
                                 \
                                  5
                                   \
                                    6
</code></pre><p>分析:<br>1.先理解一下二叉树转换为链表是什么意思 ? 链表本质上就是只有一个子树的二叉树, 二叉树就是链表的第一个节点多开出来一条链表的链表<br>2.可以用递归/非递归先序遍历, 遍历过程中把元素存储到数组里面, 然后再遍历这个数组构建一个二叉树  </p>
<pre><code class="lang-cpp">class Solution &#123;
 private:
  vector&lt;TreeNode*&gt; list;
 public:
  // 先序转数组
  void preorderTraverse(TreeNode* root) &#123;
    if (root == nullptr) &#123;
      return;
    &#125;
    list.push_back(root);
    preorderTraverse(root-&gt;left);
    preorderTraverse(root-&gt;right);
    return;
  &#125;
  void flatten(TreeNode* root) &#123;
    preorderTraverse(root);
    int len = list.size();
    // 迭代构建树: 左孩子置空指针, 右孩子链接起来
    for (int i = 1; i &lt; len; ++i) &#123;
      TreeNode* pre = list[i-1];
      TreeNode* cur = list[i];
      pre-&gt;left = nullptr;
      pre-&gt;right = cur;
    &#125;
    return;
  &#125;
&#125;;
</code></pre>
<p>2.思考能否用分解的思路递归实现, 那么就要看看怎么去实现 flatten 这种操作, 也就是找 flatten 子树和当前根节点的关系<br>3.如下所示 一个flatten操作可以分解为 3 步, 先把左右子树分别做 flatten, 然后将右子树接在左子树的最下面, 然后把左子树换到右子树  </p>
<pre><code>     1          1         1
    / \        / \         \
   2   5      2   5         2
  / \   \      \   \         \
 3   4   6      3   6         3
                 \             \
                  4             4
                                 \
                                  5
                                   \
                                    6
</code></pre><p>将三步都写出来, 得到完整答案  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  void flatten(TreeNode* root) &#123;
    if (root == nullptr) &#123;
      return;
    &#125;
    flatten(root-&gt;left);
    flatten(root-&gt;right);
    TreeNode* left = root-&gt;left;
    TreeNode* right = root-&gt;right;
    root-&gt;left = nullptr;
    root-&gt;right = left;
    TreeNode* p = root;
    while (p -&gt;right != nullptr) &#123;
      p = p-&gt;right;
    &#125;
    p-&gt;right = right;
    return;
  &#125;
&#125;;
</code></pre>
<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h2><blockquote>
<p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<p>示例 1: 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]  输出: [3,9,20,null,null,15,7]</p>
<p>示例 2: 输入: preorder = [-1], inorder = [-1] 输出: [-1]</p>
</blockquote>
<p>分析:<br>1.先拿一个例子看,  </p>
<pre><code>        1
       / \
     2     3
    / \   / \ 
   5   4 8   9 
      / \
     6   7
</code></pre><p>preorder<br>1,[2,5,4,6,7],[3,8,9]<br>inorder<br>[5,2,6,4,7],1,[8,3,9]<br>根节点把 inorder 可以划分成两半, 然后继续递归建立树, 每次建立树在先序数组里面维护起点和终点, 在中序里面也要维护起点和终点; 所以思路是先找根节点 =&gt; 左右子树递归建树, 建树的过程需要算各种长度, 我们先写个代码框架:  </p>
<pre><code class="lang-cpp">TreeNode* build(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int preLow, int preHigh, int inLow, int inHigh) &#123;
  if (preLow &gt; preHigh) &#123;
    return nullptr;
  &#125;
  // 找到先序的第一个就是根节点
  int rootVal = preorder[preLow];
  int rootInorderIdx;
  for (int i = inLow; i &lt;= inHigh; ++i) &#123;
    if (inorder[i] == rootVal) &#123;
      rootInorderIdx = i;
      break;
    &#125;
  &#125;
  TreeNode* root = newTreeNode(rootVal);
  root-&gt;left = build(preorder, inorder, ?, ?, ?, ?);
  root-&gt;right = build(preorder, inorder, ?, ?, ?, ?);
  return root;
&#125;

TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;
  return build(preorder, inorder, 0, preorder.size()-1, inorder.size()-1)
&#125;
</code></pre>
<p>现在需要明确上面递归构建子树的时候 index 填什么, 如果能填对相应的 4 个index, 那么就完成了; 我们发现在中序序列里面是比较好填的, 无非就是左侧给到左子树, 右侧给到右子树  </p>
<pre><code class="lang-cpp">TreeNode* root = newTreeNode(rootval);
root-&gt;left = build(preorder, inorder, ?, ?, inlow, rootInorderIdx-1);
root-&gt;right = build(preorder, inorder, ?, ?, rootInorderIdx+1, inHigh);
</code></pre>
<p>那么先序的左边起止点怎么填?<br>先序左边的起点是 preLow+1, 先序的终点呢? 其实是要找到先序左侧对应的 size 有多大, 然后 preLow + leftSize<br>先序右边的终点是 preHigh, 先序的起点呢? 顺着上面的结论, 其实就是左侧那个区间的后一个节点, 可以得到preLow + leftSize + 1<br>leftSize = rootInorderIdx - inLow<br>把这些起止点都梳理清楚后, 然后就能递归的建树了  </p>
<pre><code class="lang-cpp">int leftSize = rootInorderIdx - inLow;
root-&gt;left = build(preorder, inorder, preLow+1, preLow+leftSize, inlow, rootInorderIdx-1);
root-&gt;right = build(preorder, inorder, preLow+leftSize+1, preHigh, rootInorderIdx+1, inHigh);
</code></pre>
<p>完整代码如下  </p>
<pre><code class="lang-cpp">class Solution &#123;
 private:
  unordered_map&lt;int, int&gt; inorderValue2indx;
 public:
  TreeNode* build(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int prel, int preh, int inl, int inh) &#123;
    if (prel &gt; preh) &#123;
      return nullptr;
    &#125;
    // 找到根节点
    int rootVal = preorder[prel];
    int rootInorderIdx = inorderValue2indx[rootVal];
    TreeNode* root = new TreeNode(rootVal);
    int leftSize = rootInorderIdx - inl;
    root-&gt;left = build(preorder, inorder, prel + 1, prel + leftSize, inl, rootInorderIdx - 1);
    root-&gt;right = build(preorder, inorder, prel + leftSize + 1, preh, rootInorderIdx + 1, inh);
    return root;
  &#125;
  TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;
    for (int i = 0; i &lt; inorder.size(); ++i) &#123;
      inorderValue2indx[inorder[i]] = i;
    &#125;
    return build(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size()-1);
  &#125;
&#125;;
</code></pre>
<p>这里有个优化点, 因为数组中不存在重复元素, 那么可以提前把中序遍历的根节点对应的index 提前保存在 hash 表中, 找 index 的时间复杂度降低为 O(1)  </p>
<pre><code class="lang-cpp">class Solution &#123;
 private:
  // 记录下来中序遍历中每个值对应的index
  unordered_map&lt;int, int&gt; inorderValue2indx;
 public:
  TreeNode* build(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int prel, int preh, int inl, int inh) &#123;
    if (prel &gt; preh) &#123;
      return nullptr;
    &#125;
    // 找到根节点
    int rootVal = preorder[prel];
    int rootInorderIdx = inorderValue2indx[rootVal];
    TreeNode* root = new TreeNode(rootVal);
    int leftSize = rootInorderIdx - inl;
    root-&gt;left = build(preorder, inorder, prel + 1, prel + leftSize, inl, rootInorderIdx - 1);
    root-&gt;right = build(preorder, inorder, prel + leftSize + 1, preh, rootInorderIdx + 1, inh);
    return root;
  &#125;
  TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;
    for (int i = 0; i &lt; inorder.size(); ++i) &#123;
      inorderValue2indx[inorder[i]] = i;
    &#125;
    return build(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size()-1);
  &#125;
&#125;;
</code></pre>
<h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437.路径总和 III"></a>437.路径总和 III</h2><blockquote>
<p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。 路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）</p>
<p>示例 1：输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8 输出：3 解释：和等于 8 的路径有 3 条，如图所示。</p>
<p>示例 2：输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 输出：3</p>
<pre><code>         10 
       /    \
     5       -3 
    /  \       \
   3    2       11 
  /  \   \ 
3    -2   1
</code></pre></blockquote>
<p>分析:<br>1.这个题中提到的路径不需要从根节点开始, 而是累计以根节点为根节点包含下的所有 (经过或者不经过根节点) 的路径. 因此用分解问题的思维, 以根节点为根节点的所有路径总和, 等于左子树包含的路径总和 + 右子树包含的路径总和 + 以根节点为必经节点下的路径总和; 写成代码就是 pathSum(root-&gt;left) + pathSum(root-&gt;right) + rootViaSum(root), 其中 rootViaSum(root) 以根节点为必经节点下的路径总和<br>2.所以我们思考如何计算 rootViaSum(root) , 也就是以某个具体的根节点为根节点, 然后必须经过这个根节点的路径总和; 这里又要采用另一个分解思维: 当前的这个求和为 targetSum 的话, 可以有 3 种方式, 一种是一开始根节点就能满足路径总和, 另外两种是根节点和下面左子树凑出来路径总和, 以及根节点和右子树凑出来路径总和  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  // rootViaSum 计算必须经过这个根节点的路径总和
  int rootViaSum(TreeNode* root, long long targetSum) &#123;
    if (root == nullptr) &#123;
      return 0;
    &#125;
    // 计算必须经过这个根节点的路径总和 = 可能的根节点值等于 target的情况=1/否则0 + 根节点和下面左子树凑出来路径总和 + 根节点和下面右子树凑出来的路径总和
    return ((root-&gt;val == targetSum) ? 1 : 0) + rootViaSum(root-&gt;left, targetSum - root-&gt;val) + rootViaSum(root-&gt;right, targetSum - root-&gt;val);
  &#125;
  int pathSum(TreeNode* root, int targetSum) &#123;
    if (root == nullptr) &#123;
      return 0;
    &#125;
    // 以根节点为根节点的所有路径总和 = 左子树包含的路径总和 + 右子树包含的路径总和 + 以根节点为必经节点下的路径总和
    return rootViaSum(root, targetSum) + pathSum(root-&gt;left, targetSum) + pathSum(root-&gt;right, targetSum);
  &#125;
&#125;;
</code></pre>
<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236.二叉树的最近公共祖先"></a>236.二叉树的最近公共祖先</h2><blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”  </p>
<p>示例 1：输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 .  </p>
<pre><code>       3 
     /   \
   5       1 
 /  \     /  \
6    2   0    3 
   /   \ 
  7     4
</code></pre><p>示例 2：输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5  解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>示例 3：输入：root = [1,2], p = 1, q = 2 输出：1  </p>
</blockquote>
<p>分析:<br>1.给定一个根节点, 然后给定树里面任意两个节点, 让我们找这两个任意节点的最低公共祖先<br>2.先可以判定一些非常简单的情况, 假设 p 和 q 之间本身有一个祖先关系, 也就是说 root == p || root = q 那么就说明这时候的 root 就是最近公共祖先<br>3.然后我们处理一些相对复杂的情况, 根节点在上面, 然后 p 和 q 在根节点的下面分布着, 下一步怎么搜索呢 ? 根节点的搜索指针可以向下移动, 可以从根节点左子树搜索 p 和 q, 也可以从根节点的右子树搜索 p 和 q; 这里有 3 种可能的情况,<br>(i). p 和 q 都在左子树, 那么我们就在 左子树里面递归找最低公共祖先<br>(ii). p 和 q 都在右子树, 那么我们就在 右子树里面递归找最低公共祖先<br>(iii). p 和 q 左右子树各一个, 最低公共祖先就是 root  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  bool nodeInSubTree(TreeNode* root, TreeNode* c) &#123;
    if (root == nullptr) &#123;
      return false;
    &#125;
    if (root == c) &#123;
      return true;
    &#125;
    return nodeInSubTree(root-&gt;left, c) || nodeInSubTree(root-&gt;left, c);
  &#125;
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
    if (root == nullptr) &#123;
      return nullptr;
    &#125;
    if (root == p || root == q) &#123;
      return root;
    &#125;
    if (nodeInSubTree(root-&gt;left, p) &amp;&amp; nodeInSubTree(root-&gt;right, q)) &#123;
      return lowestCommonAncestor(root-&gt;left, p, q);
    &#125;
    if (nodeInSubTree(root-&gt;right, p) &amp;&amp; nodeInSubTree(root-&gt;right, q)) &#123;
      return lowestCommonAncestor(root-&gt;right, p, q);
    &#125;
    return root
  &#125;
&#125;;
</code></pre>
<p>4.我们再想一下, 既然总共就 以上 3 种情况, 这里我们也不用非要判断 p 和 q 具体要在哪个子树里面: 情况还是如上三种, 我们逐次判断 2 种情况的存在性就可以  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
    if (root == nullptr) &#123;
      return nullptr;
    &#125;
    if (root == p || root == q) &#123;
      return root;
    &#125;
    TreeNode* lRes = lowestCommonAncestor(root-&gt;left, p, q);
    TreeNode* rRes = lowestCommonAncestor(root-&gt;right, p, q);
    if (lRes != nullptr &amp;&amp; rRes != nullptr) &#123;
      return root;
    &#125; else if (lRes == nullptr) &#123;
      return rRes;
    &#125; else &#123;
      return lRes;
    &#125;
  &#125;
&#125;;
</code></pre>
<h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124.二叉树中的最大路径和"></a>124.二叉树中的最大路径和</h2><blockquote>
<p>二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。路径和 是路径中各节点值的总和。给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<p>示例 1：输入：root = [1,2,3] 输出：6 解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</p>
<p>示例 2：输入：root = [-10,9,20,null,null,15,7] 输出：42 解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42  </p>
</blockquote>
<pre><code>     -10
      / \
    9    20 
   / \   / \     
 -2     15  7
</code></pre><p>分析:<br>1.因为最大路径和可以不包含根节点, 所以我们要遍历出来以每个根节点为根节点的二叉树的最大路径和, 然后迭代出来最大的, 所以我们分析下以某个根节点为根节点的二叉树的最大路径和怎么来的?<br>2.以当前根节点为根节点的二叉树的最大路径和 = 根节点的值 + 左子树的最大路径和 + 右子树的最大路径和; 左子树的最大路径和是什么 ? 这里每个节点是有正有负的, 如果左子树最大路径和是个负数, 那么我们把左子树的负增益要砍掉, 反而是最大的; 所以准确地说, 我们考虑的左子树的最大路径和, 考虑的是经过左孩子为根节点的向下路径求和增益 (右子树同理); 以当前根节点为根节点的二叉树的最大路径和 = 根节点的值 + 经过左孩子为根节点的向下路径求和增益 + 经过右孩子为根节点的向下路径求和增益, 其中, 增益表示的是至少是个 &gt;= 0 的值<br>经过左孩子为根节点的向下路径求和增益 = max(viaRootPathSumGain(root-&gt;left), 0)<br>经过左孩子为根节点的向下路径求和增益 = max(viaRootPathSumGain(root-&gt;right), 0)<br>3.所以, 我们要写的函数是 viaRootPathSumGain(), 代表了经过 root 为根节点的向下路径的求和增益, 这个路径上的增益是什么? 根节点的值加左右增益路径中最大的一边的值: 经过 root 为根节点的向下路径的下求和增益 = root-&gt;val + max(经过左孩子为根节点的向下路径求和增益, 经过右孩子为根节点的向下路径求和增益)  </p>
<pre><code class="lang-cpp">class Solution &#123;
 private:
  int ans = INT_MIN;
 public:
  // viaRootPathSumGain 返回经过 root 为根节点的向下路径的求和增益
  int viaRootPathSumGain(TreeNode* root) &#123;
    if (root == nullptr) &#123;
      return 0;
    &#125;
    // 经过左/右孩子节点的向下陆景求和增益, 增益表示限制下界是0, 路径和为负数一律不考虑
    int lPathSumGain = max(viaRootPathSumGain(root-&gt;left), 0);
    int rPathSumGain = max(viaRootPathSumGain(root-&gt;right), 0);

    // 后序位置迭代: 求经过 root 的二叉树的最大路径和
    // 经过 root 的二叉树的最大路径和 = root 的值 + 经过左孩子为根节点的向下路径求和增益 + 经过右孩子为根节点的向下路径求和增益
    int curPathSum = root-&gt;val + lPathSumGain + rPathSumGain;
    ans = max(ans, curPathSum);

    // 经过 root 为根节点的向下路径的求和增益 = root-&gt;val + max(经过左孩子为根节点的向下路径求和增益, 经过右孩子为根节点的向下路径求和增益)
    return root-&gt;val + max(lPathSumGain, rPathSumGain);
  &#125;
  int maxPathSum(TreeNode* root) &#123;
    viaRootPathSumGain(root);
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h2><blockquote>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例 1：<br>输入：grid = [<br>  [“1”,”1”,”1”,”1”,”0”],<br>  [“1”,”1”,”0”,”1”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1</p>
<p>示例 2：<br>输入：grid = [<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”1”,”0”,”0”],<br>  [“0”,”0”,”0”,”1”,”1”]<br>]<br>输出：3</p>
</blockquote>
<p>分析:<br>1.遍历岛屿, 然后遇到1的情况下累加岛屿个数, 然后 dfs 四个方向把链接的地方都标注成水  </p>
<pre><code class="lang-cpp">class Solution &#123;
 private:
  int ans = 0;
 public:
  const vector&lt;vector&lt;int&gt;&gt; dirs = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;
  void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j) &#123;
    if (i &lt; 0 || i &gt;= grid.size() || j &lt; 0 || j &gt;= grid[0].size()) &#123;
      return;
    &#125;
    if (grid[i][j] == &#39;0&#39;) &#123;
      return;
    &#125;
    if (grid[i][j] == &#39;1&#39;) &#123;
      grid[i][j] = &#39;0&#39;;
      for (int k = 0; k &lt; 4; ++k) &#123;
        int nx = i + dirs[k][0];
        int ny = j + dirs[k][1];
        dfs(grid, nx, ny);
      &#125;
    &#125;
    return;
  &#125;
  int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;
    for (int i = 0; i &lt; grid.size(); ++i) &#123;
      for (int j = 0; j &lt; grid[0].size(); ++j) &#123;
        if (grid[i][j] == &#39;1&#39;) &#123;
          ++ans;
          dfs(grid, i, j);
        &#125;
      &#125;
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994.腐烂的橘子"></a>994.腐烂的橘子</h2><blockquote>
<p>在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：<br>值 0 代表空单元格；值 1 代表新鲜橘子；值 2 代表腐烂的橘子。<br>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。<br>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。</p>
<p>示例 1：输入：grid =<br>[<br>  [2,1,1],<br>  [1,1,0],<br>  [0,1,1]<br>] 输出：4</p>
<p>示例 2：输入：grid =<br>[<br>  [2,1,1],<br>  [0,1,1],<br>  [1,0,1]<br>]<br>输出：-1<br>解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。</p>
<p>示例 3：输入：grid =<br>[<br>  [0,2]<br>] 输出：0<br>解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</p>
</blockquote>
<p>分析:<br>1.模拟腐烂的过程, 对腐烂的橘子做广度优先搜索, 每一层数量分钟数增加1 , 然后模拟新鲜的橘子变成了腐烂的橘子<br>2.在模拟腐烂进行 BFS 的过程中, 持续判断新鲜的橘子 &gt; 0的, 如果新鲜橘子数量 == 0 了, 那么就停下来模拟, 返回结果<br>3.一开始遍历一下计数有多少个新鲜的橘子, 并将腐烂的橘子入队  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
    int rows = grid.size();
    int cols = grid[0].size(); 
    typedef pair&lt;int, int&gt; pii;
    queue&lt;pii&gt; q;
    const vector&lt;vector&lt;int&gt;&gt; dirs = &#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;
    int freshCnt = 0;
    // 维护新鲜橘子的个数
    for (int i = 0; i &lt; rows; ++i) &#123;
      for (int j = 0; j &lt; cols; ++j) &#123;
        if (grid[i][j] == 1) &#123;
          ++freshCnt;
        &#125; else if (grid[i][j] == 2) &#123;
          q.push(make_pair(i, j));
        &#125;
      &#125;
    &#125;
    int minute = 0;
    // 模拟腐烂的过程, bfs 实现
    while (freshCnt &gt; 0 &amp;&amp; !q.empty()) &#123;
      ++minute;
      int len = q.size();
      while (len &gt; 0) &#123;
        pii cur = q.front();
        q.pop();
        for (int k = 0; k &lt; 4; ++k) &#123;
          int nx = cur.first + dirs[k][0];
          int ny = cur.second + dirs[k][1];
          // 如果是个新鲜的橘子, 腐烂掉
          if (nx &gt;= 0 &amp;&amp; nx &lt; rows &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; cols &amp;&amp; grid[nx][ny] == 1) &#123;
            grid[nx][ny] = 2;
            --freshCnt;
            q.push(make_pair(nx, ny));
          &#125;
        &#125;
        --len;
      &#125;
    &#125;
    if (freshCnt &gt; 0) &#123;
      return -1;
    &#125; else &#123;
      return minute;
    &#125;
  &#125;
&#125;;
</code></pre>
<h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207.课程表"></a>207.课程表</h2><blockquote>
<p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。<br>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p>
<p>示例 1：输入：numCourses = 2, prerequisites = [[1,0]] 输出：true 解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的.  </p>
<p>示例 2：输入：numCourses = 2, prerequisites = [[1,0],[0,1]] 输出：false 解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</p>
</blockquote>
<p>分析:<br>1.课程之间的关系可以抽象为图结构的依赖关系, 返回可行的结果就是给出一种拓扑排序的结果; 我们尝试对课程图进行拓扑排序, 如果检测到环, 直接停止下来返回 false<br>2.给出 bfs 和 dfs 的两种实现  </p>
<pre><code class="lang-cpp">// bfs 实现
class Solution &#123;
 private:
  vector&lt;vector&lt;int&gt;&gt; edges;
  vector&lt;int&gt; indegree;
  queue&lt;int&gt; q;
  int cnt = 0;
 public:
  bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;
    edges.resize(numCourses, vector&lt;int&gt;());
    indegree.resize(numCourses);
    for (auto x : prerequisites) &#123;
      edges[x[1]].push_back(x[0]);
      ++indegree[x[0]];
    &#125;
    for (int i = 0; i &lt; numCourses; ++i) &#123;
      if (indegree[i] == 0) &#123;
        q.push(i);
      &#125;
    &#125;
    while (!q.empty()) &#123;
      int c = q.front();
      q.pop();
      ++cnt;
      for (auto n : edges[c]) &#123;
        --indegree[n];
        if (indegree[n] == 0) &#123;
          q.push(n);
        &#125;
      &#125;
    &#125;
    return cnt == numCourses;
  &#125;
&#125;;
</code></pre>
<p>然后写下 dfs 实现  </p>
<pre><code class="lang-cpp">// dfs 实现
class Solution &#123;
 private:
  vector&lt;vector&lt;int&gt;&gt; edges;
  vector&lt;int&gt; visited;
  bool hasCycle;
 public:
  void dfs(int c) &#123;
    if (hasCycle) &#123;
      return;
    &#125;
    visited[c] = 1;
    for (auto n : edges[c]) &#123;
      if (visited[n] == 0) &#123;
        dfs(n);
      &#125; else if (visited[n] == 1) &#123;
        hasCycle = true; 
        return;
      &#125;
    &#125;
    visited[c] = 2;
  &#125;
  bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;
    edges.resize(numCourses, vector&lt;int&gt;());
    visited.resize(numCourses);
    for (auto x : prerequisites) &#123;
      edges[x[1]].push_back(x[0]);
    &#125; 
    for (int i = 0; i &lt; numCourses; ++i) &#123;
      if (hasCycle) &#123;
        break;
      &#125;
      if (visited[i] == 0) &#123;
        dfs(i);
      &#125;
    &#125;
    return !hasCycle;
  &#125;
&#125;;
</code></pre>
<h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208.实现 Trie (前缀树)"></a>208.实现 Trie (前缀树)</h2><blockquote>
<p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。<br>请你实现 Trie 类：<br>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</p>
<p>示例：<br>输入<br>[“Trie”, “insert”, “search”, “search”, “startsWith”, “insert”, “search”]<br>[[], [“apple”], [“apple”], [“app”], [“app”], [“app”], [“app”]]<br>输出<br>[null, null, true, false, true, null, true]<br>解释<br>Trie trie = new Trie();<br>trie.insert(“apple”);<br>trie.search(“apple”);   // 返回 True<br>trie.search(“app”);     // 返回 False<br>trie.startsWith(“app”); // 返回 True<br>trie.insert(“app”);<br>trie.search(“app”);     // 返回 True</p>
</blockquote>
<p>分析:<br>1.Trie 实现, 开一个指向 Trie 的数组 vector<Trie*> children, 写一个前缀匹配的函数以及插入单词的函数  </p>
<pre><code class="lang-cpp">class Trie &#123;
 private:
  vector&lt;Trie*&gt; children; // 子节点指针, 指向的是 Trie 类型的孩子节点, 用一个数组
  bool isEnd;             // 标记已经是末尾
 public:
  Trie() &#123;
    children = vector&lt;Trie*&gt;(26, nullptr);
    isEnd = false;
  &#125;
  // 搜索前缀的函数: 实现核心搜索前缀的功能
  // 如果前缀完全匹配, 返回非空的指针;
  // 如果前缀匹配过程中没有匹配到, 直接返回空指针;
  Trie* searchPrefix(string word) &#123;
    Trie* node = this;
    for (char c: word) &#123;
      if (node-&gt;children[c - &#39;a&#39;] == nullptr) &#123;
        return nullptr;
      &#125;
      node = node-&gt;children[c - &#39;a&#39;];
    &#125;
    return node;
  &#125;
  // 插入字符串的函数
  // 遍历字符串
  // 如果当前 children[ch] 已经开了指针, node 沿着指针搜索 node = node-&gt;children[c - &#39;a&#39;];
  // 如果当前 children[ch] 没有开指针, 那么 new 一个 Trie();
  void insert(string word) &#123;
    Trie* node = this;
    for (char c: word) &#123;
      if (node-&gt;children[c - &#39;a&#39;] == nullptr) &#123;
        node-&gt;children[c - &#39;a&#39;] = new Trie();
      &#125;
      node = node-&gt;children[c - &#39;a&#39;];
    &#125;
    node-&gt;isEnd = true;
  &#125;

  // 匹配前缀函数: 能搜到前缀
  bool startsWith(string prefix) &#123;
    return searchPrefix(prefix) != nullptr;
  &#125;

  // 匹配单词函数: 能搜到前缀, 且 idEnd 标记为 true
  bool search(string word) &#123;
    Trie* node = searchPrefix(word);
    return node != nullptr &amp;&amp; node-&gt;isEnd == true;
  &#125;
&#125;;
/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj-&gt;insert(word);
 * bool param_2 = obj-&gt;search(word);
 * bool param_3 = obj-&gt;startsWith(prefix);
 */
</code></pre>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h2><blockquote>
<p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<p>示例 1：输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>
<p>示例 2：输入：nums = [0,1] 输出：[[0,1],[1,0]]</p>
<p>示例 3：输入：nums = [1] 输出：[[1]]</p>
</blockquote>
<p>分析:<br>1.因为数组中的元素已经不重复, 我们 dfs + 回溯依次放入相应的元素, 直到判断元素个数已经达到目标元素个数<br>2.放入的时候判断重复的元素不能放入  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  void dfs(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; cur, vector&lt;vector&lt;int&gt;&gt;&amp; ans) &#123;
    if (cur.size() == nums.size()) &#123;
      ans.push_back(cur);
      return;
    &#125;
    for (int i = 0; i &lt; nums.size(); ++i) &#123;
      // 检测到数组中已经存在该元素不执行放入
      if (find(cur.begin(), cur.end(), nums[i]) != cur.end()) &#123;
        continue;
      &#125;
      cur.push_back(nums[i]);
      dfs(nums, cur, ans);
      cur.pop_back();
    &#125;
    return;
  &#125;
  vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; cur;
    dfs(nums, cur, ans);
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h2><blockquote>
<p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<p>示例 1：输入：nums = [1,2,3]  输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p>
<p>示例 2：输入：nums = [0]  输出：[[],[0]]</p>
</blockquote>
<p>分析:<br>1.采用 dfs+回溯的方式, 回溯完之后, 可以不选元素加入且继续路径向前+1 进行 dfs  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  void dfs(int pos, vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; cur, vector&lt;int&gt;&amp; nums) &#123;
    if (pos == nums.size()) &#123;
      ans.push_back(cur);
      return;
    &#125;
    cur.push_back(nums[pos]);
    dfs(pos+1, ans, cur, nums);
    cur.pop_back();
    // 在不加入元素的情况下继续 dfs
    dfs(pos+1, ans, cur, nums);
    return;
  &#125;
  vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; cur;
    dfs(0, ans, cur, nums);
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h2><blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>示例 1：输入：digits = “23” 输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p>
<p>示例 2：输入：digits = “” 输出：[]</p>
<p>示例 3：输入：digits = “2” 输出：[“a”,”b”,”c”]</p>
</blockquote>
<p>分析:<br>1.先把所有的从数字到字母的字符串放在一个 map 里面, 然后对数字进行回溯搜索<br>2.回溯的对应关系为  </p>
<pre><code class="lang-cpp">unrorderd_map&lt;int, char&gt; &#123;
  &#123;&#39;2&#39;, &quot;abc&quot;&#125;,
  &#123;&#39;3&#39;, &quot;def&quot;&#125;,
  &#123;&#39;4&#39;, &quot;ghi&quot;&#125;,
  &#123;&#39;5&#39;, &quot;jkl&quot;&#125;,
  &#123;&#39;6&#39;, &quot;mno&quot;&#125;,
  &#123;&#39;7&#39;, &quot;pqrs&quot;&#125;,
  &#123;&#39;8&#39;, &quot;tuv&quot;&#125;,
  &#123;&#39;9&#39;, &quot;wxyz&quot;&#125;
&#125;
</code></pre>
<p>3.采用回溯的思想逐个加入  </p>
<pre><code class="lang-cpp">class Solution &#123;
 private:
  vector&lt;string&gt; ans;
  unordered_map&lt;char, string&gt; num2letter&#123;
    &#123;&#39;2&#39;, &quot;abc&quot;&#125;,
    &#123;&#39;3&#39;, &quot;def&quot;&#125;,
    &#123;&#39;4&#39;, &quot;ghi&quot;&#125;,
    &#123;&#39;5&#39;, &quot;jkl&quot;&#125;,
    &#123;&#39;6&#39;, &quot;mno&quot;&#125;,
    &#123;&#39;7&#39;, &quot;pqrs&quot;&#125;,
    &#123;&#39;8&#39;, &quot;tuv&quot;&#125;,
    &#123;&#39;9&#39;, &quot;wxyz&quot;&#125;
  &#125;;
 public:
  void dfs(int idx, string&amp; cur, string&amp; target) &#123;
    if (idx == target.size()) &#123;
      ans.push_back(cur);
      return;
    &#125;
    string candidates = num2letter[target[idx]];
    for (int i = 0; i &lt; candidates.size(); ++i) &#123;
      cur.push_back(candidates[i]);
      dfs(idx+1, cur, target);
      cur.pop_back();
    &#125;
    return;
  &#125;
  vector&lt;string&gt; letterCombinations(string digits) &#123;
    if (digits.empty()) &#123;
      return ans;
    &#125;
    string cur = &quot;&quot;;
    dfs(0, cur, digits);
    return ans; 
  &#125;
&#125;;
</code></pre>
<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h2><blockquote>
<p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合，并以列表形式返回。你可以按 任意顺序 返回这些组合。<br>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。<br>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
<p>示例 1：输入：candidates = [2,3,6,7], target = 7 输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 = 7 。<br>仅有这两种组合。</p>
<p>示例 2：输入: candidates = [2,3,5], target = 8 输出: [[2,2,2,2],[2,3,3],[3,5]]</p>
<p>示例 3：输入: candidates = [2], target = 1 输出: []</p>
</blockquote>
<p>分析:<br>1.想一下我们的搜索空间是什么, 为了保证不重复不遗漏, 先对元素进行排序, 每次搜索的时候, 要从当前的位置开始搜索, 之前搜过的元素不去搜索, 因此除了维护求和之外, 还得维护一个当前的搜索位置  </p>
<pre><code class="lang-cpp">class Solution &#123;
 private:
  vector&lt;vector&lt;int&gt;&gt; ans;
 public:
  void dfs(int sum, int startIdx, int target, vector&lt;int&gt;&amp; cur, vector&lt;int&gt;&amp; candidates) &#123;
    if (sum == target) &#123;
      ans.push_back(cur);
      return;
    &#125;
    if (sum &gt; target) &#123;
      return;
    &#125;
    for (int i = startIdx; i &lt; candidates.size(); ++i) &#123;
      cur.push_back(candidates[i]);
      dfs(sum + candidates[i], i, target, cur, candidates);
      cur.pop_back();
    &#125;
    return;
  &#125;
  vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;
    if (candidates.empty()) &#123;
      return ans;
    &#125;
    vector&lt;int&gt; cur;
    // 必须先排序
    sort(candidates.begin(), candidates.end());
    // dfs 的时候带上搜索的位置, 才能确定候选集合
    dfs(0, 0, target, cur, candidates);
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h2><blockquote>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<p>示例 1：输入：n = 3 输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p>
<p>示例 2：输入：n = 1 输出：[“()”]</p>
</blockquote>
<p>分析:<br>1.我们总共有 n 对括号需要增加, 只需要判定清楚什么情况下括号需要增加, 什么情况下括号不能增加, 搜索的时候采取回溯<br>2.左括号可以任意加入, 只要有就可以加; 右括号在什么情况下是合法的? 左括号数右括号数多的情况下, 可以通过加入右括号, 配置成合法的括号  </p>
<pre><code class="lang-cpp">class Solution &#123;
 private:
  vector&lt;string&gt; ans;
 public:
  void dfs(int lCnt, int rCnt, string&amp; cur) &#123;
    // 都填完
    if (lCnt == 0 &amp;&amp; rCnt == 0) &#123;
      ans.push_back(cur);
      return;
    &#125;
    // 左括号可以任意加入, 只要有就可以加
    if (lCnt &gt; 0) &#123;
      cur.push_back(&#39;(&#39;);
      dfs(lCnt - 1, rCnt, cur);
      cur.pop_back();
    &#125;
    // 右括号在什么情况下是合法的? 左括号数右括号数多的情况下, 可以通过加入右括号, 配置成合法的括号
    if (rCnt &gt; lCnt) &#123;
      cur.push_back(&#39;)&#39;);
      dfs(lCnt, rCnt - 1, cur);
      cur.pop_back();
    &#125;
    return;
  &#125;
  vector&lt;string&gt; generateParenthesis(int n) &#123;
    string cur = &quot;&quot;;
    dfs(n, n, cur);
    return ans; 
  &#125;
&#125;;
</code></pre>
<h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79.单词搜索"></a>79.单词搜索</h2><blockquote>
<p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。<br>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>示例 1：输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED” 输出：true<br>示例 2：输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “SEE” 输出：true<br>示例 3：输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCB” 输出：false  </p>
</blockquote>
<p>分析:<br>1.dfs 回溯搜索, 搜索过的地方标记成 visited<br>2.用分解问题的思维, 当前位置和下个位置的搜索问题是一个问题, 当前位置搜索成功 = 周围四个方向中任意一个搜索成功  </p>
<pre><code class="lang-cpp">class Solution &#123;
 private:
  vector&lt;vector&lt;bool&gt;&gt; visited;
  int rows;
  int cols;
 public:
  bool dfs(int i, int j, int idx, vector&lt;vector&lt;char&gt;&gt;&amp; board, string&amp; word) &#123;
    if (idx == word.size()) &#123;
      return true;
    &#125;
    if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols) &#123;
      return false;
    &#125;
    if (visited[i][j]) &#123;
      return false;
    &#125;
    if (board[i][j] != word[idx]) &#123;
      return false;
    &#125;
    visited[i][j] = true;
    int ret = dfs(i + 1, j, idx + 1, board, word) 
           || dfs(i - 1, j, idx + 1, board, word) 
           || dfs(i, j + 1, idx + 1, board, word)
           || dfs(i, j - 1, idx + 1, board, word);
    visited[i][j] = false;
    return ret;
  &#125;
  bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;
    if (board.empty() || board[0].empty()) &#123;
      return false;
    &#125; 
    rows = board.size();
    cols = board[0].size();
    visited = vector&lt;vector&lt;bool&gt;&gt;(rows, vector&lt;bool&gt;(cols, false));
    for (int i = 0; i &lt; rows; ++i) &#123;
      for (int j = 0; j &lt; cols; ++j) &#123;
        if (dfs(i, j, 0, board, word)) &#123;
          return true;
        &#125;
      &#125;
    &#125;
    return false;
  &#125;
&#125;;
</code></pre>
<h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h2><blockquote>
<p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。回文串 是正着读和反着读都一样的字符串。</p>
<p>示例 1： 输入：s = “aab” 输出：[[“a”,”a”,”b”],[“aa”,”b”]]</p>
<p>示例 2： 输入：s = “a” 输出：[[“a”]]</p>
</blockquote>
<p>分析:<br>1.这道题可以这么想, 比如给的是 aaaa, 可以 a,a,a,a, 可以 aa,a,a, 可以 aa,aa, 可以 aaa,a, 可以 aaaa, 所以每次都要判断以某一个起点为起点的某一段 [startPos, i] 是否是回文的, 如果是那么再后面的区间内尝试继续往后搜索, 然后再回溯到起点搜索, 回溯的点是字符串的某个起点位置<br>2.单独写一个判断区间是回文的函数 isPali(string s, int l, int r)  </p>
<pre><code class="lang-cpp">class Solution &#123;
 private:
  vector&lt;vector&lt;string&gt;&gt; ans;
 public:
  bool isPali(string&amp; s, int l, int h) &#123;
    while (l &lt; h &amp;&amp; s[l] == s[h]) &#123;
      ++l;
      --h;
    &#125;
    return l &gt;= h;
  &#125;
  void dfs(int startPos, string&amp; s, vector&lt;string&gt;&amp; cur)&#123;
    if (startPos == s.size()) &#123;
      ans.push_back(cur);
      return;
    &#125;
    for (int i = startPos; i &lt; s.size(); ++i) &#123;
      // 如果 [pos, i] 之间是个回文串, 直接截取这个回文串存进去, 然后往后搜索
      if (isPali(s, startPos, i)) &#123;
        cur.push_back(s.substr(startPos, i - startPos + 1));
        // 向后搜索到 i + 1 这个位置
        dfs(i+1, s, cur);
        cur.pop_back();
      &#125;
    &#125;
    return;
  &#125;
  vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;
    vector&lt;string&gt; cur;
    dfs(0, s, cur);
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51.N 皇后"></a>51.N 皇后</h2><blockquote>
<p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<br>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。<br>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例 1： 输入：n = 4<br>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]<br>解释：如上图所示，4 皇后问题存在两个不同的解法。</p>
<p>示例 2：输入：n = 1 输出：[[“Q”]]</p>
</blockquote>
<p>分析:<br>1.初始化一个默认的棋盘, 因为根据规则, 每行至多放 1 个皇后, 所以在 dfs 放置的时候, 对 [行] 这个维度进行 dfs(row), 放完了直接进入下一行; dfs(row) 的内部, 对所有的列的位置 (row, col) 进行模拟放置并回溯<br>2.放置的时候, 需要检查放置的位置 [i,j] 是满足合法性的, 因此需要在放置之前先检查放置是合法的, 写一个 checkLegality()<br>3.checkLegality() 需要依次检查面的行之前不能放过, 左上方之前不能放过, 右上方之前不能放过  </p>
<pre><code class="lang-cpp">class Solution &#123;
 private:
  vector&lt;vector&lt;string&gt;&gt; ans;
 public:
  bool checkLegality(int r, int c, int n, vector&lt;string&gt;&amp; board) &#123;
    // 上面的行之前不能放过
    for (int i = 0; i &lt; r; ++i) &#123;
      if (board[i][c] == &#39;Q&#39;) &#123;
        return false;
      &#125;
    &#125;
    // 左上方之前不能放过
    for (int i = r-1, j = c-1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) &#123;
      if (board[i][j] == &#39;Q&#39;) &#123;
        return false;
      &#125;
    &#125;
    // 右上方之前不能放过
    for (int i = r-1, j = c+1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j) &#123;
      if (board[i][j] == &#39;Q&#39;) &#123;
        return false;
      &#125;
    &#125;
    return true;
  &#125;
  void dfs(int row, int n, vector&lt;string&gt;&amp; board) &#123;
    if (row == n) &#123;
      ans.push_back(board);
      return;
    &#125;
    for (int col = 0; col &lt; n; ++col) &#123;
      if (checkLegality(row, col, n, board)) &#123;
        board[row][col] = &#39;Q&#39;;
        dfs(row+1, n, board);
        board[row][col] = &#39;.&#39;;
      &#125;
    &#125;
    return;
  &#125;
  vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;
    vector&lt;string&gt; board(n, string(n, &#39;.&#39;));
    dfs(0, n, board);
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h2><blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>请必须使用时间复杂度为 O(log n) 的算法。nums 为 无重复元素 的 升序 排列数组.</p>
<p>示例 1: 输入: nums = [1,3,5,6], target = 5 输出: 2 </p>
<p>示例 2: 输入: nums = [1,3,5,6], target = 2 输出: 1</p>
<p>示例 3: 输入: nums = [1,3,5,6], target = 7 输出: 4</p>
</blockquote>
<p>分析:<br>1.搜索左边界的二分搜索  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;
    int l = 0;
    int h = nums.size() - 1;
    if (target &lt; nums[l]) &#123;
      return 0;
    &#125;
    if (target &gt; nums[h]) &#123;
      return h + 1;
    &#125;
    while (l &lt;= h) &#123;
      int mid = l + (h - l) / 2;
      if (nums[mid] == target) &#123;
        return mid;
      &#125; else if (nums[mid] &lt; target) &#123;
        l = mid + 1;
      &#125; else if (nums[mid] &gt; target) &#123;
        h = mid - 1;
      &#125;
    &#125;
    return l;
  &#125;
&#125;;
</code></pre>
<h2 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74.搜索二维矩阵"></a>74.搜索二维矩阵</h2><blockquote>
<p>给你一个满足下述两条属性的 m x n 整数矩阵：每行中的整数从左到右按非严格递增顺序排列。 每行的第一个整数大于前一行的最后一个整数。<br>给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。</p>
<p>示例 1：输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 输出：true</p>
<p>示例 2：输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 输出：false</p>
</blockquote>
<p>分析:<br>1.二分搜索的二维版本, 我们可以用行列关系建立二维和一维之间的映射关系, 然后就能退化到一维的二分搜索了, 假设有 row 行, col 列,<br>2.二维转一维 l = 0, high = row * col - 1<br>3.一维转二维 (i, j) 坐标之间关系为 (i / col , j % col) 这么个关系  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;
    int row = matrix.size();
    int col = matrix[0].size();
    int l = 0;
    int h = row * col - 1;
    // 二维转一维映射 l = 0, h = row * col -1
    while (l &lt;= h) &#123;
      int mid = l + (h - l) / 2;
      // 一维转二维映射 m[mid / col][mid % col]
      int midNum = matrix[mid / col][mid % col];
      if (midNum == target) &#123;
        return true;
      &#125; else if (midNum &gt; target) &#123;
        h = mid - 1;
      &#125; else if (midNum &lt; target) &#123;
        l = mid + 1;
      &#125;
    &#125;
    return false;
  &#125;
&#125;;
</code></pre>
<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34.在排序数组中查找元素的第一个和最后一个位置"></a>34.在排序数组中查找元素的第一个和最后一个位置</h2><blockquote>
<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。<br>如果数组中不存在目标值 target，返回 [-1, -1]。你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
<p>示例 1：输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4]</p>
<p>示例 2：输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1]</p>
<p>示例 3：输入：nums = [], target = 0 输出：[-1,-1]</p>
</blockquote>
<p>分析:<br>1.写一个找左边边界的二分搜索, 以及另一个找右边边界的二分搜索, 两个函数分开写  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  int lBinarySearch(vector&lt;int&gt;&amp; nums, int target) &#123;
    int l = 0;
    int h = nums.size() - 1;
    while (l &lt;= h) &#123;
      int mid = l + (h - l) / 2;
      int midNum = nums[mid];
      if (midNum == target) &#123;
        h = mid - 1;
      &#125; else if (midNum &lt; target) &#123;
        l = mid + 1;
      &#125; else if (midNum &gt; target) &#123;
        h = mid - 1;
      &#125;
    &#125;
    if (l &gt;= nums.size() || nums[l] != target) &#123;
      return -1;
    &#125;
    return l;
  &#125;
  int rBinarySearch(vector&lt;int&gt;&amp; nums, int target) &#123;
    int l = 0;
    int h = nums.size() - 1;
    while (l &lt;= h) &#123;
      int mid = l + (h - l) / 2;
      int midNum = nums[mid];
      if (midNum == target) &#123;
        l = mid + 1;
      &#125; else if (midNum &lt; target) &#123;
        l = mid + 1;
      &#125; else if (midNum &gt; target) &#123;
        h = mid - 1;
      &#125;
    &#125;
    if (h &lt; 0 || nums[h] != target) &#123;
      return -1;
    &#125;
    return h;
  &#125;
  vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;
    return vector&lt;int&gt;&#123;lBinarySearch(nums, target), rBinarySearch(nums, target)&#125;;
  &#125;
&#125;;
</code></pre>
<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h2><blockquote>
<p>整数数组 nums 按升序排列，数组中的值 互不相同。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。<br>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<p>示例 1：输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4</p>
<p>示例 2：输入：nums = [4,5,6,7,0,1,2], target = 3 输出：-1</p>
<p>示例 3：输入：nums = [1], target = 0 输出：-1</p>
</blockquote>
<p>分析:<br>1.旋转数组的特点是: 以旋转点作为界限, 两边的区间仍然保持单调的性质, 比如 [4,5,6,7,0,1,2] 和 [6,7,0,1,2,3,4]; 但是以搜索点作为界限: 左右两边的区间只存在一边必然单调, 一边可能不单调的性质; 在搜索的时候, 我们先判断以 nums[mid] 的一遍是否存在单调性, 比如我们去判断 nums[mid] 的右边是否存在单调性: 判断右边是否存在单调性的依据是最右边的元素是否大于当前元素, 如果是最最右侧的元素是更大的, 说明旋转点不在右边, 右边是单调的; 如果右边存在单调性, 我们再判断在 target 是否在右边的区间里面, 也就是增加判断 target 是介于 nums[mid] 和 nums[r]之间的值, 如果是那么就很方便地进行二分搜索; 如果不存在在右边边界, 那么只要递归地搜索左边的区间, 右边不需要再投入考虑<br>2.旋转数组的二分搜索相对与普通的二分搜索相当于多加了两层判断, 一层判断是当前搜索区间是否单调, 以及再判断当前元素是否再里面<br>3.旋转数组的二分搜索如果进入一个不单调的区间里面搜索, 该子问题的结构和原问题的结构是完全相同的, 继续递归的去搜索一个子数组, 这个数组也是一个旋转数组, 直到两边不再有任何旋转数组  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  int search(vector&lt;int&gt;&amp; nums, int target) &#123;
    int l = 0;
    int r = nums.size()-1; 
    while (l &lt;= r) &#123;
      int mid = l + (r - l) / 2;
      int midNum = nums[mid];
      if (midNum == target) &#123;
        return mid;
      &#125;
      // 判断一侧是否是单调的: 例如判断右边如果是单调的
      if (nums[mid] &lt; nums[r]) &#123;
        // 判断 target 是否在右边区间
        if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;
          l = mid + 1;
        // 不在就去左边区间搜索
        &#125; else &#123;
          r = mid - 1;
        &#125;
      // 判断另一侧左边的单调性也已知了, 因为旋转数组必然一边单调一边不单调
      &#125; else &#123;
        // 判断 target 是否在左边区间
        if (nums[mid] &gt; target &amp;&amp; target &gt;= nums[l]) &#123;
          r = mid - 1;
        // 不在就去右边区间搜索
        &#125; else &#123;
          l = mid + 1;
        &#125;
      &#125;
    &#125;
    return -1;
  &#125;
&#125;;
</code></pre>
<h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153.寻找旋转排序数组中的最小值"></a>153.寻找旋转排序数组中的最小值</h2><blockquote>
<p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。<br>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。<br>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<p>示例 1：输入：nums = [3,4,5,1,2] 输出：1 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</p>
<p>示例 2：输入：nums = [4,5,6,7,0,1,2] 输出：0 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。</p>
<p>示例 3：输入：nums = [11,13,15,17] 输出：11 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</p>
</blockquote>
<p>分析:<br>1.旋转数组满足中点二分之后, 一边单调, 一边不单调的性质<br>2.我们二分搜一次, 可以找到一边的单调区间, 更新当前的最小值为单调区间的最左侧; 然后再去另一个不单调的区间里面去尝试找更小的元素, 直到两边都是单调的情况, 不断迭代找到整个数组的最小值  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  int findMin(vector&lt;int&gt;&amp; nums) &#123;
    int ans = INT_MAX;
    int l = 0;
    int h = nums.size() - 1;
    while (l &lt;= h) &#123;
      int mid = l + (h - l) / 2;
      int midNum = nums[mid];
      // 如果左边单调, 最左侧可尝试更新最小元素
      if (midNum &gt;= nums[l]) &#123;
        ans = min(ans, nums[l]);
        l = mid + 1;
      // 如果右边单调, midNum可尝试更新最小元素
      &#125; else &#123;
        ans = min(ans, midNum);
        h = mid - 1;
      &#125;
    &#125;
    return ans;
  &#125;
&#125;;
</code></pre>
<h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h2><blockquote>
<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 O(log (m+n)) 。</p>
<p>示例 1: 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2</p>
<p>示例 2：输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p>
</blockquote>
<p>分析:<br>1.找两个数组中的中位数: 两个数组中的中位数是怎么定义的 ?<br>(i). 如果两个数组长度 一个奇数一个偶数, 因为奇+偶=奇, 那么就是正好中间这个数<br>(ii). 如果两个数组长度 一个偶数一个偶数, 因为偶+偶=偶, 那么正好就是合并排序后中间这两个数的平均数<br>(iii). 如果两个数组长度 一个奇数一个奇数, 因为奇+奇=偶, 那么正好就是合并排序后中间这两个数的平均数  </p>
<p>2.怎么忽略数组长度为奇数和数组长度为偶数的分类讨论? 总长度是 m + n. 找两个有序数组中的中位数, 相当于找 [两个数组合并且排序后第(m + n + 1) / 2 小的数] 和 [两个数组合并且排序后第 (m + n + 2)/2 小的数] 这2个结果的平均数, 无论总长度 (m + n) 是奇数还是偶数; 注意一个数组中第 k 小的数的下标是 k - 1<br>我们举 3个 例子理解一下<br>[如果总长度奇数] [1, 2, 3] 和 [4, 5, 6, 7]     :(total[4 - 1]+total[4 - 1])/2 = 4<br>[如果总长度偶数] [1, 2, 3] 和 [4, 5, 6]        :(total[3 - 1]+total[4 - 1])/2 = 3.5<br>[如果总长度偶数] [1, 2, 3, 4] 和 [5, 6, 7, 8]  :(total[4 - 1]+total[5 - 1])/2 = 3.5  </p>
<p>3.需要想办法找 [两个数组合并且排序] 中第x小的数<br>具体地，我们每次在两个数组中比较第 k/2 小的数，合并总数中找中位数, 可以通过比较子数组中找 k/2 分位数的数谁大谁小去缩小搜索空间<br>如果数组1的第 k/2 小的数 小于数组2的第 k/2 小的数，则数组1的前 k/2 个数可以舍弃，同时 k 要减去 k/2<br>如果数组2的第 k/2 小的数 小于数组1的第 k/2 小的数，则数组2的前 k/2 个数可以舍弃，同时 k 要减去 k/2<br>通过不断舍弃前 k/2 个数，最终我们可以得到第 k 小数.  </p>
<p>4.我们就可以在O(log(m+n))的时间内查找到中位数  </p>
<pre><code class="lang-cpp">class Solution &#123;
 public:
  // getKth 目标找到 nums1 和 nums2 合并排序后的第 k 小的数
  int getKth(vector&lt;int&gt; nums1, vector&lt;int&gt; nums2, int k) &#123;
    int len1 = nums1.size();
    int len2 = nums2.size();
    // 保证 nums1 数组长度是较短的一个
    if (len1 &gt; len2) &#123;
      return getKth(nums2, nums1, k);
    &#125;
    // 如果 len1 为空, 直接返回 nums2 中第 k 小的数, 下标是 k - 1
    if (len1 == 0) &#123; 
      return nums2[k - 1];
    &#125;
    // 如果是找最小的数, 可以直接比这两个数组中的最小的数, 取二者的最小的
    if (k == 1) &#123;
      return min(nums1[0], nums2[0]);
    &#125;
    // 如果 num1 中 第k/2小的 元素的 index 比 len1 还大, 在 nums1 中至多找到 第 len1 小的数
    int i = min(len1, k / 2);
    int j = min(len2, k / 2);
    // 比较 num1 的第 k/2 小的数 和 num2 的 k/2 的数的大小
    // 如果 nums1的 k/2 分位数比, nums2 的 k/2 分位数大, nums2 舍弃前一半元素
    if (nums1[i - 1] &gt; nums2[j - 1]) &#123;
      vector&lt;int&gt; tmp = vector&lt;int&gt;(nums2.begin() + j, nums2.end());
      return getKth(nums1, tmp, k - j);
    // 如果 nums2的 k/2 分位数比, nums1 的 k/2 分位数大, nums1 舍弃前一半元素
    &#125; else &#123;
      vector&lt;int&gt; tmp = vector&lt;int&gt;(nums1.begin() + i, nums1.end());
      return getKth(tmp, nums2, k - i);
    &#125;
  &#125;
  double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
    int len1 = nums1.size();
    int len2 = nums2.size();
    // 两个有序数组中的中位数等于
    // median = ((合并数组后 [len1 + len2 + 1] / 2 小的数) +  (合并数组后 [len1 + len2 + 2] / 2 小的数)) / 2
    return (getKth(nums1, nums2, (len1 + len2 + 1) / 2) + getKth(nums1, nums2, (len1 + len2 + 2) / 2)) / 2.0;
  &#125;
&#125;;
</code></pre>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2><blockquote>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p>
<p>示例 1：输入：s = “()” 输出：true</p>
<p>示例 2：输入：s = “()[]{}” 输出：true</p>
<p>示例 3：输入：s = “(]” 输出：false</p>
</blockquote>
<p>分析:<br>1.总共有 3 种类型的括号, 合法的括号都是成对的出现的, 举几个合法的例子  </p>
<pre><code class="lang-bash">(([[]]))
[()]
&#123;&#125;[[(())]]
</code></pre>
<p>2.再举几个不合法的例子<br>``` bash<br>{[}]<br>)[{</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源 goldandrabbit.github.io </span>
    </div>
</article>





    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: 'Ov23lijwoqgUkb9DZ1tA',
            clientSecret: '753c99770152a10a8bb951bb5dce14766d573d68',
            repo: 'goldandrabbit.github.io',
            owner: 'GoldAndRabbit',
            admin: ['goldandrabbit'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2018-2025
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="Toggle full screen shortcut key s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 18px 3px 15px 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 602px;
    }
    .nav.fullscreen {
        margin-left: -602px;
    }
    .nav-left {
        width: 180px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 552px;
        }
        .nav.fullscreen {
            margin-left: -552px;
        }
        .nav-left {
            width: 160px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 552px;
            margin-left: -552px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #000000;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #87CEFA;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #ffffff;
    }
    
    
    .nav-right nav a.hover > span{
        color: #DC143C !important;
    }
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
